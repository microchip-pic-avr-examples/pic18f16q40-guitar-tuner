Disassembly Listing for guitar_tuner
Generated From:
C:/Users/C50931/Projects/Guitar Tuner/guitar tuner/guitar tuner.X/dist/default/production/guitar_tuner.X.production.elf
May 14, 2020 2:22:16 PM

---  C:/Users/C50931/Projects/Guitar Tuner/guitar tuner/guitar tuner.X/mcc_generated_files/uart1.c  -----
1:             /**
2:               UART1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 uart1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the UART1 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for UART1.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.0
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.4.0
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.10 and above
21:                    MPLAB             :  MPLAB X 5.35
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            #include <xc.h>
51:            #include "uart1.h"
52:            
53:            static volatile uart1_status_t uart1RxLastError;
54:            
55:            /**
56:              Section: UART1 APIs
57:            */
58:            void (*UART1_FramingErrorHandler)(void);
59:            void (*UART1_OverrunErrorHandler)(void);
60:            void (*UART1_ErrorHandler)(void);
61:            
62:            void UART1_DefaultFramingErrorHandler(void);
63:            void UART1_DefaultOverrunErrorHandler(void);
64:            void UART1_DefaultErrorHandler(void);
65:            
66:            void UART1_Initialize(void)
5832  0E00     MOVLW 0x0
5834  0102     MOVLB 0x2
5836  6FA5     MOVWF 0xA5, BANKED
67:            {
68:                // Disable interrupts before changing states
69:            
70:                // Set the UART1 module to the options selected in the user interface.
71:            
72:                // P1L 0; 
73:                U1P1L = 0x00;
74:            
75:                // P1H 0; 
76:                U1P1H = 0x00;
5838  0E00     MOVLW 0x0
583A  6FA6     MOVWF 0xA6, BANKED
77:            
78:                // P2L 0; 
79:                U1P2L = 0x00;
583C  0E00     MOVLW 0x0
583E  6FA7     MOVWF 0xA7, BANKED
80:            
81:                // P2H 0; 
82:                U1P2H = 0x00;
5840  0E00     MOVLW 0x0
5842  6FA8     MOVWF 0xA8, BANKED
83:            
84:                // P3L 0; 
85:                U1P3L = 0x00;
5844  0E00     MOVLW 0x0
5846  6FA9     MOVWF 0xA9, BANKED
86:            
87:                // P3H 0; 
88:                U1P3H = 0x00;
5848  0E00     MOVLW 0x0
584A  6FAA     MOVWF 0xAA, BANKED
89:            
90:                // BRGS high speed; MODE Asynchronous 8-bit mode; RXEN disabled; TXEN enabled; ABDEN disabled; 
91:                U1CON0 = 0xA0;
584C  0EA0     MOVLW 0xA0
584E  6FAB     MOVWF 0xAB, BANKED
92:            
93:                // RXBIMD Set RXBKIF on rising RX input; BRKOVR disabled; WUE disabled; SENDB disabled; ON enabled; 
94:                U1CON1 = 0x80;
5850  0E80     MOVLW 0x80
5852  6FAC     MOVWF ACTCON, BANKED
95:            
96:                // TXPOL not inverted; FLO off; C0EN Checksum Mode 0; RXPOL not inverted; RUNOVF RX input shifter stops all activity; STP Transmit 1Stop bit, receiver verifies first Stop bit; 
97:                U1CON2 = 0x00;
5854  0E00     MOVLW 0x0
5856  6FAD     MOVWF OSCCON1, BANKED
98:            
99:                // BRGL 138; 
100:               U1BRGL = 0x8A;
5858  0E8A     MOVLW 0x8A
585A  6FAE     MOVWF OSCCON2, BANKED
101:           
102:               // BRGH 0; 
103:               U1BRGH = 0x00;
585C  0E00     MOVLW 0x0
585E  6FAF     MOVWF OSCCON3, BANKED
104:           
105:               // STPMD in middle of first Stop bit; TXWRE No error; 
106:               U1FIFO = 0x00;
5860  0E00     MOVLW 0x0
5862  6FB0     MOVWF OSCTUNE, BANKED
107:           
108:               // ABDIF Auto-baud not enabled or not complete; WUIF WUE not enabled by software; ABDIE disabled; 
109:               U1UIR = 0x00;
5864  0E00     MOVLW 0x0
5866  6FB1     MOVWF OSCFRQ, BANKED
110:           
111:               // ABDOVF Not overflowed; TXCIF 0; RXBKIF No Break detected; RXFOIF not overflowed; CERIF No Checksum error; 
112:               U1ERRIR = 0x00;
5868  0E00     MOVLW 0x0
586A  6FB2     MOVWF OSCSTAT, BANKED
113:           
114:               // TXCIE disabled; FERIE disabled; TXMTIE disabled; ABDOVE disabled; CERIE disabled; RXFOIE disabled; PERIE disabled; RXBKIE disabled; 
115:               U1ERRIE = 0x00;
586C  0E00     MOVLW 0x0
586E  6FB3     MOVWF OSCEN, BANKED
116:           
117:           
118:               UART1_SetFramingErrorHandler(UART1_DefaultFramingErrorHandler);
5870  0E00     MOVLW 0x0
5872  6E01     MOVWF 0x1, ACCESS
5874  0E00     MOVLW 0x0
5876  6E02     MOVWF 0x2, ACCESS
5878  0E00     MOVLW 0x0
587A  6E03     MOVWF 0x3, ACCESS
587C  ECB3     CALL 0x5D66, 0
587E  F02E     NOP
119:               UART1_SetOverrunErrorHandler(UART1_DefaultOverrunErrorHandler);
5880  0E00     MOVLW 0x0
5882  6E01     MOVWF 0x1, ACCESS
5884  0E00     MOVLW 0x0
5886  6E02     MOVWF 0x2, ACCESS
5888  0E00     MOVLW 0x0
588A  6E03     MOVWF 0x3, ACCESS
588C  ECAC     CALL 0x5D58, 0
588E  F02E     NOP
120:               UART1_SetErrorHandler(UART1_DefaultErrorHandler);
5890  0E00     MOVLW 0x0
5892  6E01     MOVWF 0x1, ACCESS
5894  0E00     MOVLW 0x0
5896  6E02     MOVWF 0x2, ACCESS
5898  0E00     MOVLW 0x0
589A  6E03     MOVWF 0x3, ACCESS
589C  ECBA     CALL 0x5D74, 0
589E  F02E     NOP
121:           
122:               uart1RxLastError.status = 0;
58A0  0E00     MOVLW 0x0
58A2  0105     MOVLB 0x5
58A4  6FE3     MOVWF 0xE3, BANKED
123:           
124:           }
58A6  0012     RETURN 0
125:           
126:           bool UART1_is_rx_ready(void)
127:           {
128:               return (bool)(PIR4bits.U1RXIF);
129:           }
130:           
131:           bool UART1_is_tx_ready(void)
132:           {
133:               return (bool)(PIR4bits.U1TXIF && U1CON0bits.TXEN);
134:           }
135:           
136:           bool UART1_is_tx_done(void)
137:           {
138:               return U1ERRIRbits.TXMTIF;
139:           }
140:           
141:           uart1_status_t UART1_get_last_status(void){
142:               return uart1RxLastError;
143:           }
144:           
145:           uint8_t UART1_Read(void)
146:           {
147:               while(!PIR4bits.U1RXIF)
148:               {
149:               }
150:           
151:               uart1RxLastError.status = 0;
152:           
153:               if(U1ERRIRbits.FERIF){
154:                   uart1RxLastError.ferr = 1;
155:                   UART1_FramingErrorHandler();
156:               }
157:           
158:               if(U1ERRIRbits.RXFOIF){
159:                   uart1RxLastError.oerr = 1;
160:                   UART1_OverrunErrorHandler();
161:               }
162:           
163:               if(uart1RxLastError.status){
164:                   UART1_ErrorHandler();
165:               }
166:           
167:               return U1RXB;
168:           }
169:           
170:           void UART1_Write(uint8_t txData)
5D40  6E01     MOVWF 0x1, ACCESS
171:           {
172:               while(0 == PIR4bits.U1TXIF)
5D42  A2B2     BTFSS 0xFB2, 1, ACCESS
5D44  EFA6     GOTO 0x5D4C
5D46  F02E     NOP
5D48  EFA8     GOTO 0x5D50
5D4A  F02E     NOP
5D4C  EFA1     GOTO 0x5D42
5D4E  F02E     NOP
173:               {
174:               }
175:           
176:               U1TXB = txData;    // Write the data byte to the USART.
5D52  F404     NOP
5D54  F2A3     NOP
177:           }
5D56  0012     RETURN 0
178:           
179:           char getch(void)
180:           {
181:               return UART1_Read();
182:           }
183:           
184:           void putch(char txData)
5D90  6E02     MOVWF 0x2, ACCESS
185:           {
186:               UART1_Write(txData);
5D92  5002     MOVF 0x2, W, ACCESS
5D94  ECA0     CALL 0x5D40, 0
5D96  F02E     NOP
187:           }
5D98  0012     RETURN 0
188:           
189:           
190:           
191:           
192:           
193:           void UART1_DefaultFramingErrorHandler(void){}
194:           
195:           void UART1_DefaultOverrunErrorHandler(void){}
196:           
197:           void UART1_DefaultErrorHandler(void){
198:           }
199:           
200:           void UART1_SetFramingErrorHandler(void (* interruptHandler)(void)){
5D66  C501     MOVFF __pcstackCOMRAM, UART1_FramingErrorHandler
5D68  F5EA     NOP
5D6A  C502     MOVFF txData, 0x5EB
5D6C  F5EB     NOP
5D6E  C503     MOVFF _r, 0x5EC
5D70  F5EC     NOP
201:               UART1_FramingErrorHandler = interruptHandler;
202:           }
5D72  0012     RETURN 0
203:           
204:           void UART1_SetOverrunErrorHandler(void (* interruptHandler)(void)){
5D58  C501     MOVFF __pcstackCOMRAM, UART1_OverrunErrorHandler
5D5A  F5E7     NOP
5D5C  C502     MOVFF txData, 0x5E8
5D5E  F5E8     NOP
5D60  C503     MOVFF _r, 0x5E9
5D62  F5E9     NOP
205:               UART1_OverrunErrorHandler = interruptHandler;
206:           }
5D64  0012     RETURN 0
207:           
208:           void UART1_SetErrorHandler(void (* interruptHandler)(void)){
5D74  C501     MOVFF __pcstackCOMRAM, UART1_ErrorHandler
5D76  F5E4     NOP
5D78  C502     MOVFF txData, 0x5E5
5D7A  F5E5     NOP
5D7C  C503     MOVFF _r, 0x5E6
5D7E  F5E6     NOP
209:               UART1_ErrorHandler = interruptHandler;
210:           }
5D80  0012     RETURN 0
211:           
212:           
213:           
214:           
215:           
216:           
217:           /**
218:             End of File
219:           */
---  C:/Users/C50931/Projects/Guitar Tuner/guitar tuner/guitar tuner.X/mcc_generated_files/tmr0.c  ------
1:             /**
2:               TMR0 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr0.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR0 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR0.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.0
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  3.10
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.10 and above
21:                    MPLAB 	          :  MPLAB X 5.35
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr0.h"
53:            
54:            
55:            /**
56:              Section: TMR0 APIs
57:            */
58:            
59:            void (*TMR0_InterruptHandler)(void);
60:            
61:            void TMR0_Initialize(void)
5C46  0E40     MOVLW 0x40
5C48  0103     MOVLB 0x3
5C4A  6F1B     MOVWF 0x1B, BANKED
62:            {
63:                // Set TMR0 to the options selected in the User Interface
64:            
65:                // T0CS FOSC/4; T0CKPS 1:1; T0ASYNC synchronised; 
66:                T0CON1 = 0x40;
67:            
68:                // TMR0H 223; 
69:                TMR0H = 0xDF;
5C4C  0EDF     MOVLW 0xDF
5C4E  6F19     MOVWF 0x19, BANKED
70:            
71:                // TMR0L 0; 
72:                TMR0L = 0x00;
5C50  0E00     MOVLW 0x0
5C52  6F18     MOVWF 0x18, BANKED
73:            
74:                // Clear Interrupt flag before enabling the interrupt
75:                PIR3bits.TMR0IF = 0;
5C54  9EB1     BCF 0xFB1, 7, ACCESS
76:            
77:                // Enabling TMR0 interrupt.
78:                PIE3bits.TMR0IE = 1;
5C56  8EA1     BSF 0xFA1, 7, ACCESS
79:            
80:                // Set Default Interrupt Handler
81:                TMR0_SetInterruptHandler(TMR0_DefaultInterruptHandler);
5C58  0E9E     MOVLW 0x9E
5C5A  6E01     MOVWF 0x1, ACCESS
5C5C  0E5D     MOVLW 0x5D
5C5E  6E02     MOVWF 0x2, ACCESS
5C60  0E00     MOVLW 0x0
5C62  6E03     MOVWF 0x3, ACCESS
5C64  ECC1     CALL 0x5D82, 0
5C66  F02E     NOP
82:            
83:                // T0OUTPS 1:8; T0EN enabled; T016BIT 8-bit; 
84:                T0CON0 = 0x87;
5C68  0E87     MOVLW 0x87
5C6A  0103     MOVLB 0x3
5C6C  6F1A     MOVWF 0x1A, BANKED
85:            }
5C6E  0012     RETURN 0
86:            
87:            void TMR0_StartTimer(void)
88:            {
89:                // Start the Timer by writing to TMR0ON bit
90:                T0CON0bits.T0EN = 1;
91:            }
92:            
93:            void TMR0_StopTimer(void)
94:            {
95:                // Stop the Timer by writing to TMR0ON bit
96:                T0CON0bits.T0EN = 0;
97:            }
98:            
99:            uint8_t TMR0_ReadTimer(void)
100:           {
101:               uint8_t readVal;
102:           
103:               // read Timer0, low register only
104:               readVal = TMR0L;
105:           
106:               return readVal;
107:           }
108:           
109:           void TMR0_WriteTimer(uint8_t timerVal)
110:           {
111:               // Write to Timer0 registers, low register only
112:               TMR0L = timerVal;
113:            }
114:           
115:           void TMR0_Reload(uint8_t periodVal)
116:           {
117:              // Write to Timer0 registers, high register only
118:              TMR0H = periodVal;
119:           }
120:           
121:           void TMR0_ISR(void)
5BE8  9EB1     BCF 0xFB1, 7, ACCESS
122:           {
123:               // clear the TMR0 interrupt flag
124:               PIR3bits.TMR0IF = 0;
125:               if(TMR0_InterruptHandler)
5BEA  0105     MOVLB 0x5
5BEC  51ED     MOVF DMAnDPTRH, W, BANKED
5BEE  11EE     IORWF DMAnDSZ, W, BANKED
5BF0  11EF     IORWF DMAnDSZH, W, BANKED
5BF2  B4D8     BTFSC 0xFD8, 2, ACCESS
5BF4  EFFE     GOTO 0x5BFC
5BF6  F02D     NOP
5BF8  EF00     GOTO 0x5C00
5BFA  F02E     NOP
5BFC  EF0D     GOTO 0x5C1A
5BFE  F02E     NOP
126:               {
127:                   TMR0_InterruptHandler();
5C00  D802     RCALL 0x5C06
5C02  EF0D     GOTO 0x5C1A
5C04  F02E     NOP
5C06  0005     PUSH
5C08  6EFA     MOVWF 0xFFA, ACCESS
5C0A  51ED     MOVF DMAnDPTRH, W, BANKED
5C0C  6EFD     MOVWF 0xFFD, ACCESS
5C0E  51EE     MOVF DMAnDSZ, W, BANKED
5C10  6EFE     MOVWF 0xFFE, ACCESS
5C12  51EF     MOVF DMAnDSZH, W, BANKED
5C14  6EFF     MOVWF 0xFFF, ACCESS
5C16  50FA     MOVF 0xFFA, W, ACCESS
5C18  0012     RETURN 0
128:               }
129:           
130:               // add your TMR0 interrupt custom code
131:           }
5C1A  0012     RETURN 0
132:           
133:           
134:           void TMR0_SetInterruptHandler(void (* InterruptHandler)(void)){
5D82  C501     MOVFF __pcstackCOMRAM, TMR0_InterruptHandler
5D84  F5ED     NOP
5D86  C502     MOVFF txData, 0x5EE
5D88  F5EE     NOP
5D8A  C503     MOVFF _r, 0x5EF
5D8C  F5EF     NOP
135:               TMR0_InterruptHandler = InterruptHandler;
136:           }
5D8E  0012     RETURN 0
137:           
138:           void TMR0_DefaultInterruptHandler(void){
5D9E  0012     RETURN 0
139:               // add your TMR0 interrupt custom code
140:               // or set custom function using TMR0_SetInterruptHandler()
141:           }
142:           
143:           /**
144:             End of File
145:           */
---  C:/Users/C50931/Projects/Guitar Tuner/guitar tuner/guitar tuner.X/mcc_generated_files/pin_manager.c  
1:             /**
2:               Generated Pin Manager File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 pin_manager.c
9:             
10:              Summary:
11:                This is the Pin Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for pin APIs for all pins selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.0
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.10 and above
21:                    MPLAB             :  MPLAB X 5.35
22:            
23:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include "pin_manager.h"
50:            
51:            
52:            
53:            
54:            
55:            void PIN_MANAGER_Initialize(void)
579C  0E00     MOVLW 0x0
579E  6EC2     MOVWF 0xFC2, ACCESS
56:            {
57:                /**
58:                LATx registers
59:                */
60:                LATE = 0x00;
61:                LATD = 0x00;
57A0  0E00     MOVLW 0x0
57A2  6EC1     MOVWF 0xFC1, ACCESS
62:                LATA = 0x00;
57A4  0E00     MOVLW 0x0
57A6  6EBE     MOVWF 0xFBE, ACCESS
63:                LATB = 0x00;
57A8  0E00     MOVLW 0x0
57AA  6EBF     MOVWF 0xFBF, ACCESS
64:                LATC = 0x00;
57AC  0E00     MOVLW 0x0
57AE  6EC0     MOVWF 0xFC0, ACCESS
65:            
66:                /**
67:                TRISx registers
68:                */
69:                TRISE = 0x07;
57B0  0E07     MOVLW 0x7
57B2  6ECA     MOVWF 0xFCA, ACCESS
70:                TRISA = 0x7F;
57B4  0E7F     MOVLW 0x7F
57B6  6EC6     MOVWF 0xFC6, ACCESS
71:                TRISB = 0xFF;
57B8  68C7     SETF 0xFC7, ACCESS
72:                TRISC = 0xBF;
57BA  0EBF     MOVLW 0xBF
57BC  6EC8     MOVWF 0xFC8, ACCESS
73:                TRISD = 0xFF;
57BE  68C9     SETF 0xFC9, ACCESS
74:            
75:                /**
76:                ANSELx registers
77:                */
78:                ANSELD = 0xFF;
57C0  0104     MOVLB 0x4
57C2  6918     SETF 0x18, BANKED
79:                ANSELC = 0x3F;
57C4  0E3F     MOVLW 0x3F
57C6  6F10     MOVWF 0x10, BANKED
80:                ANSELB = 0xFF;
57C8  6908     SETF 0x8, BANKED
81:                ANSELE = 0x07;
57CA  0E07     MOVLW 0x7
57CC  6F20     MOVWF 0x20, BANKED
82:                ANSELA = 0x7F;
57CE  0E7F     MOVLW 0x7F
57D0  6F00     MOVWF txData, BANKED
83:            
84:                /**
85:                WPUx registers
86:                */
87:                WPUD = 0x00;
57D2  0E00     MOVLW 0x0
57D4  6F19     MOVWF 0x19, BANKED
88:                WPUE = 0x00;
57D6  0E00     MOVLW 0x0
57D8  6F21     MOVWF 0x21, BANKED
89:                WPUB = 0x00;
57DA  0E00     MOVLW 0x0
57DC  6F09     MOVWF 0x9, BANKED
90:                WPUA = 0x00;
57DE  0E00     MOVLW 0x0
57E0  6F01     MOVWF 0x1, BANKED
91:                WPUC = 0x00;
57E2  0E00     MOVLW 0x0
57E4  6F11     MOVWF 0x11, BANKED
92:            
93:                /**
94:                RxyI2C registers
95:                */
96:                RB1I2C = 0x00;
57E6  0E00     MOVLW 0x0
57E8  0102     MOVLB 0x2
57EA  6F89     MOVWF SPI1BAUD, BANKED
97:                RB2I2C = 0x00;
57EC  0E00     MOVLW 0x0
57EE  6F88     MOVWF SPI1TWIDTH, BANKED
98:                RC3I2C = 0x00;
57F0  0E00     MOVLW 0x0
57F2  6F87     MOVWF SPI1STATUS, BANKED
99:                RC4I2C = 0x00;
57F4  0E00     MOVLW 0x0
57F6  6F86     MOVWF SPI1CON2, BANKED
100:           
101:               /**
102:               ODx registers
103:               */
104:               ODCONE = 0x00;
57F8  0E00     MOVLW 0x0
57FA  0104     MOVLB 0x4
57FC  6F22     MOVWF 0x22, BANKED
105:               ODCONA = 0x00;
57FE  0E00     MOVLW 0x0
5800  6F02     MOVWF 0x2, BANKED
106:               ODCONB = 0x00;
5802  0E00     MOVLW 0x0
5804  6F0A     MOVWF 0xA, BANKED
107:               ODCONC = 0x00;
5806  0E00     MOVLW 0x0
5808  6F12     MOVWF 0x12, BANKED
108:               ODCOND = 0x00;
580A  0E00     MOVLW 0x0
580C  6F1A     MOVWF 0x1A, BANKED
109:           
110:               /**
111:               SLRCONx registers
112:               */
113:               SLRCONA = 0xFF;
580E  6903     SETF 0x3, BANKED
114:               SLRCONB = 0xFF;
5810  690B     SETF 0xB, BANKED
115:               SLRCONC = 0xFF;
5812  6913     SETF 0x13, BANKED
116:               SLRCOND = 0xFF;
5814  691B     SETF 0x1B, BANKED
117:               SLRCONE = 0x07;
5816  0E07     MOVLW 0x7
5818  6F23     MOVWF 0x23, BANKED
118:           
119:               /**
120:               INLVLx registers
121:               */
122:               INLVLA = 0xFF;
581A  6904     SETF 0x4, BANKED
123:               INLVLB = 0xFF;
581C  690C     SETF 0xC, BANKED
124:               INLVLC = 0xFF;
581E  6914     SETF 0x14, BANKED
125:               INLVLD = 0xFF;
5820  691C     SETF 0x1C, BANKED
126:               INLVLE = 0x0F;
5822  0E0F     MOVLW 0xF
5824  6F24     MOVWF 0x24, BANKED
127:           
128:           
129:           
130:           
131:           
132:              
133:               
134:           	
135:               RC6PPS = 0x20;   //RC6->UART1:TX1;    
5826  0E20     MOVLW 0x20
5828  0102     MOVLB 0x2
582A  6F17     MOVWF 0x17, BANKED
136:               U1RXPPS = 0x17;   //RC7->UART1:RX1;    
582C  0E17     MOVLW 0x17
582E  6F72     MOVWF CM1NCH, BANKED
137:           }
5830  0012     RETURN 0
138:             
139:           void PIN_MANAGER_IOC(void)
140:           {   
141:           }
142:           
143:           /**
144:            End of File
145:           */
---  C:/Users/C50931/Projects/Guitar Tuner/guitar tuner/guitar tuner.X/mcc_generated_files/mcc.c  -------
1:             /**
2:               @Generated PIC10 / PIC12 / PIC16 / PIC18 MCUs Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 mcc.c
9:             
10:              @Summary:
11:                This is the mcc.c file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.0
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.00
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.10 and above or later
21:                    MPLAB             :  MPLAB X 5.35
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            #include "mcc.h"
48:            
49:            
50:            void SYSTEM_Initialize(void)
5D06  ECCD     CALL 0x5D9A, 0
5D08  F02E     NOP
51:            {
52:                INTERRUPT_Initialize();
53:                PMD_Initialize();
5D0A  EC60     CALL 0x5CC0, 0
5D0C  F02E     NOP
54:                PIN_MANAGER_Initialize();
5D0E  ECCE     CALL 0x579C, 0
5D10  F02B     NOP
55:                OSCILLATOR_Initialize();
5D12  EC92     CALL 0x5D24, 0
5D14  F02E     NOP
56:                ADCC_Initialize();
5D16  ECEC     CALL 0x59D8, 0
5D18  F02C     NOP
57:                TMR0_Initialize();
5D1A  EC23     CALL 0x5C46, 0
5D1C  F02E     NOP
58:                UART1_Initialize();
5D1E  EC19     CALL 0x5832, 0
5D20  F02C     NOP
59:            }
5D22  0012     RETURN 0
60:            
61:            void OSCILLATOR_Initialize(void)
5D24  0E60     MOVLW 0x60
5D26  0100     MOVLB 0x0
5D28  6FAD     MOVWF OSCCON1, BANKED
62:            {
63:                // NOSC HFINTOSC; NDIV 1; 
64:                OSCCON1 = 0x60;
65:                // CSWHOLD may proceed; SOSCPWR Low power; 
66:                OSCCON3 = 0x00;
5D2A  0E00     MOVLW 0x0
5D2C  6FAF     MOVWF OSCCON3, BANKED
67:                // MFOEN disabled; LFOEN disabled; ADOEN disabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled; 
68:                OSCEN = 0x00;
5D2E  0E00     MOVLW 0x0
5D30  6FB3     MOVWF OSCEN, BANKED
69:                // HFFRQ 64_MHz; 
70:                OSCFRQ = 0x08;
5D32  0E08     MOVLW 0x8
5D34  6FB1     MOVWF OSCFRQ, BANKED
71:                // TUN 0; 
72:                OSCTUNE = 0x00;
5D36  0E00     MOVLW 0x0
5D38  6FB0     MOVWF OSCTUNE, BANKED
73:                // ACTUD enabled; ACTEN disabled; 
74:                ACTCON = 0x00;
5D3A  0E00     MOVLW 0x0
5D3C  6FAC     MOVWF ACTCON, BANKED
75:            }
5D3E  0012     RETURN 0
76:            
77:            void PMD_Initialize(void)
5CC0  0E00     MOVLW 0x0
5CC2  0100     MOVLB 0x0
5CC4  6F60     MOVWF PMD0, BANKED
78:            {
79:                // CLKRMD CLKR enabled; SYSCMD SYSCLK enabled; SCANMD SCANNER enabled; FVRMD FVR enabled; IOCMD IOC enabled; CRCMD CRC enabled; HLVDMD HLVD enabled; 
80:                PMD0 = 0x00;
81:                // TMR0MD TMR0 enabled; TMR1MD TMR1 enabled; TMR4MD TMR4 enabled; SMT1MD SMT1 enabled; TMR5MD TMR5 enabled; TMR2MD TMR2 enabled; TMR3MD TMR3 enabled; TMR6MD TMR6 enabled; 
82:                PMD1 = 0x00;
5CC6  0E00     MOVLW 0x0
5CC8  6F61     MOVWF PMD1, BANKED
83:                // ZCDMD ZCD enabled; ADCMD ADC enabled; ACTMD ACT enabled; CM2MD CM2 enabled; CM1MD CM1 enabled; DAC1MD DAC1 enabled; 
84:                PMD3 = 0x00;
5CCA  0E00     MOVLW 0x0
5CCC  6F63     MOVWF PMD3, BANKED
85:                // NCO1MD NCO1 enabled; NCO2MD NCO2 enabled; DSM1MD DSM1 enabled; CWG3MD CWG3 enabled; CWG2MD CWG2 enabled; CWG1MD CWG1 enabled; NCO3MD NCO3 enabled; 
86:                PMD4 = 0x00;
5CCE  0E00     MOVLW 0x0
5CD0  6F64     MOVWF PMD4, BANKED
87:                // CCP2MD CCP2 enabled; CCP1MD CCP1 enabled; PWM2MD PWM2 enabled; CCP3MD CCP3 enabled; PWM1MD PWM1 enabled; PWM3MD PWM3 enabled; 
88:                PMD5 = 0x00;
5CD2  0E00     MOVLW 0x0
5CD4  6F65     MOVWF PMD5, BANKED
89:                // U5MD UART5 enabled; U4MD UART4 enabled; U3MD UART3 enabled; U2MD UART2 enabled; U1MD UART1 enabled; SPI2MD SPI2 enabled; SPI1MD SPI1 enabled; I2C1MD I2C1 enabled; 
90:                PMD6 = 0x00;
5CD6  0E00     MOVLW 0x0
5CD8  6F66     MOVWF PMD6, BANKED
91:                // CLC5MD CLC5 enabled; CLC6MD CLC6 enabled; CLC3MD CLC3 enabled; CLC4MD CLC4 enabled; CLC7MD CLC7 enabled; CLC8MD CLC8 enabled; CLC1MD CLC1 enabled; CLC2MD CLC2 enabled; 
92:                PMD7 = 0x00;
5CDA  0E00     MOVLW 0x0
5CDC  6F67     MOVWF PMD7, BANKED
93:                // DMA5MD DMA5 enabled; DMA6MD DMA6 enabled; DMA1MD DMA1 enabled; DMA2MD DMA2 enabled; DMA3MD DMA3 enabled; DMA4MD DMA4 enabled; 
94:                PMD8 = 0x00;
5CDE  0E00     MOVLW 0x0
5CE0  6F68     MOVWF PMD8, BANKED
95:            }
5CE2  0012     RETURN 0
96:            
97:            
98:            /**
99:             End of File
100:           */
---  C:/Users/C50931/Projects/Guitar Tuner/guitar tuner/guitar tuner.X/mcc_generated_files/interrupt_manager.c
1:             /**
2:               Generated Interrupt Manager Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 interrupt_manager.c
9:             
10:              @Summary:
11:                This is the Interrupt Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for global interrupt handling.
15:                For individual peripheral handlers please see the peripheral driver for
16:                all modules selected in the GUI.
17:                Generation Information :
18:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.0
19:                    Device            :  PIC18F47Q43
20:                    Driver Version    :  2.03
21:                The generated drivers are tested against the following:
22:                    Compiler          :  XC8 2.10 and above or later
23:                    MPLAB 	          :  MPLAB X 5.35
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include "interrupt_manager.h"
50:            #include "mcc.h"
51:            
52:            void  INTERRUPT_Initialize (void)
5D9A  9AD6     BCF 0xFD6, 5, ACCESS
53:            {
54:                // Disable Interrupt Priority Vectors (16CXXX Compatibility Mode)
55:                INTCON0bits.IPEN = 0;
56:            }
5D9C  0012     RETURN 0
57:            
58:            void __interrupt() INTERRUPT_InterruptManager (void)
5CE4  AEA1     BTFSS 0xFA1, 7, ACCESS
5CE6  EF77     GOTO 0x5CEE
5CE8  F02E     NOP
5CEA  EF79     GOTO 0x5CF2
5CEC  F02E     NOP
5CEE  EF82     GOTO 0x5D04
5CF0  F02E     NOP
5CF2  AEB1     BTFSS 0xFB1, 7, ACCESS
5CF4  EF7E     GOTO 0x5CFC
5CF6  F02E     NOP
5CF8  EF80     GOTO 0x5D00
5CFA  F02E     NOP
5CFC  EF82     GOTO 0x5D04
5CFE  F02E     NOP
59:            {
60:                // interrupt handler
61:                if(PIE3bits.TMR0IE == 1 && PIR3bits.TMR0IF == 1)
62:                {
63:                    TMR0_ISR();
5D00  ECF4     CALL 0x5BE8, 0
5D02  F02D     NOP
64:                }
65:                else
66:                {
67:                    //Unhandled Interrupt
68:                }
69:            }
5D04  0011     RETFIE 1
70:            /**
71:             End of File
72:            */
---  C:/Users/C50931/Projects/Guitar Tuner/guitar tuner/guitar tuner.X/mcc_generated_files/adcc.c  ------
1:             /**
2:               ADCC Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 adcc.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the ADCC driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides implementations for driver APIs for ADCC.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.0
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.1.4
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.10 and above
21:                    MPLAB             :  MPLAB X 5.35
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "adcc.h"
53:            
54:            /**
55:              Section: ADCC Module Variables
56:            */
57:            
58:            /**
59:              Section: ADCC Module APIs
60:            */
61:            
62:            void ADCC_Initialize(void)
59D8  0E00     MOVLW 0x0
59DA  0103     MOVLB 0x3
59DC  6FD9     MOVWF CLCnSEL1, BANKED
63:            {
64:                // set the ADCC to the options selected in the User Interface
65:                // ADLTH 0; 
66:                ADLTHL = 0x00;
67:                // ADLTH 0; 
68:                ADLTHH = 0x00;
59DE  0E00     MOVLW 0x0
59E0  6FDA     MOVWF CLCnSEL2, BANKED
69:                // ADUTH 0; 
70:                ADUTHL = 0x00;
59E2  0E00     MOVLW 0x0
59E4  6FDB     MOVWF CLCnSEL3, BANKED
71:                // ADUTH 0; 
72:                ADUTHH = 0x00;
59E6  0E00     MOVLW 0x0
59E8  6FDC     MOVWF CLCnGLS0, BANKED
73:                // ADSTPT 0; 
74:                ADSTPTL = 0x00;
59EA  0E00     MOVLW 0x0
59EC  6FDF     MOVWF CLCnGLS3, BANKED
75:                // ADSTPT 0; 
76:                ADSTPTH = 0x00;
59EE  0E00     MOVLW 0x0
59F0  6FE0     MOVWF 0xE0, BANKED
77:                // ADACC 0; 
78:                ADACCU = 0x00;
59F2  0E00     MOVLW 0x0
59F4  6FE5     MOVWF 0xE5, BANKED
79:                // ADRPT 0; 
80:                ADRPT = 0x00;
59F6  0E00     MOVLW 0x0
59F8  6FE7     MOVWF 0xE7, BANKED
81:                // PCH ANA1; 
82:                ADPCH = 0x01;
59FA  0E01     MOVLW 0x1
59FC  6FEC     MOVWF DMAnDPTR, BANKED
83:                // ADACQ 0; 
84:                ADACQL = 0x00;
59FE  0E00     MOVLW 0x0
5A00  6FEE     MOVWF DMAnDSZ, BANKED
85:                // ADACQ 0; 
86:                ADACQH = 0x00;
5A02  0E00     MOVLW 0x0
5A04  6FEF     MOVWF DMAnDSZH, BANKED
87:                // CAP Additional uC disabled; 
88:                ADCAP = 0x00;
5A06  0E00     MOVLW 0x0
5A08  6FF0     MOVWF DMAnDSA, BANKED
89:                // ADPRE 0; 
90:                ADPREL = 0x00;
5A0A  0E00     MOVLW 0x0
5A0C  6FF1     MOVWF DMAnDSAH, BANKED
91:                // ADPRE 0; 
92:                ADPREH = 0x00;
5A0E  0E00     MOVLW 0x0
5A10  6FF2     MOVWF DMAnSCNT, BANKED
93:                // ADDSEN disabled; ADGPOL digital_low; ADIPEN disabled; ADPPOL Vss; 
94:                ADCON1 = 0x00;
5A12  0E00     MOVLW 0x0
5A14  6FF4     MOVWF DMAnSPTR, BANKED
95:                // ADCRS 0; ADMD Basic_mode; ADACLR disabled; ADPSIS RES; 
96:                ADCON2 = 0x00;
5A16  0E00     MOVLW 0x0
5A18  6FF5     MOVWF DMAnSPTRH, BANKED
97:                // ADCALC First derivative of Single measurement; ADTMD disabled; ADSOI ADGO not cleared; 
98:                ADCON3 = 0x00;
5A1A  0E00     MOVLW 0x0
5A1C  6FF6     MOVWF DMAnSPTRU, BANKED
99:                // ADMATH registers not updated; 
100:               ADSTAT = 0x00;
5A1E  0E00     MOVLW 0x0
5A20  6FF7     MOVWF DMAnSSZ, BANKED
101:               // ADNREF VSS; ADPREF VDD; 
102:               ADREF = 0x00;
5A22  0E00     MOVLW 0x0
5A24  6FF8     MOVWF DMAnSSZH, BANKED
103:               // ADACT TMR0; 
104:               ADACT = 0x02;
5A26  0E02     MOVLW 0x2
5A28  6FF9     MOVWF DMAnSSA, BANKED
105:               // ADCS FOSC/32; 
106:               ADCLK = 0x0F;
5A2A  0E0F     MOVLW 0xF
5A2C  6FFA     MOVWF DMAnSSAH, BANKED
107:               // ADGO stop; ADFM left; ADON enabled; ADCS FOSC/ADCLK; ADCONT disabled; 
108:               ADCON0 = 0x80;
5A2E  0E80     MOVLW 0x80
5A30  6FF3     MOVWF DMAnSCNTH, BANKED
109:               
110:           
111:           }
5A32  0012     RETURN 0
112:           
113:           void ADCC_StartConversion(adcc_channel_t channel)
114:           {
115:               // select the A/D channel
116:               ADPCH = channel;      
117:             
118:               // Turn on the ADC module
119:               ADCON0bits.ADON = 1;
120:           
121:               // Start the conversion
122:               ADCON0bits.ADGO = 1;
123:           }
124:           
125:           bool ADCC_IsConversionDone(void)
126:           {
127:               // Start the conversion
128:               return ((unsigned char)(!ADCON0bits.ADGO));
129:           }
130:           
131:           adc_result_t ADCC_GetConversionResult(void)
132:           {
133:               // Return the result
134:               return ((adc_result_t)((ADRESH << 8) + ADRESL));
135:           }
136:           
137:           adc_result_t ADCC_GetSingleConversion(adcc_channel_t channel)
138:           {
139:               // select the A/D channel
140:               ADPCH = channel;  
141:           
142:               // Turn on the ADC module
143:               ADCON0bits.ADON = 1;
144:           	
145:               //Disable the continuous mode.
146:               ADCON0bits.ADCONT = 0;    
147:           
148:               // Start the conversion
149:               ADCON0bits.ADGO = 1;
150:           
151:           
152:               // Wait for the conversion to finish
153:               while (ADCON0bits.ADGO)
154:               {
155:               }
156:               
157:               
158:               // Conversion finished, return the result
159:               return ((adc_result_t)((ADRESH << 8) + ADRESL));
160:           }
161:           
162:           void ADCC_StopConversion(void)
163:           {
164:               //Reset the ADGO bit.
165:               ADCON0bits.ADGO = 0;
166:           }
167:           
168:           void ADCC_SetStopOnInterrupt(void)
169:           {
170:               //Set the ADSOI bit.
171:               ADCON3bits.ADSOI = 1;
172:           }
173:           
174:           void ADCC_DischargeSampleCapacitor(void)
175:           {
176:               //Set the ADC channel to AVss.
177:               ADPCH = 0x3b;   
178:           }
179:           
180:           void ADCC_LoadAcquisitionRegister(uint16_t acquisitionValue)
181:           {
182:               //Load the ADACQH and ADACQL registers.
183:               ADACQH = acquisitionValue >> 8; 
184:               ADACQL = acquisitionValue;  
185:           }
186:           
187:           void ADCC_SetPrechargeTime(uint16_t prechargeTime)
188:           {
189:               //Load the ADPREH and ADPREL registers.
190:               ADPREH = prechargeTime >> 8;  
191:               ADPREL = prechargeTime;
192:           }
193:           
194:           void ADCC_SetRepeatCount(uint8_t repeatCount)
195:           {
196:               //Load the ADRPT register.
197:               ADRPT = repeatCount;   
198:           }
199:           
200:           uint8_t ADCC_GetCurrentCountofConversions(void)
201:           {
202:               //Return the contents of ADCNT register
203:               return ADCNT;
204:           }
205:           
206:           void ADCC_ClearAccumulator(void)
207:           {
208:               //Reset the ADCON2bits.ADACLR bit.
209:               ADCON2bits.ADACLR = 1;
210:           }
211:           
212:           uint24_t ADCC_GetAccumulatorValue(void)
213:           {
214:               //Return the contents of ADACCU, ADACCH and ADACCL registers
215:               return (((uint24_t)ADACCU << 16)+((uint24_t)ADACCH << 8) + ADACCL);
216:           }
217:           
218:           bool ADCC_HasAccumulatorOverflowed(void)
219:           {
220:               //Return the status of ADSTATbits.ADAOV
221:               return ADSTATbits.ADAOV;
222:           }
223:           
224:           uint16_t ADCC_GetFilterValue(void)
225:           {
226:               //Return the contents of ADFLTRH and ADFLTRL registers
227:               return ((uint16_t)((ADFLTRH << 8) + ADFLTRL));
228:           }
229:           
230:           uint16_t ADCC_GetPreviousResult(void)
231:           {
232:               //Return the contents of ADPREVH and ADPREVL registers
233:               return ((uint16_t)((ADPREVH << 8) + ADPREVL));
234:           }
235:           
236:           void ADCC_DefineSetPoint(uint16_t setPoint)
237:           {
238:               //Sets the ADSTPTH and ADSTPTL registers
239:               ADSTPTH = setPoint >> 8;
240:               ADSTPTL = setPoint;
241:           }
242:           
243:           void ADCC_SetUpperThreshold(uint16_t upperThreshold)
244:           {
245:               //Sets the ADUTHH and ADUTHL registers
246:               ADUTHH = upperThreshold >> 8;
247:               ADUTHL = upperThreshold;
248:           }
249:           
250:           void ADCC_SetLowerThreshold(uint16_t lowerThreshold)
251:           {
252:               //Sets the ADLTHH and ADLTHL registers
253:               ADLTHH = lowerThreshold >> 8;
254:               ADLTHL = lowerThreshold;
255:           }
256:           
257:           uint16_t ADCC_GetErrorCalculation(void)
258:           {
259:           	//Return the contents of ADERRH and ADERRL registers
260:           	return ((uint16_t)((ADERRH << 8) + ADERRL));
261:           }
262:           
263:           void ADCC_EnableDoubleSampling(void)
264:           {
265:               //Sets the ADCON1bits.ADDSEN
266:               ADCON1bits.ADDSEN = 1;
267:           }
268:           
269:           void ADCC_EnableContinuousConversion(void)
270:           {
271:               //Sets the ADCON0bits.ADCONT
272:               ADCON0bits.ADCONT = 1;
273:           }
274:           
275:           void ADCC_DisableContinuousConversion(void)
276:           {
277:               //Resets the ADCON0bits.ADCONT
278:               ADCON0bits.ADCONT = 0;
279:           }
280:           
281:           bool ADCC_HasErrorCrossedUpperThreshold(void)
282:           {
283:               //Returns the value of ADSTATbits.ADUTHR bit.
284:               return ADSTATbits.ADUTHR;
285:           }
286:           
287:           bool ADCC_HasErrorCrossedLowerThreshold(void)
288:           {
289:               //Returns the value of ADSTATbits.ADLTHR bit.
290:               return ADSTATbits.ADLTHR;
291:           }
292:           
293:           uint8_t ADCC_GetConversionStageStatus(void)
294:           {
295:               //Returns the contents of ADSTATbits.ADSTAT field.
296:               return ADSTATbits.ADSTAT;
297:           }
298:           
299:           
300:           /**
301:            End of File
302:           */
---  C:/Users/C50931/Projects/Guitar Tuner/guitar tuner/guitar tuner.X/main.c  --------------------------
1:             /**
2:               Generated Main Source File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 main.c
9:             
10:              Summary:
11:                This is the main file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.0
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.00
19:             */
20:            
21:            /*
22:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
23:                
24:                Subject to your compliance with these terms, you may use Microchip software and any 
25:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
26:                license terms applicable to your use of third party software (including open source software) that 
27:                may accompany Microchip software.
28:                
29:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
30:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
31:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
32:                FOR A PARTICULAR PURPOSE.
33:                
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
37:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
38:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
39:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
40:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
41:                SOFTWARE.
42:             */
43:            
44:            #include "mcc_generated_files/mcc.h"
45:            
46:            void TMR0_CustomISR(void);
47:            
48:            #define LENGTH 512
49:            
50:            uint8_t rawData[512];
51:            int16_t count;
52:            
53:            /*
54:                                     Main application
55:             */
56:            void main(void) {
42FA  EC83     CALL 0x5D06, 0
42FC  F02E     NOP
57:                // Initialize the device
58:                SYSTEM_Initialize();
59:            
60:                // If using interrupts in PIC18 High/Low Priority Mode you need to enable the Global High and Low Interrupts
61:                // If using interrupts in PIC Mid-Range Compatibility Mode you need to enable the Global Interrupts
62:                // Use the following macros to:
63:            
64:                TMR0_SetInterruptHandler(TMR0_CustomISR);
42FE  0E98     MOVLW 0x98
4300  6E01     MOVWF 0x1, ACCESS
4302  0E5C     MOVLW 0x5C
4304  6E02     MOVWF 0x2, ACCESS
4306  0E00     MOVLW 0x0
4308  6E03     MOVWF 0x3, ACCESS
430A  ECC1     CALL 0x5D82, 0
430C  F02E     NOP
65:            
66:                // Enable the Global Interrupts
67:                INTERRUPT_GlobalInterruptEnable();
430E  8ED6     BSF 0xFD6, 7, ACCESS
68:            
69:                // Disable the Global Interrupts
70:                //INTERRUPT_GlobalInterruptDisable();
71:            
72:            
73:                //variables for autocorrelation test:
74:                //    uint8_t rawData[512];
75:                //    int16_t count = 0;
76:            
77:                const float sample_freq = 8919;
4310  0E00     MOVLW 0x0
4312  0105     MOVLB 0x5
4314  6FB6     MOVWF DMA1PR, BANKED
4316  0E5C     MOVLW 0x5C
4318  6FB7     MOVWF DMA2PR, BANKED
431A  0E0B     MOVLW 0xB
431C  6FB8     MOVWF DMA3PR, BANKED
431E  0E46     MOVLW 0x46
4320  6FB9     MOVWF DMA4PR, BANKED
78:                //    const float sample_freq = 8951;
79:                int16_t len = sizeof (rawData);
4322  0E02     MOVLW 0x2
4324  6FC7     MOVWF 0xC7, BANKED
4326  0E00     MOVLW 0x0
4328  6FC6     MOVWF 0xC6, BANKED
80:            
81:                printf("LENGHT= %d \r\n", LENGTH);
432A  0E01     MOVLW 0x1
432C  6E5A     MOVWF 0x5A, ACCESS
432E  0E25     MOVLW 0x25
4330  6E5B     MOVWF 0x5B, ACCESS
4332  0E02     MOVLW 0x2
4334  6E5D     MOVWF 0x5D, ACCESS
4336  0E00     MOVLW 0x0
4338  6E5C     MOVWF 0x5C, ACCESS
433A  EC38     CALL 0x5C70, 0
433C  F02E     NOP
82:                printf("len= %d \r\n", len);
433E  0E1B     MOVLW 0x1B
4340  6E5A     MOVWF 0x5A, ACCESS
4342  0E25     MOVLW 0x25
4344  6E5B     MOVWF 0x5B, ACCESS
4346  0E02     MOVLW 0x2
4348  6E5D     MOVWF 0x5D, ACCESS
434A  0E00     MOVLW 0x0
434C  6E5C     MOVWF 0x5C, ACCESS
434E  EC38     CALL 0x5C70, 0
4350  F02E     NOP
83:            
84:                int16_t period = 0;
4352  0E00     MOVLW 0x0
4354  0105     MOVLB 0x5
4356  6FC5     MOVWF 0xC5, BANKED
4358  0E00     MOVLW 0x0
435A  6FC4     MOVWF 0xC4, BANKED
85:                int16_t i;
86:                int16_t k;
87:                int32_t sum;
88:                int32_t sum_old;
89:                int16_t thresh = 0;
90:                float freq_per = 0;
435C  0E00     MOVLW 0x0
435E  6FE2     MOVWF 0xE2, BANKED
4360  0E00     MOVLW 0x0
4362  6FE1     MOVWF 0xE1, BANKED
91:                uint8_t pd_state = 0;
92:            
93:                count = 0;
94:            
95:                //    ADPCH = 0x00;
96:            
97:                IO_RA7_SetLow();
4364  9EBE     BCF 0xFBE, 7, ACCESS
98:            
99:                while (1) {
100:                   IO_RA7_SetHigh();
4366  8EBE     BSF 0xFBE, 7, ACCESS
101:                   while (count < LENGTH);
4368  0105     MOVLB 0x5
436A  BFE2     BTFSC 0xE2, 7, BANKED
436C  EFBF     GOTO 0x437E
436E  F021     NOP
4370  0E02     MOVLW 0x2
4372  5DE2     SUBWF 0xE2, W, BANKED
4374  A0D8     BTFSS 0xFD8, 0, ACCESS
4376  EFBF     GOTO 0x437E
4378  F021     NOP
437A  EFC1     GOTO 0x4382
437C  F021     NOP
437E  EFB4     GOTO 0x4368
4380  F021     NOP
102:                   IO_RA7_SetLow();
4382  9EBE     BCF 0xFBE, 7, ACCESS
103:           
104:                   PIE3bits.TMR0IE = 0;
4384  9EA1     BCF 0xFA1, 7, ACCESS
105:                   T0CON0bits.T0EN = 0;
4386  0103     MOVLB 0x3
4388  9F1A     BCF 0x1A, 7, BANKED
106:           
107:                   //        TEST: print the rawData array
108:                   //        for (i = 0; i < 512; i++) {
109:                   //            printf("%d \r\n", rawData[i]);
110:                   //        }
111:           
112:                   sum = 0;
438A  0E00     MOVLW 0x0
438C  0105     MOVLB 0x5
438E  6FCD     MOVWF 0xCD, BANKED
4390  0E00     MOVLW 0x0
4392  6FCE     MOVWF 0xCE, BANKED
4394  0E00     MOVLW 0x0
4396  6FCF     MOVWF 0xCF, BANKED
4398  0E00     MOVLW 0x0
439A  6FD0     MOVWF 0xD0, BANKED
113:                   pd_state = 0;
439C  0E00     MOVLW 0x0
439E  6FCA     MOVWF 0xCA, BANKED
114:                   period = 0;
43A0  0E00     MOVLW 0x0
43A2  6FBF     MOVWF ISRPR, BANKED
43A4  0E00     MOVLW 0x0
43A6  6FBE     MOVWF MAINPR, BANKED
115:                   for (i = 0; i < len; i++) {
43A8  0E00     MOVLW 0x0
43AA  6FCC     MOVWF 0xCC, BANKED
43AC  0E00     MOVLW 0x0
43AE  6FCB     MOVWF 0xCB, BANKED
43B0  EFE7     GOTO 0x45CE
43B2  F022     NOP
116:                       // Autocorrelation
117:                       sum_old = sum;
43B4  C5CD     MOVFF sum, sum_old
43B6  F5C0     NOP
43B8  C5CE     MOVFF 0x5CE, 0x5C1
43BA  F5C1     NOP
43BC  C5CF     MOVFF 0x5CF, 0x5C2
43BE  F5C2     NOP
43C0  C5D0     MOVFF 0x5D0, 0x5C3
43C2  F5C3     NOP
118:                       sum = 0;
43C4  0E00     MOVLW 0x0
43C6  6FCD     MOVWF 0xCD, BANKED
43C8  0E00     MOVLW 0x0
43CA  6FCE     MOVWF 0xCE, BANKED
43CC  0E00     MOVLW 0x0
43CE  6FCF     MOVWF 0xCF, BANKED
43D0  0E00     MOVLW 0x0
43D2  6FD0     MOVWF 0xD0, BANKED
119:                       for (k = 0; k < len - i; k++) {
43D4  0E00     MOVLW 0x0
43D6  6FC9     MOVWF 0xC9, BANKED
43D8  0E00     MOVLW 0x0
43DA  6FC8     MOVWF 0xC8, BANKED
43DC  EF34     GOTO 0x4468
43DE  F022     NOP
120:                           sum += ((rawData[k] - 128)*(rawData[k + i] - 128)) / 256;
43E0  0E50     MOVLW 0x50
43E2  25C8     ADDWF 0xC8, W, BANKED
43E4  6ED9     MOVWF 0xFD9, ACCESS
43E6  0E06     MOVLW 0x6
43E8  21C9     ADDWFC 0xC9, W, BANKED
43EA  6EDA     MOVWF 0xFDA, ACCESS
43EC  50DF     MOVF 0xFDF, W, ACCESS
43EE  6FAE     MOVWF OSCCON2, BANKED
43F0  0E80     MOVLW 0x80
43F2  25AE     ADDWF OSCCON2, W, BANKED
43F4  6E01     MOVWF 0x1, ACCESS
43F6  6A02     CLRF 0x2, ACCESS
43F8  0EFF     MOVLW 0xFF
43FA  2202     ADDWFC 0x2, F, ACCESS
43FC  0E50     MOVLW 0x50
43FE  6FAF     MOVWF OSCCON3, BANKED
4400  0E06     MOVLW 0x6
4402  6FB0     MOVWF OSCTUNE, BANKED
4404  51C8     MOVF 0xC8, W, BANKED
4406  27AF     ADDWF OSCCON3, F, BANKED
4408  51C9     MOVF 0xC9, W, BANKED
440A  23B0     ADDWFC OSCTUNE, F, BANKED
440C  51CB     MOVF 0xCB, W, BANKED
440E  25AF     ADDWF OSCCON3, W, BANKED
4410  6ED9     MOVWF 0xFD9, ACCESS
4412  51CC     MOVF 0xCC, W, BANKED
4414  21B0     ADDWFC OSCTUNE, W, BANKED
4416  6EDA     MOVWF 0xFDA, ACCESS
4418  50DF     MOVF 0xFDF, W, ACCESS
441A  6FB1     MOVWF OSCFRQ, BANKED
441C  0E80     MOVLW 0x80
441E  25B1     ADDWF OSCFRQ, W, BANKED
4420  6E03     MOVWF 0x3, ACCESS
4422  6A04     CLRF 0x4, ACCESS
4424  0EFF     MOVLW 0xFF
4426  2204     ADDWFC 0x4, F, ACCESS
4428  EC0E     CALL 0x5C1C, 0
442A  F02E     NOP
442C  C501     MOVFF __pcstackCOMRAM, s
442E  F507     NOP
4430  C502     MOVFF txData, l
4432  F508     NOP
4434  0E01     MOVLW 0x1
4436  6E0A     MOVWF 0xA, ACCESS
4438  0E00     MOVLW 0x0
443A  6E09     MOVWF 0x9, ACCESS
443C  EC74     CALL 0x54E8, 0
443E  F02A     NOP
4440  C507     MOVFF s, 0x5B2
4442  F5B2     NOP
4444  C508     MOVFF l, 0x5B3
4446  F5B3     NOP
4448  0E00     MOVLW 0x0
444A  0105     MOVLB 0x5
444C  BFB3     BTFSC OSCEN, 7, BANKED
444E  0EFF     MOVLW 0xFF
4450  6FB4     MOVWF PRLOCK, BANKED
4452  6FB5     MOVWF SCANPR, BANKED
4454  51B2     MOVF OSCSTAT, W, BANKED
4456  27CD     ADDWF 0xCD, F, BANKED
4458  51B3     MOVF OSCEN, W, BANKED
445A  23CE     ADDWFC 0xCE, F, BANKED
445C  51B4     MOVF PRLOCK, W, BANKED
445E  23CF     ADDWFC 0xCF, F, BANKED
4460  51B5     MOVF SCANPR, W, BANKED
4462  23D0     ADDWFC 0xD0, F, BANKED
121:                           //                sum += ((rawData[k] - 128)*(rawData[k + i] - 128)) >> 8;
122:                       }
4464  4BC8     INFSNZ 0xC8, F, BANKED
4466  2BC9     INCF 0xC9, F, BANKED
4468  51CB     MOVF 0xCB, W, BANKED
446A  5DC6     SUBWF 0xC6, W, BANKED
446C  6FAE     MOVWF OSCCON2, BANKED
446E  51CC     MOVF 0xCC, W, BANKED
4470  59C7     SUBWFB 0xC7, W, BANKED
4472  6FAF     MOVWF OSCCON3, BANKED
4474  51AE     MOVF OSCCON2, W, BANKED
4476  5DC8     SUBWF 0xC8, W, BANKED
4478  51C9     MOVF 0xC9, W, BANKED
447A  0A80     XORLW 0x80
447C  6FB0     MOVWF OSCTUNE, BANKED
447E  51AF     MOVF OSCCON3, W, BANKED
4480  0A80     XORLW 0x80
4482  59B0     SUBWFB OSCTUNE, W, BANKED
4484  A0D8     BTFSS 0xFD8, 0, ACCESS
4486  EF47     GOTO 0x448E
4488  F022     NOP
448A  EF49     GOTO 0x4492
448C  F022     NOP
448E  EFF0     GOTO 0x43E0
4490  F021     NOP
123:                       // Peak Detect State Machine
124:                       if ((pd_state == 2) && ((sum - sum_old) <= 0)) {
4492  0E02     MOVLW 0x2
4494  19CA     XORWF 0xCA, W, BANKED
4496  A4D8     BTFSS 0xFD8, 2, ACCESS
4498  EF50     GOTO 0x44A0
449A  F022     NOP
449C  EF52     GOTO 0x44A4
449E  F022     NOP
44A0  EF73     GOTO 0x44E6
44A2  F022     NOP
44A4  51C0     MOVF 0xC0, W, BANKED
44A6  5DCD     SUBWF 0xCD, W, BANKED
44A8  6FAE     MOVWF OSCCON2, BANKED
44AA  51C1     MOVF 0xC1, W, BANKED
44AC  59CE     SUBWFB 0xCE, W, BANKED
44AE  6FAF     MOVWF OSCCON3, BANKED
44B0  51C2     MOVF 0xC2, W, BANKED
44B2  59CF     SUBWFB 0xCF, W, BANKED
44B4  6FB0     MOVWF OSCTUNE, BANKED
44B6  51C3     MOVF 0xC3, W, BANKED
44B8  59D0     SUBWFB 0xD0, W, BANKED
44BA  6FB1     MOVWF OSCFRQ, BANKED
44BC  BFB1     BTFSC OSCFRQ, 7, BANKED
44BE  EF6D     GOTO 0x44DA
44C0  F022     NOP
44C2  51B1     MOVF OSCFRQ, W, BANKED
44C4  11B0     IORWF OSCTUNE, W, BANKED
44C6  11AF     IORWF OSCCON3, W, BANKED
44C8  E106     BNZ 0x44D6
44CA  05AE     DECF OSCCON2, W, BANKED
44CC  B0D8     BTFSC 0xFD8, 0, ACCESS
44CE  EF6B     GOTO 0x44D6
44D0  F022     NOP
44D2  EF6D     GOTO 0x44DA
44D4  F022     NOP
44D6  EF73     GOTO 0x44E6
44D8  F022     NOP
125:                           period = i;
44DA  C5CB     MOVFF i, period
44DC  F5BE     NOP
44DE  C5CC     MOVFF 0x5CC, 0x5BF
44E0  F5BF     NOP
126:                           pd_state = 3;
44E2  0E03     MOVLW 0x3
44E4  6FCA     MOVWF 0xCA, BANKED
127:                       }
128:                       if ((pd_state == 1) && (sum > thresh) && ((sum - sum_old) > 0)) {
44E6  05CA     DECF 0xCA, W, BANKED
44E8  A4D8     BTFSS 0xFD8, 2, ACCESS
44EA  EF79     GOTO 0x44F2
44EC  F022     NOP
44EE  EF7B     GOTO 0x44F6
44F0  F022     NOP
44F2  EFAE     GOTO 0x455C
44F4  F022     NOP
44F6  0E00     MOVLW 0x0
44F8  BFC5     BTFSC 0xC5, 7, BANKED
44FA  0EFF     MOVLW 0xFF
44FC  6FAF     MOVWF OSCCON3, BANKED
44FE  0A80     XORLW 0x80
4500  6FAE     MOVWF OSCCON2, BANKED
4502  51CD     MOVF 0xCD, W, BANKED
4504  5DC4     SUBWF 0xC4, W, BANKED
4506  51CE     MOVF 0xCE, W, BANKED
4508  59C5     SUBWFB 0xC5, W, BANKED
450A  51CF     MOVF 0xCF, W, BANKED
450C  59AF     SUBWFB OSCCON3, W, BANKED
450E  51D0     MOVF 0xD0, W, BANKED
4510  0A80     XORLW 0x80
4512  59AE     SUBWFB OSCCON2, W, BANKED
4514  B0D8     BTFSC 0xFD8, 0, ACCESS
4516  EF8F     GOTO 0x451E
4518  F022     NOP
451A  EF91     GOTO 0x4522
451C  F022     NOP
451E  EFAE     GOTO 0x455C
4520  F022     NOP
4522  51C0     MOVF 0xC0, W, BANKED
4524  5DCD     SUBWF 0xCD, W, BANKED
4526  6FAE     MOVWF OSCCON2, BANKED
4528  51C1     MOVF 0xC1, W, BANKED
452A  59CE     SUBWFB 0xCE, W, BANKED
452C  6FAF     MOVWF OSCCON3, BANKED
452E  51C2     MOVF 0xC2, W, BANKED
4530  59CF     SUBWFB 0xCF, W, BANKED
4532  6FB0     MOVWF OSCTUNE, BANKED
4534  51C3     MOVF 0xC3, W, BANKED
4536  59D0     SUBWFB 0xD0, W, BANKED
4538  6FB1     MOVWF OSCFRQ, BANKED
453A  BFB1     BTFSC OSCFRQ, 7, BANKED
453C  EFAA     GOTO 0x4554
453E  F022     NOP
4540  51B1     MOVF OSCFRQ, W, BANKED
4542  11B0     IORWF OSCTUNE, W, BANKED
4544  11AF     IORWF OSCCON3, W, BANKED
4546  E108     BNZ 0x4558
4548  05AE     DECF OSCCON2, W, BANKED
454A  A0D8     BTFSS 0xFD8, 0, ACCESS
454C  EFAA     GOTO 0x4554
454E  F022     NOP
4550  EFAC     GOTO 0x4558
4552  F022     NOP
4554  EFAE     GOTO 0x455C
4556  F022     NOP
129:                           pd_state = 2;
4558  0E02     MOVLW 0x2
455A  6FCA     MOVWF 0xCA, BANKED
130:                       }
131:                       if (!i) {
455C  51CB     MOVF 0xCB, W, BANKED
455E  11CC     IORWF 0xCC, W, BANKED
4560  A4D8     BTFSS 0xFD8, 2, ACCESS
4562  EFB5     GOTO 0x456A
4564  F022     NOP
4566  EFB7     GOTO 0x456E
4568  F022     NOP
456A  EFE5     GOTO 0x45CA
456C  F022     NOP
132:                           thresh = sum * 0.5;
456E  0E00     MOVLW 0x0
4570  6E13     MOVWF 0x13, ACCESS
4572  0E00     MOVLW 0x0
4574  6E14     MOVWF 0x14, ACCESS
4576  0E00     MOVLW 0x0
4578  6E15     MOVWF 0x15, ACCESS
457A  0E3F     MOVLW 0x3F
457C  6E16     MOVWF 0x16, ACCESS
457E  C5CD     MOVFF sum, __pcstackCOMRAM
4580  F501     NOP
4582  C5CE     MOVFF 0x5CE, txData
4584  F502     NOP
4586  C5CF     MOVFF 0x5CF, _r
4588  F503     NOP
458A  C5D0     MOVFF 0x5D0, 0x504
458C  F504     NOP
458E  0E01     MOVLW 0x1
4590  ECC0     CALL 0x4B80, 0
4592  F025     NOP
4594  C501     MOVFF __pcstackCOMRAM, bexp
4596  F50F     NOP
4598  C502     MOVFF txData, c
459A  F510     NOP
459C  C503     MOVFF _r, counter
459E  F511     NOP
45A0  C504     MOVFF 0x504, sign
45A2  F512     NOP
45A4  EC89     CALL 0x3B12, 0
45A6  F01D     NOP
45A8  C50F     MOVFF bexp, x
45AA  F528     NOP
45AC  C510     MOVFF c, 0x529
45AE  F529     NOP
45B0  C511     MOVFF counter, 0x52A
45B2  F52A     NOP
45B4  C512     MOVFF sign, 0x52B
45B6  F52B     NOP
45B8  EC10     CALL 0x5020, 0
45BA  F028     NOP
45BC  C528     MOVFF x, thresh
45BE  F5C4     NOP
45C0  C529     MOVFF 0x529, 0x5C5
45C2  F5C5     NOP
133:                           pd_state = 1;
45C4  0E01     MOVLW 0x1
45C6  0105     MOVLB 0x5
45C8  6FCA     MOVWF 0xCA, BANKED
134:                       }
135:                   }
45CA  4BCB     INFSNZ 0xCB, F, BANKED
45CC  2BCC     INCF 0xCC, F, BANKED
45CE  51C6     MOVF 0xC6, W, BANKED
45D0  5DCB     SUBWF 0xCB, W, BANKED
45D2  51CC     MOVF 0xCC, W, BANKED
45D4  0A80     XORLW 0x80
45D6  6FAE     MOVWF OSCCON2, BANKED
45D8  51C7     MOVF 0xC7, W, BANKED
45DA  0A80     XORLW 0x80
45DC  59AE     SUBWFB OSCCON2, W, BANKED
45DE  A0D8     BTFSS 0xFD8, 0, ACCESS
45E0  EFF4     GOTO 0x45E8
45E2  F022     NOP
45E4  EFF6     GOTO 0x45EC
45E6  F022     NOP
45E8  EFDA     GOTO 0x43B4
45EA  F021     NOP
136:                   // Frequency identified in Hz
137:                   if (thresh > 100) {
45EC  BFC5     BTFSC 0xC5, 7, BANKED
45EE  EF02     GOTO 0x4604
45F0  F023     NOP
45F2  51C5     MOVF 0xC5, W, BANKED
45F4  E109     BNZ 0x4608
45F6  0E65     MOVLW 0x65
45F8  5DC4     SUBWF 0xC4, W, BANKED
45FA  A0D8     BTFSS 0xFD8, 0, ACCESS
45FC  EF02     GOTO 0x4604
45FE  F023     NOP
4600  EF04     GOTO 0x4608
4602  F023     NOP
4604  EF38     GOTO 0x4670
4606  F023     NOP
138:                       freq_per = sample_freq / period;
4608  C5B6     MOVFF sample_freq, bexp
460A  F50F     NOP
460C  C5B7     MOVFF 0x5B7, c
460E  F510     NOP
4610  C5B8     MOVFF 0x5B8, counter
4612  F511     NOP
4614  C5B9     MOVFF 0x5B9, sign
4616  F512     NOP
4618  C5BE     MOVFF period, __pcstackCOMRAM
461A  F501     NOP
461C  C5BF     MOVFF 0x5BF, txData
461E  F502     NOP
4620  0E00     MOVLW 0x0
4622  BE02     BTFSC 0x2, 7, ACCESS
4624  0EFF     MOVLW 0xFF
4626  6E03     MOVWF 0x3, ACCESS
4628  6E04     MOVWF 0x4, ACCESS
462A  0E01     MOVLW 0x1
462C  ECC0     CALL 0x4B80, 0
462E  F025     NOP
4630  C501     MOVFF __pcstackCOMRAM, quotient
4632  F513     NOP
4634  C502     MOVFF txData, 0x514
4636  F514     NOP
4638  C503     MOVFF _r, buf
463A  F515     NOP
463C  C504     MOVFF 0x504, 0x516
463E  F516     NOP
4640  ECB0     CALL 0x3F60, 0
4642  F01F     NOP
4644  C50F     MOVFF bexp, freq_per
4646  F5BA     NOP
4648  C510     MOVFF c, 0x5BB
464A  F5BB     NOP
464C  C511     MOVFF counter, 0x5BC
464E  F5BC     NOP
4650  C512     MOVFF sign, 0x5BD
4652  F5BD     NOP
139:                       printf("Freq= %f \r\n", freq_per);
4654  0E0F     MOVLW 0xF
4656  6E5A     MOVWF 0x5A, ACCESS
4658  0E25     MOVLW 0x25
465A  6E5B     MOVWF 0x5B, ACCESS
465C  C5BA     MOVFF freq_per, 0x55C
465E  F55C     NOP
4660  C5BB     MOVFF 0x5BB, 0x55D
4662  F55D     NOP
4664  C5BC     MOVFF 0x5BC, 0x55E
4666  F55E     NOP
4668  C5BD     MOVFF 0x5BD, 0x55F
466A  F55F     NOP
466C  EC38     CALL 0x5C70, 0
466E  F02E     NOP
140:                   }
141:           
142:           
143:                   count = 0;
4670  0E00     MOVLW 0x0
4672  0105     MOVLB 0x5
4674  6FE2     MOVWF 0xE2, BANKED
4676  0E00     MOVLW 0x0
4678  6FE1     MOVWF 0xE1, BANKED
144:                   PIE3bits.TMR0IE = 1;
467A  8EA1     BSF 0xFA1, 7, ACCESS
145:                   T0CON0bits.T0EN = 1;
467C  0103     MOVLB 0x3
467E  8F1A     BSF 0x1A, 7, BANKED
4680  EFB3     GOTO 0x4366
4682  F021     NOP
4684  EF0D     GOTO 0x1A
4686  F000     NOP
146:           
147:               }
148:           }
149:           
150:           void TMR0_CustomISR() {
5C98  0103     MOVLB 0x3
5C9A  B1F3     BTFSC DMAnSCNTH, 0, BANKED
5C9C  EF52     GOTO 0x5CA4
5C9E  F02E     NOP
5CA0  EF54     GOTO 0x5CA8
5CA2  F02E     NOP
5CA4  EF4C     GOTO 0x5C98
5CA6  F02E     NOP
151:               //    rawData[count] = (ADCC_GetSingleConversion(MIC_Input) >> 8);
152:               // Wait for the conversion to finish
153:               while (ADCON0bits.ADGO);
154:               rawData[count] = ADRESH;
5CA8  0E50     MOVLW 0x50
5CAA  0105     MOVLB 0x5
5CAC  25E1     ADDWF 0xE1, W, BANKED
5CAE  6ED9     MOVWF 0xFD9, ACCESS
5CB0  0E06     MOVLW 0x6
5CB2  21E2     ADDWFC 0xE2, W, BANKED
5CB4  6EDA     MOVWF 0xFDA, ACCESS
5CB6  C3EB     MOVFF ADRESH, INDF2
5CB8  F4DF     NOP
155:               count++;
5CBA  4BE1     INFSNZ 0xE1, F, BANKED
5CBC  2BE2     INCF 0xE2, F, BANKED
156:           }
5CBE  0012     RETURN 0
157:           
158:           /**
159:            End of File
160:            */
---  C:/Users/C50931/AppData/Local/Temp/s2m28.s  --------------------------------------------------------
5ABE  EE01     LFSR 0, 0x650
5AC2  EE10     LFSR 1, 0x200
5AC6  6AEE     CLRF 0xFEE, ACCESS
5AC8  50E5     MOVF 0xFE5, W, ACCESS
5ACA  50E1     MOVF 0xFE1, W, ACCESS
5ACC  E1FC     BNZ 0x5AC6
5ACE  50E2     MOVF 0xFE2, W, ACCESS
5AD0  E1FA     BNZ 0x5AC6
5AD2  EE01     LFSR 0, 0x600
5AD6  0E50     MOVLW 0x50
5AD8  6AEE     CLRF 0xFEE, ACCESS
5ADA  06E8     DECF 0xFE8, F, ACCESS
5ADC  E1FD     BNZ 0x5AD8
5ADE  EE01     LFSR 0, 0x5D1
5AE2  0E13     MOVLW 0x13
5AE4  6AEE     CLRF 0xFEE, ACCESS
5AE6  06E8     DECF 0xFE8, F, ACCESS
5AE8  E1FD     BNZ 0x5AE4
5AEA  0104     MOVLB 0x4
5AEC  0E08     MOVLW 0x8
5AEE  6F5D     MOVWF 0x5D, BANKED
5AF0  0E00     MOVLW 0x0
5AF2  6F5E     MOVWF 0x5E, BANKED
5AF4  0E00     MOVLW 0x0
5AF6  6F5F     MOVWF 0x5F, BANKED
5AF8  0100     MOVLB 0x0
5AFA  EF7D     GOTO 0x42FA
---  C:/Program Files/Microchip/xc8/v2.20/pic/sources/c99/common/xxtofl.c  ------------------------------
1:             // since we use tests on the size of operands, suppress the warnings that
2:             // would be generated
3:             #pragma warning disable 757
4:             
5:             /* Convert an integer to a 32-bit floating point value.
6:              * sign : is val actually a signed value
7:              * val  : the incoming integer (signed or unsigned) for conversion, cast to a signed long
8:              */ 
9:             double
10:            __xxtofl(unsigned char sign, signed long val)
4B80  6E09     MOVWF 0x9, ACCESS
11:            {
12:            	unsigned char exp;
13:            	unsigned long arg;
14:            
15:            	if(sign && val < 0) {
4B82  5009     MOVF 0x9, W, ACCESS
4B84  B4D8     BTFSC 0xFD8, 2, ACCESS
4B86  EFC7     GOTO 0x4B8E
4B88  F025     NOP
4B8A  EFC9     GOTO 0x4B92
4B8C  F025     NOP
4B8E  EFEB     GOTO 0x4BD6
4B90  F025     NOP
4B92  BE04     BTFSC 0x4, 7, ACCESS
4B94  EFD0     GOTO 0x4BA0
4B96  F025     NOP
4B98  EFCE     GOTO 0x4B9C
4B9A  F025     NOP
4B9C  EFEB     GOTO 0x4BD6
4B9E  F025     NOP
16:            		arg = -val;
4BA0  C501     MOVFF __pcstackCOMRAM, n
4BA2  F505     NOP
4BA4  C502     MOVFF txData, sign
4BA6  F506     NOP
4BA8  C503     MOVFF _r, s
4BAA  F507     NOP
4BAC  C504     MOVFF 0x504, l
4BAE  F508     NOP
4BB0  1E05     COMF 0x5, F, ACCESS
4BB2  1E06     COMF 0x6, F, ACCESS
4BB4  1E07     COMF 0x7, F, ACCESS
4BB6  1E08     COMF 0x8, F, ACCESS
4BB8  2A05     INCF 0x5, F, ACCESS
4BBA  0E00     MOVLW 0x0
4BBC  2206     ADDWFC 0x6, F, ACCESS
4BBE  2207     ADDWFC 0x7, F, ACCESS
4BC0  2208     ADDWFC 0x8, F, ACCESS
4BC2  C505     MOVFF n, arg
4BC4  F50B     NOP
4BC6  C506     MOVFF sign, s
4BC8  F50C     NOP
4BCA  C507     MOVFF s, signs
4BCC  F50D     NOP
4BCE  C508     MOVFF l, fp
4BD0  F50E     NOP
17:            	}
4BD2  EFF3     GOTO 0x4BE6
4BD4  F025     NOP
18:            	else {
4BD6  C501     MOVFF __pcstackCOMRAM, arg
4BD8  F50B     NOP
4BDA  C502     MOVFF txData, s
4BDC  F50C     NOP
4BDE  C503     MOVFF _r, signs
4BE0  F50D     NOP
4BE2  C504     MOVFF 0x504, fp
4BE4  F50E     NOP
19:            		arg = val;
20:            	}
21:            	if(val == 0)
4BE6  5001     MOVF 0x1, W, ACCESS
4BE8  1002     IORWF 0x2, W, ACCESS
4BEA  1003     IORWF 0x3, W, ACCESS
4BEC  1004     IORWF 0x4, W, ACCESS
4BEE  A4D8     BTFSS 0xFD8, 2, ACCESS
4BF0  EFFC     GOTO 0x4BF8
4BF2  F025     NOP
4BF4  EFFE     GOTO 0x4BFC
4BF6  F025     NOP
4BF8  EF08     GOTO 0x4C10
4BFA  F026     NOP
22:            		return 0.0;
4BFC  0E00     MOVLW 0x0
4BFE  6E01     MOVWF 0x1, ACCESS
4C00  0E00     MOVLW 0x0
4C02  6E02     MOVWF 0x2, ACCESS
4C04  0E00     MOVLW 0x0
4C06  6E03     MOVWF 0x3, ACCESS
4C08  0E00     MOVLW 0x0
4C0A  6E04     MOVWF 0x4, ACCESS
4C0C  EF99     GOTO 0x4D32
4C0E  F026     NOP
23:            	exp = (127 + 23);
4C10  0E96     MOVLW 0x96
4C12  6E0A     MOVWF 0xA, ACCESS
24:            	while(arg & ~0x1FFFFFFUL) {
4C14  EF12     GOTO 0x4C24
4C16  F026     NOP
4C24  0E00     MOVLW 0x0
4C26  140B     ANDWF 0xB, W, ACCESS
4C28  6E05     MOVWF 0x5, ACCESS
4C2A  0E00     MOVLW 0x0
4C2C  140C     ANDWF 0xC, W, ACCESS
4C2E  6E06     MOVWF 0x6, ACCESS
4C30  0E00     MOVLW 0x0
4C32  140D     ANDWF 0xD, W, ACCESS
4C34  6E07     MOVWF 0x7, ACCESS
4C36  0EFE     MOVLW 0xFE
4C38  140E     ANDWF 0xE, W, ACCESS
4C3A  6E08     MOVWF 0x8, ACCESS
4C3C  5005     MOVF 0x5, W, ACCESS
4C3E  1006     IORWF 0x6, W, ACCESS
4C40  1007     IORWF 0x7, W, ACCESS
4C42  1008     IORWF 0x8, W, ACCESS
4C44  A4D8     BTFSS 0xFD8, 2, ACCESS
4C46  EF27     GOTO 0x4C4E
4C48  F026     NOP
4C4A  EF29     GOTO 0x4C52
4C4C  F026     NOP
4C4E  EF0C     GOTO 0x4C18
4C50  F026     NOP
4C52  EF37     GOTO 0x4C6E
4C54  F026     NOP
25:            		++exp;
4C18  2A0A     INCF 0xA, F, ACCESS
26:            		arg >>= 1;
4C1A  90D8     BCF 0xFD8, 0, ACCESS
4C1C  320E     RRCF 0xE, F, ACCESS
4C1E  320D     RRCF 0xD, F, ACCESS
4C20  320C     RRCF 0xC, F, ACCESS
4C22  320B     RRCF 0xB, F, ACCESS
27:            	}
28:            	while(arg & ~0xFFFFFFUL) {
4C6E  0E00     MOVLW 0x0
4C70  140B     ANDWF 0xB, W, ACCESS
4C72  6E05     MOVWF 0x5, ACCESS
4C74  0E00     MOVLW 0x0
4C76  140C     ANDWF 0xC, W, ACCESS
4C78  6E06     MOVWF 0x6, ACCESS
4C7A  0E00     MOVLW 0x0
4C7C  140D     ANDWF 0xD, W, ACCESS
4C7E  6E07     MOVWF 0x7, ACCESS
4C80  0EFF     MOVLW 0xFF
4C82  140E     ANDWF 0xE, W, ACCESS
4C84  6E08     MOVWF 0x8, ACCESS
4C86  5005     MOVF 0x5, W, ACCESS
4C88  1006     IORWF 0x6, W, ACCESS
4C8A  1007     IORWF 0x7, W, ACCESS
4C8C  1008     IORWF 0x8, W, ACCESS
4C8E  A4D8     BTFSS 0xFD8, 2, ACCESS
4C90  EF4C     GOTO 0x4C98
4C92  F026     NOP
4C94  EF4E     GOTO 0x4C9C
4C96  F026     NOP
4C98  EF2B     GOTO 0x4C56
4C9A  F026     NOP
4C9C  EF56     GOTO 0x4CAC
4C9E  F026     NOP
29:            		++exp;
4C56  2A0A     INCF 0xA, F, ACCESS
30:            		++arg;
4C58  0E01     MOVLW 0x1
4C5A  260B     ADDWF 0xB, F, ACCESS
4C5C  0E00     MOVLW 0x0
4C5E  220C     ADDWFC 0xC, F, ACCESS
4C60  220D     ADDWFC 0xD, F, ACCESS
4C62  220E     ADDWFC 0xE, F, ACCESS
31:            		arg >>= 1;
4C64  90D8     BCF 0xFD8, 0, ACCESS
4C66  320E     RRCF 0xE, F, ACCESS
4C68  320D     RRCF 0xD, F, ACCESS
4C6A  320C     RRCF 0xC, F, ACCESS
4C6C  320B     RRCF 0xB, F, ACCESS
32:            	}
33:            	while(!(arg & 0x800000UL) && exp > 1) {
4CAC  BE0D     BTFSC 0xD, 7, ACCESS
4CAE  EF5B     GOTO 0x4CB6
4CB0  F026     NOP
4CB2  EF5D     GOTO 0x4CBA
4CB4  F026     NOP
4CB6  EF65     GOTO 0x4CCA
4CB8  F026     NOP
4CBA  0E02     MOVLW 0x2
4CBC  600A     CPFSLT 0xA, ACCESS
4CBE  EF63     GOTO 0x4CC6
4CC0  F026     NOP
4CC2  EF65     GOTO 0x4CCA
4CC4  F026     NOP
4CC6  EF50     GOTO 0x4CA0
4CC8  F026     NOP
34:            		--exp;
4CA0  060A     DECF 0xA, F, ACCESS
35:            		arg <<= 1;
4CA2  90D8     BCF 0xFD8, 0, ACCESS
4CA4  360B     RLCF 0xB, F, ACCESS
4CA6  360C     RLCF 0xC, F, ACCESS
4CA8  360D     RLCF 0xD, F, ACCESS
4CAA  360E     RLCF 0xE, F, ACCESS
36:            	}
37:            	if(!(exp & 1))
4CCA  B00A     BTFSC 0xA, 0, ACCESS
4CCC  EF6A     GOTO 0x4CD4
4CCE  F026     NOP
4CD0  EF6C     GOTO 0x4CD8
4CD2  F026     NOP
4CD4  EF6D     GOTO 0x4CDA
4CD6  F026     NOP
38:            		arg &= ~0x800000UL;
4CD8  9E0D     BCF 0xD, 7, ACCESS
39:            	exp >>= 1;
4CDA  90D8     BCF 0xFD8, 0, ACCESS
4CDC  320A     RRCF 0xA, F, ACCESS
40:            	arg |= (unsigned long)exp << 24;
4CDE  C50A     MOVFF r, n
4CE0  F505     NOP
4CE2  6A06     CLRF 0x6, ACCESS
4CE4  6A07     CLRF 0x7, ACCESS
4CE6  6A08     CLRF 0x8, ACCESS
4CE8  C505     MOVFF n, l
4CEA  F508     NOP
4CEC  6A07     CLRF 0x7, ACCESS
4CEE  6A06     CLRF 0x6, ACCESS
4CF0  6A05     CLRF 0x5, ACCESS
4CF2  5005     MOVF 0x5, W, ACCESS
4CF4  120B     IORWF 0xB, F, ACCESS
4CF6  5006     MOVF 0x6, W, ACCESS
4CF8  120C     IORWF 0xC, F, ACCESS
4CFA  5007     MOVF 0x7, W, ACCESS
4CFC  120D     IORWF 0xD, F, ACCESS
4CFE  5008     MOVF 0x8, W, ACCESS
4D00  120E     IORWF 0xE, F, ACCESS
41:            	if(sign && val < 0)
4D02  5009     MOVF 0x9, W, ACCESS
4D04  B4D8     BTFSC 0xFD8, 2, ACCESS
4D06  EF87     GOTO 0x4D0E
4D08  F026     NOP
4D0A  EF89     GOTO 0x4D12
4D0C  F026     NOP
4D0E  EF91     GOTO 0x4D22
4D10  F026     NOP
4D12  BE04     BTFSC 0x4, 7, ACCESS
4D14  EF90     GOTO 0x4D20
4D16  F026     NOP
4D18  EF8E     GOTO 0x4D1C
4D1A  F026     NOP
4D1C  EF91     GOTO 0x4D22
4D1E  F026     NOP
42:            		arg |= 0x80000000UL;
4D20  8E0E     BSF 0xE, 7, ACCESS
43:            	return *(double *)&arg;
4D22  C50B     MOVFF arg, __pcstackCOMRAM
4D24  F501     NOP
4D26  C50C     MOVFF s, txData
4D28  F502     NOP
4D2A  C50D     MOVFF signs, _r
4D2C  F503     NOP
4D2E  C50E     MOVFF fp, 0x504
4D30  F504     NOP
44:            }
4D32  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.20/pic/sources/c99/common/tolower.c  -----------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             
4:             int tolower(int c)
5978  0EBF     MOVLW 0xBF
597A  6E09     MOVWF 0x9, ACCESS
597C  0EFF     MOVLW 0xFF
597E  6E0A     MOVWF 0xA, ACCESS
5980  C507     MOVFF s, arg
5982  F50B     NOP
5984  C508     MOVFF l, s
5986  F50C     NOP
5988  5009     MOVF 0x9, W, ACCESS
598A  260B     ADDWF 0xB, F, ACCESS
598C  500A     MOVF 0xA, W, ACCESS
598E  220C     ADDWFC 0xC, F, ACCESS
5990  500C     MOVF 0xC, W, ACCESS
5992  E10A     BNZ 0x59A8
5994  0E1A     MOVLW 0x1A
5996  5C0B     SUBWF 0xB, W, ACCESS
5998  A0D8     BTFSS 0xFD8, 0, ACCESS
599A  EFD1     GOTO 0x59A2
599C  F02C     NOP
599E  EFD4     GOTO 0x59A8
59A0  F02C     NOP
59A2  0E01     MOVLW 0x1
59A4  EFD5     GOTO 0x59AA
59A6  F02C     NOP
59A8  0E00     MOVLW 0x0
59AA  6E0D     MOVWF 0xD, ACCESS
59AC  6A0E     CLRF 0xE, ACCESS
59AE  500D     MOVF 0xD, W, ACCESS
59B0  100E     IORWF 0xE, W, ACCESS
59B2  B4D8     BTFSC 0xFD8, 2, ACCESS
59B4  EFDE     GOTO 0x59BC
59B6  F02C     NOP
59B8  EFE0     GOTO 0x59C0
59BA  F02C     NOP
59BC  EFE7     GOTO 0x59CE
59BE  F02C     NOP
59C0  0E20     MOVLW 0x20
59C2  1007     IORWF 0x7, W, ACCESS
59C4  6E07     MOVWF 0x7, ACCESS
59C6  5008     MOVF 0x8, W, ACCESS
59C8  6E08     MOVWF 0x8, ACCESS
59CA  EFEB     GOTO 0x59D6
59CC  F02C     NOP
5:             {
6:             	if (isupper(c)) return c | 32;
7:             	return c;
59CE  C507     MOVFF s, s
59D0  F507     NOP
59D2  C508     MOVFF l, l
59D4  F508     NOP
8:             }
59D6  0012     RETURN 0
9:             
10:            int __tolower_l(int c, locale_t l)
11:            {
12:            	return tolower(c);
13:            }
14:            
15:            weak_alias(__tolower_l, tolower_l);
---  C:/Program Files/Microchip/xc8/v2.20/pic/sources/c99/common/strncmp.c  -----------------------------
1:             #include <string.h>
2:             
3:             int strncmp(const char *_l, const char *_r, size_t n)
5328  C501     MOVFF __pcstackCOMRAM, l
532A  F508     NOP
532C  C502     MOVFF txData, d
532E  F509     NOP
5330  C503     MOVFF _r, r
5332  F50A     NOP
5334  C504     MOVFF 0x504, arg
5336  F50B     NOP
4:             {
5:             	const unsigned char *l=(void *)_l, *r=(void *)_r;
6:             	if (!n--) return 0;
5338  0605     DECF 0x5, F, ACCESS
533A  A0D8     BTFSS 0xFD8, 0, ACCESS
533C  0606     DECF 0x6, F, ACCESS
533E  2805     INCF 0x5, W, ACCESS
5340  E106     BNZ 0x534E
5342  2806     INCF 0x6, W, ACCESS
5344  A4D8     BTFSS 0xFD8, 2, ACCESS
5346  EFA7     GOTO 0x534E
5348  F029     NOP
534A  EFA9     GOTO 0x5352
534C  F029     NOP
534E  EFB6     GOTO 0x536C
5350  F029     NOP
5352  0E00     MOVLW 0x0
5354  6E02     MOVWF 0x2, ACCESS
5356  0E00     MOVLW 0x0
5358  6E01     MOVWF 0x1, ACCESS
535A  EF10     GOTO 0x5420
535C  F02A     NOP
7:             	for (; *l && *r && n && *l == *r ; l++, r++, n--);
535E  4A08     INFSNZ 0x8, F, ACCESS
5360  2A09     INCF 0x9, F, ACCESS
5362  4A0A     INFSNZ 0xA, F, ACCESS
5364  2A0B     INCF 0xB, F, ACCESS
5366  0605     DECF 0x5, F, ACCESS
5368  A0D8     BTFSS 0xFD8, 0, ACCESS
536A  0606     DECF 0x6, F, ACCESS
536E  F420     NOP
5370  F4D9     NOP
5374  F424     NOP
5376  F4DA     NOP
5378  50DF     MOVF 0xFDF, W, ACCESS
537A  B4D8     BTFSC 0xFD8, 2, ACCESS
537C  EFC2     GOTO 0x5384
537E  F029     NOP
5380  EFC4     GOTO 0x5388
5382  F029     NOP
5384  EFF9     GOTO 0x53F2
5386  F029     NOP
538A  F428     NOP
538C  F4F6     NOP
5390  F42C     NOP
5392  F4F7     NOP
5394  0E00     MOVLW 0x0
5396  6EF8     MOVWF 0xFF8, ACCESS
5398  0008     TBLRD*
539A  50F5     MOVF 0xFF5, W, ACCESS
539C  0900     IORLW 0x0
539E  B4D8     BTFSC 0xFD8, 2, ACCESS
53A0  EFD4     GOTO 0x53A8
53A2  F029     NOP
53A4  EFD6     GOTO 0x53AC
53A6  F029     NOP
53A8  EFF9     GOTO 0x53F2
53AA  F029     NOP
53AC  5005     MOVF 0x5, W, ACCESS
53AE  1006     IORWF 0x6, W, ACCESS
53B0  B4D8     BTFSC 0xFD8, 2, ACCESS
53B2  EFDD     GOTO 0x53BA
53B4  F029     NOP
53B6  EFDF     GOTO 0x53BE
53B8  F029     NOP
53BA  EFF9     GOTO 0x53F2
53BC  F029     NOP
53C0  F420     NOP
53C2  F4D9     NOP
53C6  F424     NOP
53C8  F4DA     NOP
53CA  50DF     MOVF 0xFDF, W, ACCESS
53CC  6E07     MOVWF 0x7, ACCESS
53D0  F428     NOP
53D2  F4F6     NOP
53D6  F42C     NOP
53D8  F4F7     NOP
53DA  0E00     MOVLW 0x0
53DC  6EF8     MOVWF 0xFF8, ACCESS
53DE  0008     TBLRD*
53E0  50F5     MOVF 0xFF5, W, ACCESS
53E2  1807     XORWF 0x7, W, ACCESS
53E4  B4D8     BTFSC 0xFD8, 2, ACCESS
53E6  EFF7     GOTO 0x53EE
53E8  F029     NOP
53EA  EFF9     GOTO 0x53F2
53EC  F029     NOP
53EE  EFAF     GOTO 0x535E
53F0  F029     NOP
8:             	return *l - *r;
53F4  F420     NOP
53F6  F4D9     NOP
53FA  F424     NOP
53FC  F4DA     NOP
53FE  50DF     MOVF 0xFDF, W, ACCESS
5400  6E07     MOVWF 0x7, ACCESS
5404  F428     NOP
5406  F4F6     NOP
540A  F42C     NOP
540C  F4F7     NOP
540E  0E00     MOVLW 0x0
5410  6EF8     MOVWF 0xFF8, ACCESS
5412  0008     TBLRD*
5414  50F5     MOVF 0xFF5, W, ACCESS
5416  5C07     SUBWF 0x7, W, ACCESS
5418  6E01     MOVWF 0x1, ACCESS
541A  6A02     CLRF 0x2, ACCESS
541C  A0D8     BTFSS 0xFD8, 0, ACCESS
541E  0602     DECF 0x2, F, ACCESS
9:             }
5420  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.20/pic/sources/c99/common/strlen.c  ------------------------------
1:             #include <string.h>
2:             #include <stdint.h>
3:             #include <limits.h>
4:             
5:             size_t strlen(const char *s)
5B3E  C501     MOVFF __pcstackCOMRAM, _r
5B40  F503     NOP
5B42  C502     MOVFF txData, 0x504
5B44  F504     NOP
6:             {
7:             	const char *a = s;
8:             	while(*s) {
5B46  EFA7     GOTO 0x5B4E
5B48  F02D     NOP
5B50  F404     NOP
5B52  F4D9     NOP
5B56  F408     NOP
5B58  F4DA     NOP
5B5A  50DF     MOVF 0xFDF, W, ACCESS
5B5C  A4D8     BTFSS 0xFD8, 2, ACCESS
5B5E  EFB3     GOTO 0x5B66
5B60  F02D     NOP
5B62  EFB5     GOTO 0x5B6A
5B64  F02D     NOP
5B66  EFA5     GOTO 0x5B4A
5B68  F02D     NOP
9:             		s++;
5B4A  4A01     INFSNZ 0x1, F, ACCESS
5B4C  2A02     INCF 0x2, F, ACCESS
10:            	}
11:            	return s-a;
5B6A  5003     MOVF 0x3, W, ACCESS
5B6C  5C01     SUBWF 0x1, W, ACCESS
5B6E  6E01     MOVWF 0x1, ACCESS
5B70  5004     MOVF 0x4, W, ACCESS
5B72  5802     SUBWFB 0x2, W, ACCESS
5B74  6E02     MOVWF 0x2, ACCESS
12:            }
5B76  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.20/pic/sources/c99/common/strcpy.c  ------------------------------
1:             #include <string.h>
2:             
3:             char *strcpy(char *restrict dest, const char *restrict src)
5912  C503     MOVFF _r, s
5914  F507     NOP
5916  C504     MOVFF 0x504, l
5918  F508     NOP
4:             {
5:             	const char *s = src;
6:             	char *d = dest;
591A  C501     MOVFF __pcstackCOMRAM, d
591C  F509     NOP
591E  C502     MOVFF txData, r
5920  F50A     NOP
7:             	while ((*d++ = *s++));
5922  5007     MOVF 0x7, W, ACCESS
5924  6E05     MOVWF 0x5, ACCESS
5926  5008     MOVF 0x8, W, ACCESS
5928  6E06     MOVWF 0x6, ACCESS
592A  4A07     INFSNZ 0x7, F, ACCESS
592C  2A08     INCF 0x8, F, ACCESS
5930  F414     NOP
5932  F4F6     NOP
5936  F418     NOP
5938  F4F7     NOP
593A  0E00     MOVLW 0x0
593C  6EF8     MOVWF 0xFF8, ACCESS
5940  F424     NOP
5942  F4D9     NOP
5946  F428     NOP
5948  F4DA     NOP
594A  4A09     INFSNZ 0x9, F, ACCESS
594C  2A0A     INCF 0xA, F, ACCESS
594E  0E24     MOVLW 0x24
5950  64F7     CPFSGT 0xFF7, ACCESS
5952  D003     BRA 0x595A
5954  0008     TBLRD*
5956  50F5     MOVF 0xFF5, W, ACCESS
5958  D005     BRA 0x5964
595A  C4F6     MOVFF TBLPTR, FSR0
595C  F4E9     NOP
595E  C4F7     MOVFF TBLPTRH, FSR0H
5960  F4EA     NOP
5962  50EF     MOVF 0xFEF, W, ACCESS
5964  6EDF     MOVWF 0xFDF, ACCESS
5966  50DF     MOVF 0xFDF, W, ACCESS
5968  A4D8     BTFSS 0xFD8, 2, ACCESS
596A  EFB9     GOTO 0x5972
596C  F02C     NOP
596E  EFBB     GOTO 0x5976
5970  F02C     NOP
5972  EF91     GOTO 0x5922
5974  F02C     NOP
8:             	return dest;
9:             }
5976  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.20/pic/sources/c99/common/sprcmul.c  -----------------------------
1:             /* SP relaxed compliance floating point multiply intrinsic function */
2:             #include <stdint.h>
3:             #include "fpform.h"
4:             
5:             /* SP Multiply */
6:             /* single monolithic routine */
7:             SP
8:             SPMUL(SP b, SP a) {
3B12  5012     MOVF 0x12, W, ACCESS
3B14  0B80     ANDLW 0x80
3B16  6E1B     MOVWF 0x1B, ACCESS
9:             	unsigned char sign;	/* sign of result */
10:            	unsigned char bexp;	/* Dst exponent */
11:            	unsigned char aexp;	/* Src exponent */
12:            	uint32_t grs;		/* Guard, round, sticky */
13:            	SFP prod;
14:            	wordProduct temp;	/* intermediate mult results ; exponent of result */
15:            
16:            	/* Unpack and check operands */
17:            	sign = (*(SFP *) & b).fAsBytes.d & 0x80;
18:            	bexp = ((*(SFP *) & b).fAsBytes.d) << 1;
3B18  5012     MOVF 0x12, W, ACCESS
3B1A  2412     ADDWF 0x12, W, ACCESS
3B1C  6E21     MOVWF 0x21, ACCESS
19:            	if ((*(SFP *) & b).fAsBytes.c & 0x80) {
3B1E  AE11     BTFSS 0x11, 7, ACCESS
3B20  EF94     GOTO 0x3B28
3B22  F01D     NOP
3B24  EF96     GOTO 0x3B2C
3B26  F01D     NOP
3B28  EF97     GOTO 0x3B2E
3B2A  F01D     NOP
20:            		bexp |= 0x1;
3B2C  8021     BSF 0x21, 0, ACCESS
21:            	}
22:            
23:            	/* Destination normal ? */
24:            	if (bexp) {
3B2E  5021     MOVF 0x21, W, ACCESS
3B30  B4D8     BTFSC 0xFD8, 2, ACCESS
3B32  EF9D     GOTO 0x3B3A
3B34  F01D     NOP
3B36  EF9F     GOTO 0x3B3E
3B38  F01D     NOP
3B3A  EFB2     GOTO 0x3B64
3B3C  F01D     NOP
25:            		/* Destination inf or NaN ? */
26:            		if (bexp == 0xFF) {
3B3E  2821     INCF 0x21, W, ACCESS
3B40  A4D8     BTFSS 0xFD8, 2, ACCESS
3B42  EFA5     GOTO 0x3B4A
3B44  F01D     NOP
3B46  EFA7     GOTO 0x3B4E
3B48  F01D     NOP
3B4A  EFAF     GOTO 0x3B5E
3B4C  F01D     NOP
27:            			/* Make it inf */
28:            			b = 0;
3B4E  0E00     MOVLW 0x0
3B50  6E0F     MOVWF 0xF, ACCESS
3B52  0E00     MOVLW 0x0
3B54  6E10     MOVWF 0x10, ACCESS
3B56  0E00     MOVLW 0x0
3B58  6E11     MOVWF 0x11, ACCESS
3B5A  0E00     MOVLW 0x0
3B5C  6E12     MOVWF 0x12, ACCESS
29:            		}
30:            		// and in the implied 1-bit to b's fraction
31:            		(*(SFP *) & b).i |= (int32_t) 1 << SPFRCB;
3B5E  8E11     BSF 0x11, 7, ACCESS
32:            
33:            	}
3B60  EFBA     GOTO 0x3B74
3B62  F01D     NOP
34:            	else {
35:            		/* Make it zero */
36:            		b = 0;
3B64  0E00     MOVLW 0x0
3B66  6E0F     MOVWF 0xF, ACCESS
3B68  0E00     MOVLW 0x0
3B6A  6E10     MOVWF 0x10, ACCESS
3B6C  0E00     MOVLW 0x0
3B6E  6E11     MOVWF 0x11, ACCESS
3B70  0E00     MOVLW 0x0
3B72  6E12     MOVWF 0x12, ACCESS
37:            	}
38:            
39:            	sign ^= (*(SFP *) & a).fAsBytes.d & 0x80;
3B74  5016     MOVF 0x16, W, ACCESS
3B76  0B80     ANDLW 0x80
3B78  1A1B     XORWF 0x1B, F, ACCESS
40:            	aexp = ((*(SFP *) & a).fAsBytes.d) << 1;
3B7A  5016     MOVF 0x16, W, ACCESS
3B7C  2416     ADDWF 0x16, W, ACCESS
3B7E  6E20     MOVWF 0x20, ACCESS
41:            	if ((*(SFP *) & a).fAsBytes.c & 0x80) {
3B80  AE15     BTFSS 0x15, 7, ACCESS
3B82  EFC5     GOTO 0x3B8A
3B84  F01D     NOP
3B86  EFC7     GOTO 0x3B8E
3B88  F01D     NOP
3B8A  EFC8     GOTO 0x3B90
3B8C  F01D     NOP
42:            		aexp |= 0x1;
3B8E  8020     BSF 0x20, 0, ACCESS
43:            	}
44:            	/* Destination normal ? */
45:            	if (aexp) {
3B90  5020     MOVF 0x20, W, ACCESS
3B92  B4D8     BTFSC 0xFD8, 2, ACCESS
3B94  EFCE     GOTO 0x3B9C
3B96  F01D     NOP
3B98  EFD0     GOTO 0x3BA0
3B9A  F01D     NOP
3B9C  EFE3     GOTO 0x3BC6
3B9E  F01D     NOP
46:            
47:            		/* Destination inf or NaN ? */
48:            		if (aexp == 0xFF) {
3BA0  2820     INCF 0x20, W, ACCESS
3BA2  A4D8     BTFSS 0xFD8, 2, ACCESS
3BA4  EFD6     GOTO 0x3BAC
3BA6  F01D     NOP
3BA8  EFD8     GOTO 0x3BB0
3BAA  F01D     NOP
3BAC  EFE0     GOTO 0x3BC0
3BAE  F01D     NOP
49:            			/* Make it inf */
50:            			a = 0;
3BB0  0E00     MOVLW 0x0
3BB2  6E13     MOVWF 0x13, ACCESS
3BB4  0E00     MOVLW 0x0
3BB6  6E14     MOVWF 0x14, ACCESS
3BB8  0E00     MOVLW 0x0
3BBA  6E15     MOVWF 0x15, ACCESS
3BBC  0E00     MOVLW 0x0
3BBE  6E16     MOVWF 0x16, ACCESS
51:            		}
52:            		// and in the implied 1-bit to a's fraction
53:            		(*(SFP *) & a).i |= (int32_t) 1 << SPFRCB;
3BC0  8E15     BSF 0x15, 7, ACCESS
54:            	}
3BC2  EFEB     GOTO 0x3BD6
3BC4  F01D     NOP
55:            	else {
56:            		/* Make it zero */
57:            		a = 0;
3BC6  0E00     MOVLW 0x0
3BC8  6E13     MOVWF 0x13, ACCESS
3BCA  0E00     MOVLW 0x0
3BCC  6E14     MOVWF 0x14, ACCESS
3BCE  0E00     MOVLW 0x0
3BD0  6E15     MOVWF 0x15, ACCESS
3BD2  0E00     MOVLW 0x0
3BD4  6E16     MOVWF 0x16, ACCESS
58:            	}
3BD6  5020     MOVF 0x20, W, ACCESS
3BD8  B4D8     BTFSC 0xFD8, 2, ACCESS
3BDA  EFF1     GOTO 0x3BE2
3BDC  F01D     NOP
3BDE  EFF3     GOTO 0x3BE6
3BE0  F01D     NOP
3BE2  EFFB     GOTO 0x3BF6
3BE4  F01D     NOP
3BE6  5021     MOVF 0x21, W, ACCESS
3BE8  A4D8     BTFSS 0xFD8, 2, ACCESS
3BEA  EFF9     GOTO 0x3BF2
3BEC  F01D     NOP
3BEE  EFFB     GOTO 0x3BF6
3BF0  F01D     NOP
3BF2  EF05     GOTO 0x3C0A
3BF4  F01E     NOP
59:            
60:            	/* Multiply */
61:            
62:            	/* Special operand check */
63:            
64:            	/* Source or destination zero ? Result zero */
65:            	if (aexp == 0 || bexp == 0) {
66:            		return 0.0;
3BF6  0E00     MOVLW 0x0
3BF8  6E0F     MOVWF 0xF, ACCESS
3BFA  0E00     MOVLW 0x0
3BFC  6E10     MOVWF 0x10, ACCESS
3BFE  0E00     MOVLW 0x0
3C00  6E11     MOVWF 0x11, ACCESS
3C02  0E00     MOVLW 0x0
3C04  6E12     MOVWF 0x12, ACCESS
3C06  EFAF     GOTO 0x3F5E
3C08  F01F     NOP
67:            	}
68:            
69:            //    we decompose a 24 bit multiply into 9 8 bit multiplies as follows:
70:            //
71:            //    b's fraction is b1|b2|b3 and a's fraction is a1|a2|a3
72:            //
73:            //    then ab is the (48 bit) sum of these 9 16 bit intermediate products shifted appropriately
74:            //
75:            //
76:            //                                     a3b3
77:            //                                   a2b3
78:            //                                   a3b2
79:            //                                 a1b3
80:            //                                 a2b2
81:            //                                 a3b1
82:            //                               a1b2
83:            //                               a2b1
84:            //                             a1b1
85:            //
86:            //   in this algorithm we compute the product to be the upper 24 bits of the sum and grs to be the lower 24 bits
87:            //   shifted 8 to the left     then we renormalize and round as usual.
88:            //
89:            
90:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
91:            #define MIDBYTE(x)  (*(((unsigned char *)(&x))+1))
92:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+2))
93:            
94:            #ifdef _PIC18
95:            	temp.n = HIGHBYTE(a) * LOWBYTE(b);
3C0A  5015     MOVF 0x15, W, ACCESS
3C0C  020F     MULWF 0xF, ACCESS
3C10  F3CC     NOP
3C12  F526     NOP
3C16  F3D0     NOP
3C18  F527     NOP
96:            	grs = temp.nAsBytes.a;
3C1A  5026     MOVF 0x26, W, ACCESS
3C1C  6E1C     MOVWF 0x1C, ACCESS
3C1E  6A1D     CLRF 0x1D, ACCESS
3C20  6A1E     CLRF 0x1E, ACCESS
3C22  6A1F     CLRF 0x1F, ACCESS
97:            	prod.i = temp.nAsBytes.b;
3C24  5027     MOVF 0x27, W, ACCESS
3C26  6E22     MOVWF 0x22, ACCESS
3C28  6A23     CLRF 0x23, ACCESS
3C2A  6A24     CLRF 0x24, ACCESS
3C2C  6A25     CLRF 0x25, ACCESS
98:            	temp.n = MIDBYTE(a) * MIDBYTE(b);
3C2E  5014     MOVF 0x14, W, ACCESS
3C30  0210     MULWF 0x10, ACCESS
3C34  F3CC     NOP
3C36  F526     NOP
3C3A  F3D0     NOP
3C3C  F527     NOP
99:            	grs += temp.nAsBytes.a;
3C3E  5026     MOVF 0x26, W, ACCESS
3C40  261C     ADDWF 0x1C, F, ACCESS
3C42  0E00     MOVLW 0x0
3C44  221D     ADDWFC 0x1D, F, ACCESS
3C46  221E     ADDWFC 0x1E, F, ACCESS
3C48  221F     ADDWFC 0x1F, F, ACCESS
100:           	prod.i += temp.nAsBytes.b;
3C4A  5027     MOVF 0x27, W, ACCESS
3C4C  2622     ADDWF 0x22, F, ACCESS
3C4E  0E00     MOVLW 0x0
3C50  2223     ADDWFC 0x23, F, ACCESS
3C52  2224     ADDWFC 0x24, F, ACCESS
3C54  2225     ADDWFC 0x25, F, ACCESS
101:           	temp.n = LOWBYTE(a) * HIGHBYTE(b);
3C56  5013     MOVF 0x13, W, ACCESS
3C58  0211     MULWF 0x11, ACCESS
3C5C  F3CC     NOP
3C5E  F526     NOP
3C62  F3D0     NOP
3C64  F527     NOP
102:           	grs += temp.nAsBytes.a;
3C66  5026     MOVF 0x26, W, ACCESS
3C68  261C     ADDWF 0x1C, F, ACCESS
3C6A  0E00     MOVLW 0x0
3C6C  221D     ADDWFC 0x1D, F, ACCESS
3C6E  221E     ADDWFC 0x1E, F, ACCESS
3C70  221F     ADDWFC 0x1F, F, ACCESS
103:           	prod.i += temp.nAsBytes.b;
3C72  5027     MOVF 0x27, W, ACCESS
3C74  2622     ADDWF 0x22, F, ACCESS
3C76  0E00     MOVLW 0x0
3C78  2223     ADDWFC 0x23, F, ACCESS
3C7A  2224     ADDWFC 0x24, F, ACCESS
3C7C  2225     ADDWFC 0x25, F, ACCESS
104:           	grs <<= 8;
3C7E  C51E     MOVFF fp, sign
3C80  F51F     NOP
3C82  C51D     MOVFF 0x51D, fp
3C84  F51E     NOP
3C86  C51C     MOVFF grs, 0x51D
3C88  F51D     NOP
3C8A  6A1C     CLRF 0x1C, ACCESS
105:           	temp.n = LOWBYTE(a) * MIDBYTE(b);
3C8C  5013     MOVF 0x13, W, ACCESS
3C8E  0210     MULWF 0x10, ACCESS
3C92  F3CC     NOP
3C94  F526     NOP
3C98  F3D0     NOP
3C9A  F527     NOP
106:           	grs += (unsigned long)temp.n;
3C9C  5026     MOVF 0x26, W, ACCESS
3C9E  261C     ADDWF 0x1C, F, ACCESS
3CA0  5027     MOVF 0x27, W, ACCESS
3CA2  221D     ADDWFC 0x1D, F, ACCESS
3CA4  0E00     MOVLW 0x0
3CA6  221E     ADDWFC 0x1E, F, ACCESS
3CA8  0E00     MOVLW 0x0
3CAA  221F     ADDWFC 0x1F, F, ACCESS
107:           	temp.n = MIDBYTE(a) * LOWBYTE(b);
3CAC  5014     MOVF 0x14, W, ACCESS
3CAE  020F     MULWF 0xF, ACCESS
3CB2  F3CC     NOP
3CB4  F526     NOP
3CB8  F3D0     NOP
3CBA  F527     NOP
108:           	grs += (unsigned long)temp.n;
3CBC  5026     MOVF 0x26, W, ACCESS
3CBE  261C     ADDWF 0x1C, F, ACCESS
3CC0  5027     MOVF 0x27, W, ACCESS
3CC2  221D     ADDWFC 0x1D, F, ACCESS
3CC4  0E00     MOVLW 0x0
3CC6  221E     ADDWFC 0x1E, F, ACCESS
3CC8  0E00     MOVLW 0x0
3CCA  221F     ADDWFC 0x1F, F, ACCESS
109:           	grs <<= 8;
3CCC  C51E     MOVFF fp, sign
3CCE  F51F     NOP
3CD0  C51D     MOVFF 0x51D, fp
3CD2  F51E     NOP
3CD4  C51C     MOVFF grs, 0x51D
3CD6  F51D     NOP
3CD8  6A1C     CLRF 0x1C, ACCESS
110:           	temp.n = LOWBYTE(a) * LOWBYTE(b);
3CDA  5013     MOVF 0x13, W, ACCESS
3CDC  020F     MULWF 0xF, ACCESS
3CE0  F3CC     NOP
3CE2  F526     NOP
3CE6  F3D0     NOP
3CE8  F527     NOP
111:           	grs += (unsigned long)temp.n;
3CEA  5026     MOVF 0x26, W, ACCESS
3CEC  261C     ADDWF 0x1C, F, ACCESS
3CEE  5027     MOVF 0x27, W, ACCESS
3CF0  221D     ADDWFC 0x1D, F, ACCESS
3CF2  0E00     MOVLW 0x0
3CF4  221E     ADDWFC 0x1E, F, ACCESS
3CF6  0E00     MOVLW 0x0
3CF8  221F     ADDWFC 0x1F, F, ACCESS
112:           	temp.n = HIGHBYTE(a) * MIDBYTE(b);
3CFA  5015     MOVF 0x15, W, ACCESS
3CFC  0210     MULWF 0x10, ACCESS
3D00  F3CC     NOP
3D02  F526     NOP
3D06  F3D0     NOP
3D08  F527     NOP
113:           	prod.i += (unsigned long)temp.n;
3D0A  5026     MOVF 0x26, W, ACCESS
3D0C  2622     ADDWF 0x22, F, ACCESS
3D0E  5027     MOVF 0x27, W, ACCESS
3D10  2223     ADDWFC 0x23, F, ACCESS
3D12  0E00     MOVLW 0x0
3D14  2224     ADDWFC 0x24, F, ACCESS
3D16  0E00     MOVLW 0x0
3D18  2225     ADDWFC 0x25, F, ACCESS
114:           	temp.n = MIDBYTE(a) * HIGHBYTE(b);
3D1A  5014     MOVF 0x14, W, ACCESS
3D1C  0211     MULWF 0x11, ACCESS
3D20  F3CC     NOP
3D22  F526     NOP
3D26  F3D0     NOP
3D28  F527     NOP
115:           	prod.i += (unsigned long)temp.n;
3D2A  5026     MOVF 0x26, W, ACCESS
3D2C  2622     ADDWF 0x22, F, ACCESS
3D2E  5027     MOVF 0x27, W, ACCESS
3D30  2223     ADDWFC 0x23, F, ACCESS
3D32  0E00     MOVLW 0x0
3D34  2224     ADDWFC 0x24, F, ACCESS
3D36  0E00     MOVLW 0x0
3D38  2225     ADDWFC 0x25, F, ACCESS
116:           	temp.n = HIGHBYTE(a) * HIGHBYTE(b);
3D3A  5015     MOVF 0x15, W, ACCESS
3D3C  0211     MULWF 0x11, ACCESS
3D40  F3CC     NOP
3D42  F526     NOP
3D46  F3D0     NOP
3D48  F527     NOP
117:           	prod.i += (((unsigned long)temp.n) << 8);
3D4A  5026     MOVF 0x26, W, ACCESS
3D4C  6E17     MOVWF 0x17, ACCESS
3D4E  5027     MOVF 0x27, W, ACCESS
3D50  6E18     MOVWF 0x18, ACCESS
3D52  6A19     CLRF 0x19, ACCESS
3D54  6A1A     CLRF 0x1A, ACCESS
3D56  C519     MOVFF 0x519, i
3D58  F51A     NOP
3D5A  C518     MOVFF 0x518, 0x519
3D5C  F519     NOP
3D5E  C517     MOVFF p, 0x518
3D60  F518     NOP
3D62  6A17     CLRF 0x17, ACCESS
3D64  5017     MOVF 0x17, W, ACCESS
3D66  2622     ADDWF 0x22, F, ACCESS
3D68  5018     MOVF 0x18, W, ACCESS
3D6A  2223     ADDWFC 0x23, F, ACCESS
3D6C  5019     MOVF 0x19, W, ACCESS
3D6E  2224     ADDWFC 0x24, F, ACCESS
3D70  501A     MOVF 0x1A, W, ACCESS
3D72  2225     ADDWFC 0x25, F, ACCESS
118:           #else
119:           	temp.n = _Umul8_16(HIGHBYTE(a), LOWBYTE(b));
120:           	grs = temp.nAsBytes.a;
121:           	prod.i = temp.nAsBytes.b;
122:           	temp.n = _Umul8_16(MIDBYTE(a), MIDBYTE(b));
123:           	grs += temp.nAsBytes.a;
124:           	prod.i += temp.nAsBytes.b;
125:           	temp.n = _Umul8_16(LOWBYTE(a), HIGHBYTE(b));
126:           	grs += temp.nAsBytes.a;
127:           	prod.i += temp.nAsBytes.b;
128:           	grs <<= 8;
129:           	temp.n = _Umul8_16(LOWBYTE(a), MIDBYTE(b));
130:           	grs += (unsigned long)temp.n;
131:           	temp.n = _Umul8_16(MIDBYTE(a), LOWBYTE(b));
132:           	grs += (unsigned long)temp.n;
133:           	grs <<= 8;
134:           	temp.n = _Umul8_16(LOWBYTE(a), LOWBYTE(b));
135:           	grs += (unsigned long)temp.n;
136:           	temp.n = _Umul8_16(HIGHBYTE(a), MIDBYTE(b));
137:           	prod.i += (unsigned long)temp.n;
138:           	temp.n = _Umul8_16(MIDBYTE(a), HIGHBYTE(b));
139:           	prod.i += (unsigned long)temp.n;
140:           	temp.n = _Umul8_16(HIGHBYTE(a), HIGHBYTE(b));
141:           	prod.i += (((unsigned long)temp.n) << 8);
142:           #endif
143:           
144:           	// first add the overflow bit from the lower half to the upper half
145:           	prod.i += (grs >> 24);
3D74  C51C     MOVFF grs, p
3D76  F517     NOP
3D78  C51D     MOVFF 0x51D, 0x518
3D7A  F518     NOP
3D7C  C51E     MOVFF fp, 0x519
3D7E  F519     NOP
3D80  C51F     MOVFF sign, i
3D82  F51A     NOP
3D84  0E19     MOVLW 0x19
3D86  EFCA     GOTO 0x3D94
3D88  F01E     NOP
3D8A  90D8     BCF 0xFD8, 0, ACCESS
3D8C  321A     RRCF 0x1A, F, ACCESS
3D8E  3219     RRCF 0x19, F, ACCESS
3D90  3218     RRCF 0x18, F, ACCESS
3D92  3217     RRCF 0x17, F, ACCESS
3D94  2EE8     DECFSZ 0xFE8, F, ACCESS
3D96  EFC5     GOTO 0x3D8A
3D98  F01E     NOP
3D9A  5017     MOVF 0x17, W, ACCESS
3D9C  2622     ADDWF 0x22, F, ACCESS
3D9E  5018     MOVF 0x18, W, ACCESS
3DA0  2223     ADDWFC 0x23, F, ACCESS
3DA2  5019     MOVF 0x19, W, ACCESS
3DA4  2224     ADDWFC 0x24, F, ACCESS
3DA6  501A     MOVF 0x1A, W, ACCESS
3DA8  2225     ADDWFC 0x25, F, ACCESS
146:           	grs <<= 8;
3DAA  C51E     MOVFF fp, sign
3DAC  F51F     NOP
3DAE  C51D     MOVFF 0x51D, fp
3DB0  F51E     NOP
3DB2  C51C     MOVFF grs, 0x51D
3DB4  F51D     NOP
3DB6  6A1C     CLRF 0x1C, ACCESS
147:           
148:           	/* Add source exponent, minus (bias - 1) */
149:           	temp.i = bexp + aexp - 126;
3DB8  5020     MOVF 0x20, W, ACCESS
3DBA  C521     MOVFF bexp, p
3DBC  F517     NOP
3DBE  6A18     CLRF 0x18, ACCESS
3DC0  2617     ADDWF 0x17, F, ACCESS
3DC2  0E00     MOVLW 0x0
3DC4  2218     ADDWFC 0x18, F, ACCESS
3DC6  0E82     MOVLW 0x82
3DC8  2417     ADDWF 0x17, W, ACCESS
3DCA  6E26     MOVWF 0x26, ACCESS
3DCC  0EFF     MOVLW 0xFF
3DCE  2018     ADDWFC 0x18, W, ACCESS
3DD0  6E27     MOVWF 0x27, ACCESS
150:           
151:           	/* Renormalize  */
152:           	while (!(prod.i & ((int32_t) 1 << SPFRCB))) {
3DD2  EF00     GOTO 0x3E00
3DD4  F01F     NOP
3E00  AE24     BTFSS 0x24, 7, ACCESS
3E02  EF05     GOTO 0x3E0A
3E04  F01F     NOP
3E06  EF07     GOTO 0x3E0E
3E08  F01F     NOP
3E0A  EFEB     GOTO 0x3DD6
3E0C  F01E     NOP
153:           		prod.i <<= 1;
3DD6  90D8     BCF 0xFD8, 0, ACCESS
3DD8  3622     RLCF 0x22, F, ACCESS
3DDA  3623     RLCF 0x23, F, ACCESS
3DDC  3624     RLCF 0x24, F, ACCESS
3DDE  3625     RLCF 0x25, F, ACCESS
154:           		if (grs & 0x80000000) {
3DE0  AE1F     BTFSS 0x1F, 7, ACCESS
3DE2  EFF5     GOTO 0x3DEA
3DE4  F01E     NOP
3DE6  EFF7     GOTO 0x3DEE
3DE8  F01E     NOP
3DEA  EFF8     GOTO 0x3DF0
3DEC  F01E     NOP
155:           			prod.i |= 0x1;
3DEE  8022     BSF 0x22, 0, ACCESS
156:           		}
3DF0  90D8     BCF 0xFD8, 0, ACCESS
3DF2  361C     RLCF 0x1C, F, ACCESS
3DF4  361D     RLCF 0x1D, F, ACCESS
3DF6  361E     RLCF 0x1E, F, ACCESS
3DF8  361F     RLCF 0x1F, F, ACCESS
157:           		grs <<= 1;
158:           		--temp.i;
3DFA  0626     DECF 0x26, F, ACCESS
3DFC  A0D8     BTFSS 0xFD8, 0, ACCESS
3DFE  0627     DECF 0x27, F, ACCESS
159:           	}
160:           
161:           	/* Round, check overflow, underflow */
162:           	// reuse aexp as round up flag
163:           	aexp = 0;
3E0E  0E00     MOVLW 0x0
3E10  6E20     MOVWF 0x20, ACCESS
164:           	if (grs & 0x80000000) {
3E12  AE1F     BTFSS 0x1F, 7, ACCESS
3E14  EF0E     GOTO 0x3E1C
3E16  F01F     NOP
3E18  EF10     GOTO 0x3E20
3E1A  F01F     NOP
3E1C  EF34     GOTO 0x3E68
3E1E  F01F     NOP
165:           		if (grs & 0x7FFFFFFF) {
3E20  0EFF     MOVLW 0xFF
3E22  141C     ANDWF 0x1C, W, ACCESS
3E24  6E17     MOVWF 0x17, ACCESS
3E26  0EFF     MOVLW 0xFF
3E28  141D     ANDWF 0x1D, W, ACCESS
3E2A  6E18     MOVWF 0x18, ACCESS
3E2C  0EFF     MOVLW 0xFF
3E2E  141E     ANDWF 0x1E, W, ACCESS
3E30  6E19     MOVWF 0x19, ACCESS
3E32  0E7F     MOVLW 0x7F
3E34  141F     ANDWF 0x1F, W, ACCESS
3E36  6E1A     MOVWF 0x1A, ACCESS
3E38  5017     MOVF 0x17, W, ACCESS
3E3A  1018     IORWF 0x18, W, ACCESS
3E3C  1019     IORWF 0x19, W, ACCESS
3E3E  101A     IORWF 0x1A, W, ACCESS
3E40  B4D8     BTFSC 0xFD8, 2, ACCESS
3E42  EF25     GOTO 0x3E4A
3E44  F01F     NOP
3E46  EF27     GOTO 0x3E4E
3E48  F01F     NOP
3E4A  EF2B     GOTO 0x3E56
3E4C  F01F     NOP
166:           			aexp = 1;
3E4E  0E01     MOVLW 0x1
3E50  6E20     MOVWF 0x20, ACCESS
167:           		}
3E52  EF34     GOTO 0x3E68
3E54  F01F     NOP
168:           		else {
3E56  A022     BTFSS 0x22, 0, ACCESS
3E58  EF30     GOTO 0x3E60
3E5A  F01F     NOP
3E5C  EF32     GOTO 0x3E64
3E5E  F01F     NOP
3E60  EF34     GOTO 0x3E68
3E62  F01F     NOP
3E64  EF27     GOTO 0x3E4E
3E66  F01F     NOP
169:           			if (prod.i & 1) {
170:           				aexp = 1;
171:           			}
172:           		}
173:           	}
3E68  5020     MOVF 0x20, W, ACCESS
3E6A  B4D8     BTFSC 0xFD8, 2, ACCESS
3E6C  EF3A     GOTO 0x3E74
3E6E  F01F     NOP
3E70  EF3C     GOTO 0x3E78
3E72  F01F     NOP
3E74  EF60     GOTO 0x3EC0
3E76  F01F     NOP
174:           	if (aexp) {
175:           		++prod.i;
3E78  0E01     MOVLW 0x1
3E7A  2622     ADDWF 0x22, F, ACCESS
3E7C  0E00     MOVLW 0x0
3E7E  2223     ADDWFC 0x23, F, ACCESS
3E80  2224     ADDWFC 0x24, F, ACCESS
3E82  2225     ADDWFC 0x25, F, ACCESS
176:           		if (prod.i & ((int32_t) 1 << (SPFRCB + 1))) {
3E84  A025     BTFSS 0x25, 0, ACCESS
3E86  EF47     GOTO 0x3E8E
3E88  F01F     NOP
3E8A  EF49     GOTO 0x3E92
3E8C  F01F     NOP
3E8E  EF60     GOTO 0x3EC0
3E90  F01F     NOP
177:           			prod.i = prod.i >> 1;
3E92  C522     MOVFF grs, p
3E94  F517     NOP
3E96  C523     MOVFF 0x523, 0x518
3E98  F518     NOP
3E9A  C524     MOVFF 0x524, 0x519
3E9C  F519     NOP
3E9E  C525     MOVFF 0x525, i
3EA0  F51A     NOP
3EA2  341A     RLCF 0x1A, W, ACCESS
3EA4  321A     RRCF 0x1A, F, ACCESS
3EA6  3219     RRCF 0x19, F, ACCESS
3EA8  3218     RRCF 0x18, F, ACCESS
3EAA  3217     RRCF 0x17, F, ACCESS
3EAC  C517     MOVFF p, grs
3EAE  F522     NOP
3EB0  C518     MOVFF 0x518, 0x523
3EB2  F523     NOP
3EB4  C519     MOVFF 0x519, 0x524
3EB6  F524     NOP
3EB8  C51A     MOVFF i, 0x525
3EBA  F525     NOP
178:           			++temp.i;
3EBC  4A26     INFSNZ 0x26, F, ACCESS
3EBE  2A27     INCF 0x27, F, ACCESS
179:           		}
180:           	}
181:           
182:           	/* Overflow ? Return infinity */
183:           	if (!(temp.i < SPEXPM)) {
3EC0  BE27     BTFSC 0x27, 7, ACCESS
3EC2  EF6B     GOTO 0x3ED6
3EC4  F01F     NOP
3EC6  5027     MOVF 0x27, W, ACCESS
3EC8  E108     BNZ 0x3EDA
3ECA  2826     INCF 0x26, W, ACCESS
3ECC  A0D8     BTFSS 0xFD8, 0, ACCESS
3ECE  EF6B     GOTO 0x3ED6
3ED0  F01F     NOP
3ED2  EF6D     GOTO 0x3EDA
3ED4  F01F     NOP
3ED6  EF77     GOTO 0x3EEE
3ED8  F01F     NOP
184:           		prod.i = 0x7F800000;
3EDA  0E00     MOVLW 0x0
3EDC  6E22     MOVWF 0x22, ACCESS
3EDE  0E00     MOVLW 0x0
3EE0  6E23     MOVWF 0x23, ACCESS
3EE2  0E80     MOVLW 0x80
3EE4  6E24     MOVWF 0x24, ACCESS
3EE6  0E7F     MOVLW 0x7F
3EE8  6E25     MOVWF 0x25, ACCESS
185:           	}
3EEA  EFA5     GOTO 0x3F4A
3EEC  F01F     NOP
186:           	/* Underflow ? Flush to zero */
187:           	else if (!(0 < temp.i)) {
3EEE  BE27     BTFSC 0x27, 7, ACCESS
3EF0  EF84     GOTO 0x3F08
3EF2  F01F     NOP
3EF4  5027     MOVF 0x27, W, ACCESS
3EF6  E106     BNZ 0x3F04
3EF8  0426     DECF 0x26, W, ACCESS
3EFA  B0D8     BTFSC 0xFD8, 0, ACCESS
3EFC  EF82     GOTO 0x3F04
3EFE  F01F     NOP
3F00  EF84     GOTO 0x3F08
3F02  F01F     NOP
3F04  EF90     GOTO 0x3F20
3F06  F01F     NOP
188:           		prod.i = 0;
3F08  0E00     MOVLW 0x0
3F0A  6E22     MOVWF 0x22, ACCESS
3F0C  0E00     MOVLW 0x0
3F0E  6E23     MOVWF 0x23, ACCESS
3F10  0E00     MOVLW 0x0
3F12  6E24     MOVWF 0x24, ACCESS
3F14  0E00     MOVLW 0x0
3F16  6E25     MOVWF 0x25, ACCESS
189:                           // no negative 0 for now
190:                           sign=0;
3F18  0E00     MOVLW 0x0
3F1A  6E1B     MOVWF 0x1B, ACCESS
191:           	}
3F1C  EFA5     GOTO 0x3F4A
3F1E  F01F     NOP
192:           	else {
3F20  C526     MOVFF bexp, bexp
3F22  F521     NOP
193:           		/* Pack and return result */
194:           		bexp = temp.i;	// it fits in 8 bits !
195:           		prod.i &= SPFRCM;	// trim away the leading 1
3F24  0EFF     MOVLW 0xFF
3F26  1622     ANDWF 0x22, F, ACCESS
3F28  0EFF     MOVLW 0xFF
3F2A  1623     ANDWF 0x23, F, ACCESS
3F2C  0E7F     MOVLW 0x7F
3F2E  1624     ANDWF 0x24, F, ACCESS
3F30  0E00     MOVLW 0x0
3F32  1625     ANDWF 0x25, F, ACCESS
196:           		if (bexp & 0x1) {
3F34  A021     BTFSS 0x21, 0, ACCESS
3F36  EF9F     GOTO 0x3F3E
3F38  F01F     NOP
3F3A  EFA1     GOTO 0x3F42
3F3C  F01F     NOP
3F3E  EFA2     GOTO 0x3F44
3F40  F01F     NOP
197:           			prod.fAsBytes.c |= 0x80;
3F42  8E24     BSF 0x24, 7, ACCESS
198:           		}
199:           		prod.fAsBytes.d = bexp >> 1;
3F44  90D8     BCF 0xFD8, 0, ACCESS
3F46  3021     RRCF 0x21, W, ACCESS
3F48  6E25     MOVWF 0x25, ACCESS
200:           	}
201:           	prod.fAsBytes.d |= sign;
3F4A  501B     MOVF 0x1B, W, ACCESS
3F4C  1225     IORWF 0x25, F, ACCESS
202:           
203:           	return prod.f;
3F4E  C522     MOVFF grs, bexp
3F50  F50F     NOP
3F52  C523     MOVFF 0x523, c
3F54  F510     NOP
3F56  C524     MOVFF 0x524, counter
3F58  F511     NOP
3F5A  C525     MOVFF 0x525, sign
3F5C  F512     NOP
204:           
205:           }
3F5E  0012     RETURN 0
206:           
---  C:/Program Files/Microchip/xc8/v2.20/pic/sources/c99/common/sprcdiv.c  -----------------------------
1:             /* SP relaxed compliance floating point divide intrinsic function */
2:             #include <stdint.h>
3:             #include "fpform.h"
4:             
5:             /* SP Divide */
6:             #ifdef __PICC__
7:             SP
8:             SPDIV(SP a, SP b)
9:             #else
10:            SP
11:            SPDIV(SP b, SP a)
3F60  5012     MOVF 0x12, W, ACCESS
3F62  0B80     ANDLW 0x80
3F64  6E1F     MOVWF 0x1F, ACCESS
12:            #endif
13:            {
14:            #define A_FRACTION    (*(SFP *)&a)
15:            #define B_FRACTION    (*(SFP *)&b)
16:            	unsigned char sign;	/* sign of result */
17:            
18:            	unsigned char bexp;	/* Dst exponent */
19:            	unsigned char aexp;	/* Src exponent */
20:            	int16_t new_exp;
21:            	uint32_t grs;		/* Guard, round, sticky */
22:            	uint32_t rem;
23:            
24:            	/* Unpack and check operands */
25:            	// put b's sign as the result sign ...
26:            	sign = B_FRACTION.fAsBytes.d & 0x80;
27:            	bexp = B_FRACTION.fAsBytes.d << 1;
3F66  5012     MOVF 0x12, W, ACCESS
3F68  2412     ADDWF 0x12, W, ACCESS
3F6A  6E26     MOVWF 0x26, ACCESS
28:            	if (B_FRACTION.fAsBytes.c & 0x80) {
3F6C  AE11     BTFSS 0x11, 7, ACCESS
3F6E  EFBB     GOTO 0x3F76
3F70  F01F     NOP
3F72  EFBD     GOTO 0x3F7A
3F74  F01F     NOP
3F76  EFBE     GOTO 0x3F7C
3F78  F01F     NOP
29:            		bexp |= 0x1;
3F7A  8026     BSF 0x26, 0, ACCESS
30:            	}
31:            
32:            	/* Destination normal ? */
33:            	if (bexp) {
3F7C  5026     MOVF 0x26, W, ACCESS
3F7E  B4D8     BTFSC 0xFD8, 2, ACCESS
3F80  EFC4     GOTO 0x3F88
3F82  F01F     NOP
3F84  EFC6     GOTO 0x3F8C
3F86  F01F     NOP
3F88  EFDB     GOTO 0x3FB6
3F8A  F01F     NOP
34:            		/* Destination inf or NaN ? */
35:            		if (bexp == 0xFF) {
3F8C  2826     INCF 0x26, W, ACCESS
3F8E  A4D8     BTFSS 0xFD8, 2, ACCESS
3F90  EFCC     GOTO 0x3F98
3F92  F01F     NOP
3F94  EFCE     GOTO 0x3F9C
3F96  F01F     NOP
3F98  EFD6     GOTO 0x3FAC
3F9A  F01F     NOP
36:            			/* Make it inf */
37:            			b = 0;
3F9C  0E00     MOVLW 0x0
3F9E  6E0F     MOVWF 0xF, ACCESS
3FA0  0E00     MOVLW 0x0
3FA2  6E10     MOVWF 0x10, ACCESS
3FA4  0E00     MOVLW 0x0
3FA6  6E11     MOVWF 0x11, ACCESS
3FA8  0E00     MOVLW 0x0
3FAA  6E12     MOVWF 0x12, ACCESS
38:            		}
39:            		// OR in the hidden 1-bit to b's fraction
40:            		B_FRACTION.i |= (int32_t) 1 << SPFRCB;
3FAC  8E11     BSF 0x11, 7, ACCESS
41:            		// and zero out the upper byte so we can safely shift
42:            		B_FRACTION.fAsBytes.d = 0;
3FAE  0E00     MOVLW 0x0
3FB0  6E12     MOVWF 0x12, ACCESS
43:            	}
3FB2  EFE3     GOTO 0x3FC6
3FB4  F01F     NOP
44:            	else {
45:            		/* Make it zero */
46:            		b = 0;
3FB6  0E00     MOVLW 0x0
3FB8  6E0F     MOVWF 0xF, ACCESS
3FBA  0E00     MOVLW 0x0
3FBC  6E10     MOVWF 0x10, ACCESS
3FBE  0E00     MOVLW 0x0
3FC0  6E11     MOVWF 0x11, ACCESS
3FC2  0E00     MOVLW 0x0
3FC4  6E12     MOVWF 0x12, ACCESS
47:            	}
48:            	// xor a's sign into the result sign
49:            	sign ^= A_FRACTION.fAsBytes.d & 0x80;
3FC6  5016     MOVF 0x16, W, ACCESS
3FC8  0B80     ANDLW 0x80
3FCA  1A1F     XORWF 0x1F, F, ACCESS
50:            	aexp = A_FRACTION.fAsBytes.d << 1;
3FCC  5016     MOVF 0x16, W, ACCESS
3FCE  2416     ADDWF 0x16, W, ACCESS
3FD0  6E27     MOVWF 0x27, ACCESS
51:            	if (A_FRACTION.fAsBytes.c & 0x80) {
3FD2  AE15     BTFSS 0x15, 7, ACCESS
3FD4  EFEE     GOTO 0x3FDC
3FD6  F01F     NOP
3FD8  EFF0     GOTO 0x3FE0
3FDA  F01F     NOP
3FDC  EFF1     GOTO 0x3FE2
3FDE  F01F     NOP
52:            		aexp |= 0x1;
3FE0  8027     BSF 0x27, 0, ACCESS
53:            	}
54:            
55:            	/* Destination normal ? */
56:            	if (aexp) {
3FE2  5027     MOVF 0x27, W, ACCESS
3FE4  B4D8     BTFSC 0xFD8, 2, ACCESS
3FE6  EFF7     GOTO 0x3FEE
3FE8  F01F     NOP
3FEA  EFF9     GOTO 0x3FF2
3FEC  F01F     NOP
3FEE  EF0E     GOTO 0x401C
3FF0  F020     NOP
57:            		/* Destination inf or NaN ? */
58:            		if (aexp == 0xFF) {
3FF2  2827     INCF 0x27, W, ACCESS
3FF4  A4D8     BTFSS 0xFD8, 2, ACCESS
3FF6  EFFF     GOTO 0x3FFE
3FF8  F01F     NOP
3FFA  EF01     GOTO 0x4002
3FFC  F020     NOP
3FFE  EF09     GOTO 0x4012
4000  F020     NOP
59:            			/* Make it inf */
60:            			a = 0;
4002  0E00     MOVLW 0x0
4004  6E13     MOVWF 0x13, ACCESS
4006  0E00     MOVLW 0x0
4008  6E14     MOVWF 0x14, ACCESS
400A  0E00     MOVLW 0x0
400C  6E15     MOVWF 0x15, ACCESS
400E  0E00     MOVLW 0x0
4010  6E16     MOVWF 0x16, ACCESS
61:            		}
62:            		// OR in the hidden 1-bit to a's fraction
63:            		A_FRACTION.i |= (int32_t) 1 << SPFRCB;
4012  8E15     BSF 0x15, 7, ACCESS
64:            		// and zero out the upper bits so we can safely shift
65:            		A_FRACTION.fAsBytes.d = 0;
4014  0E00     MOVLW 0x0
4016  6E16     MOVWF 0x16, ACCESS
66:            	}
4018  EF16     GOTO 0x402C
401A  F020     NOP
67:            	else {
68:            		/* Make it zero */
69:            		a = 0;
401C  0E00     MOVLW 0x0
401E  6E13     MOVWF 0x13, ACCESS
4020  0E00     MOVLW 0x0
4022  6E14     MOVWF 0x14, ACCESS
4024  0E00     MOVLW 0x0
4026  6E15     MOVWF 0x15, ACCESS
4028  0E00     MOVLW 0x0
402A  6E16     MOVWF 0x16, ACCESS
70:            	}
71:            
72:            	/* Special operand check */
73:            
74:            	/* Denominator zero ? Result infinity */
75:            	if (A_FRACTION.i == 0) {
402C  5013     MOVF 0x13, W, ACCESS
402E  1014     IORWF 0x14, W, ACCESS
4030  1015     IORWF 0x15, W, ACCESS
4032  1016     IORWF 0x16, W, ACCESS
4034  A4D8     BTFSS 0xFD8, 2, ACCESS
4036  EF1F     GOTO 0x403E
4038  F020     NOP
403A  EF21     GOTO 0x4042
403C  F020     NOP
403E  EF39     GOTO 0x4072
4040  F020     NOP
76:            		B_FRACTION.i = 0;
4042  0E00     MOVLW 0x0
4044  6E0F     MOVWF 0xF, ACCESS
4046  0E00     MOVLW 0x0
4048  6E10     MOVWF 0x10, ACCESS
404A  0E00     MOVLW 0x0
404C  6E11     MOVWF 0x11, ACCESS
404E  0E00     MOVLW 0x0
4050  6E12     MOVWF 0x12, ACCESS
77:            		B_FRACTION.fAsWords.wordB |= (SPEXPM << 7);
4052  0E80     MOVLW 0x80
4054  1211     IORWF 0x11, F, ACCESS
4056  0E7F     MOVLW 0x7F
4058  1212     IORWF 0x12, F, ACCESS
78:            		B_FRACTION.fAsBytes.d |= sign;
405A  501F     MOVF 0x1F, W, ACCESS
405C  1212     IORWF 0x12, F, ACCESS
79:            		return b;
405E  C50F     MOVFF bexp, bexp
4060  F50F     NOP
4062  C510     MOVFF c, c
4064  F510     NOP
4066  C511     MOVFF counter, counter
4068  F511     NOP
406A  C512     MOVFF sign, sign
406C  F512     NOP
406E  EF7C     GOTO 0x42F8
4070  F021     NOP
80:            	}
81:            
82:            	/* Numerator zero ? Result zero */
83:            	if (!bexp) {
4072  5026     MOVF 0x26, W, ACCESS
4074  A4D8     BTFSS 0xFD8, 2, ACCESS
4076  EF3F     GOTO 0x407E
4078  F020     NOP
407A  EF41     GOTO 0x4082
407C  F020     NOP
407E  EF4B     GOTO 0x4096
4080  F020     NOP
84:            		B_FRACTION.i = 0;
4082  0E00     MOVLW 0x0
4084  6E0F     MOVWF 0xF, ACCESS
4086  0E00     MOVLW 0x0
4088  6E10     MOVWF 0x10, ACCESS
408A  0E00     MOVLW 0x0
408C  6E11     MOVWF 0x11, ACCESS
408E  0E00     MOVLW 0x0
4090  6E12     MOVWF 0x12, ACCESS
4092  EF7C     GOTO 0x42F8
4094  F021     NOP
85:            		return b;
86:            	}
87:            
88:            	/* Subtract denominator exponent, minus bias */
89:            	new_exp = bexp - aexp + 127;
4096  5027     MOVF 0x27, W, ACCESS
4098  C526     MOVFF bexp, p
409A  F517     NOP
409C  6A18     CLRF 0x18, ACCESS
409E  5E17     SUBWF 0x17, F, ACCESS
40A0  0E00     MOVLW 0x0
40A2  5A18     SUBWFB 0x18, F, ACCESS
40A4  0E7F     MOVLW 0x7F
40A6  2417     ADDWF 0x17, W, ACCESS
40A8  6E20     MOVWF 0x20, ACCESS
40AA  0E00     MOVLW 0x0
40AC  2018     ADDWFC 0x18, W, ACCESS
40AE  6E21     MOVWF 0x21, ACCESS
90:            
91:            	/* Divide loop */
92:            	rem = B_FRACTION.i;
40B0  C50F     MOVFF bexp, rem
40B2  F51B     NOP
40B4  C510     MOVFF c, grs
40B6  F51C     NOP
40B8  C511     MOVFF counter, 0x51D
40BA  F51D     NOP
40BC  C512     MOVFF sign, fp
40BE  F51E     NOP
93:            	B_FRACTION.i = 0;
40C0  0E00     MOVLW 0x0
40C2  6E0F     MOVWF 0xF, ACCESS
40C4  0E00     MOVLW 0x0
40C6  6E10     MOVWF 0x10, ACCESS
40C8  0E00     MOVLW 0x0
40CA  6E11     MOVWF 0x11, ACCESS
40CC  0E00     MOVLW 0x0
40CE  6E12     MOVWF 0x12, ACCESS
94:            	grs = 0;
40D0  0E00     MOVLW 0x0
40D2  6E22     MOVWF 0x22, ACCESS
40D4  0E00     MOVLW 0x0
40D6  6E23     MOVWF 0x23, ACCESS
40D8  0E00     MOVLW 0x0
40DA  6E24     MOVWF 0x24, ACCESS
40DC  0E00     MOVLW 0x0
40DE  6E25     MOVWF 0x25, ACCESS
95:            	// reuse aexp as the loop counter ...
96:            	aexp = 0;
40E0  0E00     MOVLW 0x0
40E2  6E27     MOVWF 0x27, ACCESS
97:            	while (aexp < 26) {
40E4  EFAC     GOTO 0x4158
40E6  F020     NOP
4158  0E19     MOVLW 0x19
415A  6427     CPFSGT 0x27, ACCESS
415C  EFB2     GOTO 0x4164
415E  F020     NOP
4160  EFB4     GOTO 0x4168
4162  F020     NOP
4164  EF74     GOTO 0x40E8
4166  F020     NOP
98:            
99:            		/* Shift remainder, quotient left */
100:           		if (aexp) {
40E8  5027     MOVF 0x27, W, ACCESS
40EA  B4D8     BTFSC 0xFD8, 2, ACCESS
40EC  EF7A     GOTO 0x40F4
40EE  F020     NOP
40F0  EF7C     GOTO 0x40F8
40F2  F020     NOP
40F4  EF93     GOTO 0x4126
40F6  F020     NOP
101:           			rem <<= 1;
40F8  90D8     BCF 0xFD8, 0, ACCESS
40FA  361B     RLCF 0x1B, F, ACCESS
40FC  361C     RLCF 0x1C, F, ACCESS
40FE  361D     RLCF 0x1D, F, ACCESS
4100  361E     RLCF 0x1E, F, ACCESS
102:           			B_FRACTION.i <<= 1;
4102  90D8     BCF 0xFD8, 0, ACCESS
4104  360F     RLCF 0xF, F, ACCESS
4106  3610     RLCF 0x10, F, ACCESS
4108  3611     RLCF 0x11, F, ACCESS
410A  3612     RLCF 0x12, F, ACCESS
103:           			if (grs & 0x80000000) {
410C  AE25     BTFSS 0x25, 7, ACCESS
410E  EF8B     GOTO 0x4116
4110  F020     NOP
4112  EF8D     GOTO 0x411A
4114  F020     NOP
4116  EF8E     GOTO 0x411C
4118  F020     NOP
104:           				B_FRACTION.i |= 0x1;
411A  800F     BSF 0xF, 0, ACCESS
105:           			}
411C  90D8     BCF 0xFD8, 0, ACCESS
411E  3622     RLCF 0x22, F, ACCESS
4120  3623     RLCF 0x23, F, ACCESS
4122  3624     RLCF 0x24, F, ACCESS
4124  3625     RLCF 0x25, F, ACCESS
106:           			grs <<= 1;
107:           		}
108:           
109:           		/* Restoring divide */
110:           
111:           		/* Remainder not less than divisor ? */
112:           		if (!(rem < A_FRACTION.i)) {
4126  5013     MOVF 0x13, W, ACCESS
4128  5C1B     SUBWF 0x1B, W, ACCESS
412A  5014     MOVF 0x14, W, ACCESS
412C  581C     SUBWFB 0x1C, W, ACCESS
412E  5015     MOVF 0x15, W, ACCESS
4130  581D     SUBWFB 0x1D, W, ACCESS
4132  5016     MOVF 0x16, W, ACCESS
4134  581E     SUBWFB 0x1E, W, ACCESS
4136  A0D8     BTFSS 0xFD8, 0, ACCESS
4138  EFA0     GOTO 0x4140
413A  F020     NOP
413C  EFA2     GOTO 0x4144
413E  F020     NOP
4140  EFAB     GOTO 0x4156
4142  F020     NOP
113:           
114:           			/* Set quotient bit, subtract divisor */
115:           			grs |= 0x40000000;
4144  8C25     BSF 0x25, 6, ACCESS
116:           			rem -= A_FRACTION.i;
4146  5013     MOVF 0x13, W, ACCESS
4148  5E1B     SUBWF 0x1B, F, ACCESS
414A  5014     MOVF 0x14, W, ACCESS
414C  5A1C     SUBWFB 0x1C, F, ACCESS
414E  5015     MOVF 0x15, W, ACCESS
4150  5A1D     SUBWFB 0x1D, F, ACCESS
4152  5016     MOVF 0x16, W, ACCESS
4154  5A1E     SUBWFB 0x1E, F, ACCESS
117:           		}
118:           		++aexp;
4156  2A27     INCF 0x27, F, ACCESS
119:           	}
120:           
121:           	/* Sticky bit is nonzero remainder */
122:           	if (rem) {
4168  501B     MOVF 0x1B, W, ACCESS
416A  101C     IORWF 0x1C, W, ACCESS
416C  101D     IORWF 0x1D, W, ACCESS
416E  101E     IORWF 0x1E, W, ACCESS
4170  B4D8     BTFSC 0xFD8, 2, ACCESS
4172  EFBD     GOTO 0x417A
4174  F020     NOP
4176  EFBF     GOTO 0x417E
4178  F020     NOP
417A  EFD7     GOTO 0x41AE
417C  F020     NOP
123:           		grs |= 1;
417E  8022     BSF 0x22, 0, ACCESS
4180  EFD7     GOTO 0x41AE
4182  F020     NOP
124:           	}
125:           
126:           	/* Renormalize */
127:           	while (!(B_FRACTION.i & ((int32_t) 1 << SPFRCB))) {
41AE  AE11     BTFSS 0x11, 7, ACCESS
41B0  EFDC     GOTO 0x41B8
41B2  F020     NOP
41B4  EFDE     GOTO 0x41BC
41B6  F020     NOP
41B8  EFC2     GOTO 0x4184
41BA  F020     NOP
128:           		B_FRACTION.i <<= 1;
4184  90D8     BCF 0xFD8, 0, ACCESS
4186  360F     RLCF 0xF, F, ACCESS
4188  3610     RLCF 0x10, F, ACCESS
418A  3611     RLCF 0x11, F, ACCESS
418C  3612     RLCF 0x12, F, ACCESS
129:           		if (grs & 0x80000000) {
418E  AE25     BTFSS 0x25, 7, ACCESS
4190  EFCC     GOTO 0x4198
4192  F020     NOP
4194  EFCE     GOTO 0x419C
4196  F020     NOP
4198  EFCF     GOTO 0x419E
419A  F020     NOP
130:           			B_FRACTION.i |= 0x1;
419C  800F     BSF 0xF, 0, ACCESS
131:           		}
419E  90D8     BCF 0xFD8, 0, ACCESS
41A0  3622     RLCF 0x22, F, ACCESS
41A2  3623     RLCF 0x23, F, ACCESS
41A4  3624     RLCF 0x24, F, ACCESS
41A6  3625     RLCF 0x25, F, ACCESS
132:           		grs <<= 1;
133:           		--new_exp;
41A8  0620     DECF 0x20, F, ACCESS
41AA  A0D8     BTFSS 0xFD8, 0, ACCESS
41AC  0621     DECF 0x21, F, ACCESS
134:           	}
135:           
136:           	/* Round result and check overflow, underflow */
137:           	/* Round */
138:           	// reuse aexp again as the round-up flag ...
139:           	aexp = 0;
41BC  0E00     MOVLW 0x0
41BE  6E27     MOVWF 0x27, ACCESS
140:           	if (grs & ((uint32_t) 1 << 31)) {
41C0  AE25     BTFSS 0x25, 7, ACCESS
41C2  EFE5     GOTO 0x41CA
41C4  F020     NOP
41C6  EFE7     GOTO 0x41CE
41C8  F020     NOP
41CA  EF0B     GOTO 0x4216
41CC  F021     NOP
141:           		if (grs & (((uint32_t) 1 << 31) - 1)) {
41CE  0EFF     MOVLW 0xFF
41D0  1422     ANDWF 0x22, W, ACCESS
41D2  6E17     MOVWF 0x17, ACCESS
41D4  0EFF     MOVLW 0xFF
41D6  1423     ANDWF 0x23, W, ACCESS
41D8  6E18     MOVWF 0x18, ACCESS
41DA  0EFF     MOVLW 0xFF
41DC  1424     ANDWF 0x24, W, ACCESS
41DE  6E19     MOVWF 0x19, ACCESS
41E0  0E7F     MOVLW 0x7F
41E2  1425     ANDWF 0x25, W, ACCESS
41E4  6E1A     MOVWF 0x1A, ACCESS
41E6  5017     MOVF 0x17, W, ACCESS
41E8  1018     IORWF 0x18, W, ACCESS
41EA  1019     IORWF 0x19, W, ACCESS
41EC  101A     IORWF 0x1A, W, ACCESS
41EE  B4D8     BTFSC 0xFD8, 2, ACCESS
41F0  EFFC     GOTO 0x41F8
41F2  F020     NOP
41F4  EFFE     GOTO 0x41FC
41F6  F020     NOP
41F8  EF02     GOTO 0x4204
41FA  F021     NOP
142:           			aexp = 1;
41FC  0E01     MOVLW 0x1
41FE  6E27     MOVWF 0x27, ACCESS
143:           		}
4200  EF0B     GOTO 0x4216
4202  F021     NOP
144:           		else {
4204  A00F     BTFSS 0xF, 0, ACCESS
4206  EF07     GOTO 0x420E
4208  F021     NOP
420A  EF09     GOTO 0x4212
420C  F021     NOP
420E  EF0B     GOTO 0x4216
4210  F021     NOP
4212  EFFE     GOTO 0x41FC
4214  F020     NOP
145:           			if (B_FRACTION.i & 1) {
146:           				aexp = 1;
147:           			}
148:           		}
149:           	}
4216  5027     MOVF 0x27, W, ACCESS
4218  B4D8     BTFSC 0xFD8, 2, ACCESS
421A  EF11     GOTO 0x4222
421C  F021     NOP
421E  EF13     GOTO 0x4226
4220  F021     NOP
4222  EF37     GOTO 0x426E
4224  F021     NOP
150:           	if (aexp) {
151:           		++B_FRACTION.i;
4226  0E01     MOVLW 0x1
4228  260F     ADDWF 0xF, F, ACCESS
422A  0E00     MOVLW 0x0
422C  2210     ADDWFC 0x10, F, ACCESS
422E  2211     ADDWFC 0x11, F, ACCESS
4230  2212     ADDWFC 0x12, F, ACCESS
152:           		if (B_FRACTION.i & ((int32_t) 1 << (SPFRCB + 1))) {
4232  A012     BTFSS 0x12, 0, ACCESS
4234  EF1E     GOTO 0x423C
4236  F021     NOP
4238  EF20     GOTO 0x4240
423A  F021     NOP
423C  EF37     GOTO 0x426E
423E  F021     NOP
153:           			B_FRACTION.i = B_FRACTION.i >> 1;
4240  C50F     MOVFF bexp, p
4242  F517     NOP
4244  C510     MOVFF c, 0x518
4246  F518     NOP
4248  C511     MOVFF counter, 0x519
424A  F519     NOP
424C  C512     MOVFF sign, i
424E  F51A     NOP
4250  341A     RLCF 0x1A, W, ACCESS
4252  321A     RRCF 0x1A, F, ACCESS
4254  3219     RRCF 0x19, F, ACCESS
4256  3218     RRCF 0x18, F, ACCESS
4258  3217     RRCF 0x17, F, ACCESS
425A  C517     MOVFF p, bexp
425C  F50F     NOP
425E  C518     MOVFF 0x518, c
4260  F510     NOP
4262  C519     MOVFF 0x519, counter
4264  F511     NOP
4266  C51A     MOVFF i, sign
4268  F512     NOP
154:           			++new_exp;
426A  4A20     INFSNZ 0x20, F, ACCESS
426C  2A21     INCF 0x21, F, ACCESS
155:           		}
156:           	}
157:           
158:           	/* Overflow ? Return infinity */
159:           	if (!(new_exp < SPEXPM)) {
426E  BE21     BTFSC 0x21, 7, ACCESS
4270  EF42     GOTO 0x4284
4272  F021     NOP
4274  5021     MOVF 0x21, W, ACCESS
4276  E108     BNZ 0x4288
4278  2820     INCF 0x20, W, ACCESS
427A  A0D8     BTFSS 0xFD8, 0, ACCESS
427C  EF42     GOTO 0x4284
427E  F021     NOP
4280  EF44     GOTO 0x4288
4282  F021     NOP
4284  EF4F     GOTO 0x429E
4286  F021     NOP
160:           		new_exp = SPEXPM;
4288  0E00     MOVLW 0x0
428A  6E21     MOVWF 0x21, ACCESS
428C  6820     SETF 0x20, ACCESS
161:           		B_FRACTION.i = 0;
428E  0E00     MOVLW 0x0
4290  6E0F     MOVWF 0xF, ACCESS
4292  0E00     MOVLW 0x0
4294  6E10     MOVWF 0x10, ACCESS
4296  0E00     MOVLW 0x0
4298  6E11     MOVWF 0x11, ACCESS
429A  0E00     MOVLW 0x0
429C  6E12     MOVWF 0x12, ACCESS
162:           	}
163:           
164:           	/* Underflow ? Flush to zero */
165:           	if (!(0 < new_exp)) {
429E  BE21     BTFSC 0x21, 7, ACCESS
42A0  EF5C     GOTO 0x42B8
42A2  F021     NOP
42A4  5021     MOVF 0x21, W, ACCESS
42A6  E106     BNZ 0x42B4
42A8  0420     DECF 0x20, W, ACCESS
42AA  B0D8     BTFSC 0xFD8, 0, ACCESS
42AC  EF5A     GOTO 0x42B4
42AE  F021     NOP
42B0  EF5C     GOTO 0x42B8
42B2  F021     NOP
42B4  EF6A     GOTO 0x42D4
42B6  F021     NOP
166:           		new_exp = 0;
42B8  0E00     MOVLW 0x0
42BA  6E21     MOVWF 0x21, ACCESS
42BC  0E00     MOVLW 0x0
42BE  6E20     MOVWF 0x20, ACCESS
167:           		B_FRACTION.i = 0;
42C0  0E00     MOVLW 0x0
42C2  6E0F     MOVWF 0xF, ACCESS
42C4  0E00     MOVLW 0x0
42C6  6E10     MOVWF 0x10, ACCESS
42C8  0E00     MOVLW 0x0
42CA  6E11     MOVWF 0x11, ACCESS
42CC  0E00     MOVLW 0x0
42CE  6E12     MOVWF 0x12, ACCESS
168:                           // no negative fp 0 for now
169:                           sign = 0;
42D0  0E00     MOVLW 0x0
42D2  6E1F     MOVWF 0x1F, ACCESS
170:           	}
171:           
172:           	/* Pack and return result */
173:           	bexp = new_exp;
42D4  C520     MOVFF new_exp, bexp
42D6  F526     NOP
174:           	// set the low bit of the exponent ...
175:           	if (bexp & 0x1) {
42D8  A026     BTFSS 0x26, 0, ACCESS
42DA  EF71     GOTO 0x42E2
42DC  F021     NOP
42DE  EF73     GOTO 0x42E6
42E0  F021     NOP
42E2  EF76     GOTO 0x42EC
42E4  F021     NOP
176:           		B_FRACTION.fAsBytes.c |= 0x80;
42E6  8E11     BSF 0x11, 7, ACCESS
177:           	}
42E8  EF77     GOTO 0x42EE
42EA  F021     NOP
178:           	// AND out the leading 1
179:           	else {
180:           		B_FRACTION.fAsBytes.c &= 0x7F;
42EC  9E11     BCF 0x11, 7, ACCESS
181:           	}
182:           	B_FRACTION.fAsBytes.d = bexp >> 1;
42EE  90D8     BCF 0xFD8, 0, ACCESS
42F0  3026     RRCF 0x26, W, ACCESS
42F2  6E12     MOVWF 0x12, ACCESS
42F4  EF2D     GOTO 0x405A
42F6  F020     NOP
183:           	B_FRACTION.fAsBytes.d |= sign;
184:           	return b;
185:           }
42F8  0012     RETURN 0
186:           
---  C:/Program Files/Microchip/xc8/v2.20/pic/sources/c99/common/sprcadd.c  -----------------------------
1:             /* SP relaxed compliance floating point add intrinsic function */
2:             #include <stdint.h>
3:             #include "fpform.h"
4:             
5:             
6:             // single monlithic add function
7:             
8:             /* SP Add */
9:             SP
10:            SPADD(SP b, SP a) {
3652  5004     MOVF 0x4, W, ACCESS
3654  0B80     ANDLW 0x80
3656  6E0D     MOVWF 0xD, ACCESS
11:            #define A_FRACTION    (*(SFP *)&a)
12:            #define B_FRACTION    (*(SFP *)&b)
13:            	unsigned char signs;	/* leftmost bit stores sign of b, next bit stores
14:            				   0 if and only if a and b have the same sign  */
15:            	unsigned char bexp;	/* Dst exponent */
16:            	unsigned char aexp;	/* Src exponent */
17:            	unsigned char grs;	/* Guard, round, sticky */
18:            
19:            
20:            	/* Unpack and check operands */
21:            	signs = B_FRACTION.fAsBytes.d & 0x80;
22:            	bexp = B_FRACTION.fAsBytes.d << 1;
3658  5004     MOVF 0x4, W, ACCESS
365A  2404     ADDWF 0x4, W, ACCESS
365C  6E0F     MOVWF 0xF, ACCESS
23:            	if (B_FRACTION.fAsBytes.c & 0x80) {
365E  AE03     BTFSS 0x3, 7, ACCESS
3660  EF34     GOTO 0x3668
3662  F01B     NOP
3664  EF36     GOTO 0x366C
3666  F01B     NOP
3668  EF37     GOTO 0x366E
366A  F01B     NOP
24:            		bexp |= 0x1;
366C  800F     BSF 0xF, 0, ACCESS
25:            	}
26:            
27:            	/* Destination normal ? */
28:            	if (bexp) {
366E  500F     MOVF 0xF, W, ACCESS
3670  B4D8     BTFSC 0xFD8, 2, ACCESS
3672  EF3D     GOTO 0x367A
3674  F01B     NOP
3676  EF3F     GOTO 0x367E
3678  F01B     NOP
367A  EF54     GOTO 0x36A8
367C  F01B     NOP
29:            		/* Destination inf or NaN ? */
30:            		if (bexp == 0xFF) {
367E  280F     INCF 0xF, W, ACCESS
3680  A4D8     BTFSS 0xFD8, 2, ACCESS
3682  EF45     GOTO 0x368A
3684  F01B     NOP
3686  EF47     GOTO 0x368E
3688  F01B     NOP
368A  EF4F     GOTO 0x369E
368C  F01B     NOP
31:            			/* Make it inf */
32:            			b = 0;
368E  0E00     MOVLW 0x0
3690  6E01     MOVWF 0x1, ACCESS
3692  0E00     MOVLW 0x0
3694  6E02     MOVWF 0x2, ACCESS
3696  0E00     MOVLW 0x0
3698  6E03     MOVWF 0x3, ACCESS
369A  0E00     MOVLW 0x0
369C  6E04     MOVWF 0x4, ACCESS
33:            		}
34:            		// OR in the hidden 1-bit to b's fraction
35:            		B_FRACTION.i |= (int32_t) 1 << SPFRCB;
369E  8E03     BSF 0x3, 7, ACCESS
36:            		// and zero out the upper byte so we can safely shift
37:            		B_FRACTION.fAsBytes.d = 0;
36A0  0E00     MOVLW 0x0
36A2  6E04     MOVWF 0x4, ACCESS
38:            	}
36A4  EF5C     GOTO 0x36B8
36A6  F01B     NOP
39:            	else {
40:            		/* Make it zero */
41:            		b = 0;
36A8  0E00     MOVLW 0x0
36AA  6E01     MOVWF 0x1, ACCESS
36AC  0E00     MOVLW 0x0
36AE  6E02     MOVWF 0x2, ACCESS
36B0  0E00     MOVLW 0x0
36B2  6E03     MOVWF 0x3, ACCESS
36B4  0E00     MOVLW 0x0
36B6  6E04     MOVWF 0x4, ACCESS
42:            	}
43:            
44:            	aexp = A_FRACTION.fAsBytes.d & 0x80;
36B8  5008     MOVF 0x8, W, ACCESS
36BA  0B80     ANDLW 0x80
36BC  6E0E     MOVWF 0xE, ACCESS
45:            	// sign of a different from sign of b?
46:            	if (aexp != signs) {
36BE  500D     MOVF 0xD, W, ACCESS
36C0  180E     XORWF 0xE, W, ACCESS
36C2  B4D8     BTFSC 0xFD8, 2, ACCESS
36C4  EF66     GOTO 0x36CC
36C6  F01B     NOP
36C8  EF68     GOTO 0x36D0
36CA  F01B     NOP
36CC  EF69     GOTO 0x36D2
36CE  F01B     NOP
47:            		signs |= 0x40;
36D0  8C0D     BSF 0xD, 6, ACCESS
48:            	}
49:            	aexp = A_FRACTION.fAsBytes.d << 1;
36D2  5008     MOVF 0x8, W, ACCESS
36D4  2408     ADDWF 0x8, W, ACCESS
36D6  6E0E     MOVWF 0xE, ACCESS
50:            	if (A_FRACTION.fAsBytes.c & 0x80) {
36D8  AE07     BTFSS 0x7, 7, ACCESS
36DA  EF71     GOTO 0x36E2
36DC  F01B     NOP
36DE  EF73     GOTO 0x36E6
36E0  F01B     NOP
36E2  EF74     GOTO 0x36E8
36E4  F01B     NOP
51:            		aexp |= 0x1;
36E6  800E     BSF 0xE, 0, ACCESS
52:            	}
53:            
54:            	/* Destination normal ? */
55:            	if (aexp) {
36E8  500E     MOVF 0xE, W, ACCESS
36EA  B4D8     BTFSC 0xFD8, 2, ACCESS
36EC  EF7A     GOTO 0x36F4
36EE  F01B     NOP
36F0  EF7C     GOTO 0x36F8
36F2  F01B     NOP
36F4  EF91     GOTO 0x3722
36F6  F01B     NOP
56:            		/* Destination inf or NaN ? */
57:            		if (aexp == 0xFF) {
36F8  280E     INCF 0xE, W, ACCESS
36FA  A4D8     BTFSS 0xFD8, 2, ACCESS
36FC  EF82     GOTO 0x3704
36FE  F01B     NOP
3700  EF84     GOTO 0x3708
3702  F01B     NOP
3704  EF8C     GOTO 0x3718
3706  F01B     NOP
58:            			/* Make it inf */
59:            			a = 0;
3708  0E00     MOVLW 0x0
370A  6E05     MOVWF 0x5, ACCESS
370C  0E00     MOVLW 0x0
370E  6E06     MOVWF 0x6, ACCESS
3710  0E00     MOVLW 0x0
3712  6E07     MOVWF 0x7, ACCESS
3714  0E00     MOVLW 0x0
3716  6E08     MOVWF 0x8, ACCESS
60:            		}
61:            		// OR in the hidden 1-bit to a's fraction
62:            		A_FRACTION.i |= (int32_t) 1 << SPFRCB;
3718  8E07     BSF 0x7, 7, ACCESS
63:            		// and zero out the upper bits so we can safely shift
64:            		A_FRACTION.fAsBytes.d = 0;
371A  0E00     MOVLW 0x0
371C  6E08     MOVWF 0x8, ACCESS
65:            	}
371E  EF99     GOTO 0x3732
3720  F01B     NOP
66:            	else {
67:            		/* Make it zero */
68:            		a = 0;
3722  0E00     MOVLW 0x0
3724  6E05     MOVWF 0x5, ACCESS
3726  0E00     MOVLW 0x0
3728  6E06     MOVWF 0x6, ACCESS
372A  0E00     MOVLW 0x0
372C  6E07     MOVWF 0x7, ACCESS
372E  0E00     MOVLW 0x0
3730  6E08     MOVWF 0x8, ACCESS
69:            	}
70:            
71:            	/* Add */
72:            
73:            	/* Get smaller operand in b */
74:            
75:            	if (aexp < bexp) {
3732  500F     MOVF 0xF, W, ACCESS
3734  5C0E     SUBWF 0xE, W, ACCESS
3736  B0D8     BTFSC 0xFD8, 0, ACCESS
3738  EFA0     GOTO 0x3740
373A  F01B     NOP
373C  EFA2     GOTO 0x3744
373E  F01B     NOP
3740  EFC9     GOTO 0x3792
3742  F01B     NOP
76:            		// do I need to reverse the sign?
77:            		if (signs & 0x40) {
3744  AC0D     BTFSS 0xD, 6, ACCESS
3746  EFA7     GOTO 0x374E
3748  F01B     NOP
374A  EFA9     GOTO 0x3752
374C  F01B     NOP
374E  EFAB     GOTO 0x3756
3750  F01B     NOP
78:            			signs ^= 0x80;
3752  0E80     MOVLW 0x80
3754  1A0D     XORWF 0xD, F, ACCESS
79:            		}
80:            		// use  grs as swap space
81:            		grs = bexp;
3756  C50F     MOVFF bexp, c
3758  F510     NOP
82:            		bexp = aexp;
375A  C50E     MOVFF fp, bexp
375C  F50F     NOP
83:            		aexp = grs;
375E  C510     MOVFF c, fp
3760  F50E     NOP
84:            		grs = B_FRACTION.fAsBytes.a;
3762  C501     MOVFF __pcstackCOMRAM, c
3764  F510     NOP
85:            		B_FRACTION.fAsBytes.a = A_FRACTION.fAsBytes.a;
3766  C505     MOVFF n, __pcstackCOMRAM
3768  F501     NOP
86:            		A_FRACTION.fAsBytes.a = grs;
376A  C510     MOVFF c, n
376C  F505     NOP
87:            		grs = B_FRACTION.fAsBytes.b;
376E  C502     MOVFF txData, c
3770  F510     NOP
88:            		B_FRACTION.fAsBytes.b = A_FRACTION.fAsBytes.b;
3772  C506     MOVFF sign, txData
3774  F502     NOP
89:            		A_FRACTION.fAsBytes.b = grs;
3776  C510     MOVFF c, sign
3778  F506     NOP
90:            		grs = B_FRACTION.fAsBytes.c;
377A  C503     MOVFF _r, c
377C  F510     NOP
91:            		B_FRACTION.fAsBytes.c = A_FRACTION.fAsBytes.c;
377E  C507     MOVFF s, _r
3780  F503     NOP
92:            		A_FRACTION.fAsBytes.c = grs;
3782  C510     MOVFF c, s
3784  F507     NOP
93:            		grs = B_FRACTION.fAsBytes.d;
3786  C504     MOVFF 0x504, c
3788  F510     NOP
94:            		B_FRACTION.fAsBytes.d = A_FRACTION.fAsBytes.d;
378A  C508     MOVFF l, 0x504
378C  F504     NOP
95:            		A_FRACTION.fAsBytes.d = grs;
378E  C510     MOVFF c, l
3790  F508     NOP
96:            	}
97:            
98:            	grs = 0;
3792  0E00     MOVLW 0x0
3794  6E10     MOVWF 0x10, ACCESS
99:            	/* If all ones will shift through G,R, then S = significand nonzero */
100:           	if ((aexp - bexp) > (SPFRCB + 2)) {
3796  500F     MOVF 0xF, W, ACCESS
3798  C50E     MOVFF fp, d
379A  F509     NOP
379C  6A0A     CLRF 0xA, ACCESS
379E  5E09     SUBWF 0x9, F, ACCESS
37A0  0E00     MOVLW 0x0
37A2  5A0A     SUBWFB 0xA, F, ACCESS
37A4  BE0A     BTFSC 0xA, 7, ACCESS
37A6  EFDE     GOTO 0x37BC
37A8  F01B     NOP
37AA  500A     MOVF 0xA, W, ACCESS
37AC  E109     BNZ 0x37C0
37AE  0E1A     MOVLW 0x1A
37B0  5C09     SUBWF 0x9, W, ACCESS
37B2  A0D8     BTFSS 0xFD8, 0, ACCESS
37B4  EFDE     GOTO 0x37BC
37B6  F01B     NOP
37B8  EFE0     GOTO 0x37C0
37BA  F01B     NOP
37BC  EF17     GOTO 0x382E
37BE  F01C     NOP
101:           		grs = B_FRACTION.i ? 1 : 0;
37C0  5001     MOVF 0x1, W, ACCESS
37C2  1002     IORWF 0x2, W, ACCESS
37C4  1003     IORWF 0x3, W, ACCESS
37C6  1004     IORWF 0x4, W, ACCESS
37C8  A4D8     BTFSS 0xFD8, 2, ACCESS
37CA  EFE9     GOTO 0x37D2
37CC  F01B     NOP
37CE  EFEC     GOTO 0x37D8
37D0  F01B     NOP
37D2  0E01     MOVLW 0x1
37D4  EFED     GOTO 0x37DA
37D6  F01B     NOP
37D8  0E00     MOVLW 0x0
37DA  6E10     MOVWF 0x10, ACCESS
102:           		B_FRACTION.i = 0;
37DC  0E00     MOVLW 0x0
37DE  6E01     MOVWF 0x1, ACCESS
37E0  0E00     MOVLW 0x0
37E2  6E02     MOVWF 0x2, ACCESS
37E4  0E00     MOVLW 0x0
37E6  6E03     MOVWF 0x3, ACCESS
37E8  0E00     MOVLW 0x0
37EA  6E04     MOVWF 0x4, ACCESS
103:           		bexp = aexp;
37EC  C50E     MOVFF fp, bexp
37EE  F50F     NOP
104:           	}
37F0  EF20     GOTO 0x3840
37F2  F01C     NOP
105:           	else {
106:           		while (bexp < aexp) {
37F4  A010     BTFSS 0x10, 0, ACCESS
37F6  EFFF     GOTO 0x37FE
37F8  F01B     NOP
37FA  EF01     GOTO 0x3802
37FC  F01C     NOP
37FE  EF07     GOTO 0x380E
3800  F01C     NOP
382E  500E     MOVF 0xE, W, ACCESS
3830  5C0F     SUBWF 0xF, W, ACCESS
3832  A0D8     BTFSS 0xFD8, 0, ACCESS
3834  EF1E     GOTO 0x383C
3836  F01C     NOP
3838  EF20     GOTO 0x3840
383A  F01C     NOP
383C  EFFA     GOTO 0x37F4
383E  F01B     NOP
107:           			/* Shift smaller operand right until exponents equal */
108:           			/* save the bits shifted out in grs    */
109:           			if (grs & 1) {
110:           				grs = (grs >> 1) | 0x1;
3802  90D8     BCF 0xFD8, 0, ACCESS
3804  3010     RRCF 0x10, W, ACCESS
3806  0901     IORLW 0x1
3808  6E10     MOVWF 0x10, ACCESS
111:           			}
380A  EF09     GOTO 0x3812
380C  F01C     NOP
112:           			else {
113:           				grs >>= 1;
380E  90D8     BCF 0xFD8, 0, ACCESS
3810  3210     RRCF 0x10, F, ACCESS
114:           			}
115:           			if (B_FRACTION.i & 0x1) {
3812  A001     BTFSS 0x1, 0, ACCESS
3814  EF0E     GOTO 0x381C
3816  F01C     NOP
3818  EF10     GOTO 0x3820
381A  F01C     NOP
381C  EF11     GOTO 0x3822
381E  F01C     NOP
116:           				grs |= 0x80;
3820  8E10     BSF 0x10, 7, ACCESS
117:           			}
118:           			B_FRACTION.i >>= 1;
3822  3404     RLCF 0x4, W, ACCESS
3824  3204     RRCF 0x4, F, ACCESS
3826  3203     RRCF 0x3, F, ACCESS
3828  3202     RRCF 0x2, F, ACCESS
382A  3201     RRCF 0x1, F, ACCESS
119:           			bexp++;
382C  2A0F     INCF 0xF, F, ACCESS
120:           		}
121:           	}
3840  BC0D     BTFSC 0xD, 6, ACCESS
3842  EF25     GOTO 0x384A
3844  F01C     NOP
3846  EF27     GOTO 0x384E
3848  F01C     NOP
384A  EF67     GOTO 0x38CE
384C  F01C     NOP
122:           
123:           	/* Add or subtract magnitude ? */
124:           	if (!(signs & 0x40)) {
125:           
126:           		/* Quick exit for 0 + 0, same sign */
127:           		if (!bexp) {
384E  500F     MOVF 0xF, W, ACCESS
3850  A4D8     BTFSS 0xFD8, 2, ACCESS
3852  EF2D     GOTO 0x385A
3854  F01C     NOP
3856  EF2F     GOTO 0x385E
3858  F01C     NOP
385A  EF39     GOTO 0x3872
385C  F01C     NOP
128:           			return 0.0;
385E  0E00     MOVLW 0x0
3860  6E01     MOVWF 0x1, ACCESS
3862  0E00     MOVLW 0x0
3864  6E02     MOVWF 0x2, ACCESS
3866  0E00     MOVLW 0x0
3868  6E03     MOVWF 0x3, ACCESS
386A  0E00     MOVLW 0x0
386C  6E04     MOVWF 0x4, ACCESS
386E  EF88     GOTO 0x3B10
3870  F01D     NOP
129:           		}
130:           
131:           		/* Add magnitude */
132:           		B_FRACTION.i += A_FRACTION.i;
3872  5005     MOVF 0x5, W, ACCESS
3874  2601     ADDWF 0x1, F, ACCESS
3876  5006     MOVF 0x6, W, ACCESS
3878  2202     ADDWFC 0x2, F, ACCESS
387A  5007     MOVF 0x7, W, ACCESS
387C  2203     ADDWFC 0x3, F, ACCESS
387E  5008     MOVF 0x8, W, ACCESS
3880  2204     ADDWFC 0x4, F, ACCESS
133:           		// did it overflow?
134:           		if (B_FRACTION.i & ((int32_t) 1 << (SPFRCB + 1))) {
3882  A004     BTFSS 0x4, 0, ACCESS
3884  EF46     GOTO 0x388C
3886  F01C     NOP
3888  EF48     GOTO 0x3890
388A  F01C     NOP
388C  EFF4     GOTO 0x39E8
388E  F01C     NOP
135:           			if (grs & 1) {
3890  A010     BTFSS 0x10, 0, ACCESS
3892  EF4D     GOTO 0x389A
3894  F01C     NOP
3896  EF4F     GOTO 0x389E
3898  F01C     NOP
389A  EF55     GOTO 0x38AA
389C  F01C     NOP
136:           				grs = (grs >> 1) | 0x1;
389E  90D8     BCF 0xFD8, 0, ACCESS
38A0  3010     RRCF 0x10, W, ACCESS
38A2  0901     IORLW 0x1
38A4  6E10     MOVWF 0x10, ACCESS
137:           			}
38A6  EF57     GOTO 0x38AE
38A8  F01C     NOP
138:           			else {
139:           				grs >>= 1;
38AA  90D8     BCF 0xFD8, 0, ACCESS
38AC  3210     RRCF 0x10, F, ACCESS
140:           			}
141:           			if (B_FRACTION.i & 1) {
38AE  A001     BTFSS 0x1, 0, ACCESS
38B0  EF5C     GOTO 0x38B8
38B2  F01C     NOP
38B4  EF5E     GOTO 0x38BC
38B6  F01C     NOP
38B8  EF5F     GOTO 0x38BE
38BA  F01C     NOP
142:           				grs |= 0x80;
38BC  8E10     BSF 0x10, 7, ACCESS
143:           			}
144:           			B_FRACTION.i >>= 1;
38BE  3404     RLCF 0x4, W, ACCESS
38C0  3204     RRCF 0x4, F, ACCESS
38C2  3203     RRCF 0x3, F, ACCESS
38C4  3202     RRCF 0x2, F, ACCESS
38C6  3201     RRCF 0x1, F, ACCESS
145:           			++bexp;
38C8  2A0F     INCF 0xF, F, ACCESS
38CA  EFF4     GOTO 0x39E8
38CC  F01C     NOP
146:           		}
147:           
148:           	}
149:           	else {
150:           
151:           		/* Subtract magnitude */
152:           
153:           		if (B_FRACTION.i < A_FRACTION.i) {
38CE  5005     MOVF 0x5, W, ACCESS
38D0  5C01     SUBWF 0x1, W, ACCESS
38D2  5006     MOVF 0x6, W, ACCESS
38D4  5802     SUBWFB 0x2, W, ACCESS
38D6  5007     MOVF 0x7, W, ACCESS
38D8  5803     SUBWFB 0x3, W, ACCESS
38DA  5004     MOVF 0x4, W, ACCESS
38DC  0A80     XORLW 0x80
38DE  6E09     MOVWF 0x9, ACCESS
38E0  5008     MOVF 0x8, W, ACCESS
38E2  0A80     XORLW 0x80
38E4  5809     SUBWFB 0x9, W, ACCESS
38E6  B0D8     BTFSC 0xFD8, 0, ACCESS
38E8  EF78     GOTO 0x38F0
38EA  F01C     NOP
38EC  EF7A     GOTO 0x38F4
38EE  F01C     NOP
38F0  EFA5     GOTO 0x394A
38F2  F01C     NOP
154:           			B_FRACTION.i = A_FRACTION.i - B_FRACTION.i - 1;
38F4  5001     MOVF 0x1, W, ACCESS
38F6  5C05     SUBWF 0x5, W, ACCESS
38F8  6E09     MOVWF 0x9, ACCESS
38FA  5002     MOVF 0x2, W, ACCESS
38FC  5806     SUBWFB 0x6, W, ACCESS
38FE  6E0A     MOVWF 0xA, ACCESS
3900  5003     MOVF 0x3, W, ACCESS
3902  5807     SUBWFB 0x7, W, ACCESS
3904  6E0B     MOVWF 0xB, ACCESS
3906  5004     MOVF 0x4, W, ACCESS
3908  5808     SUBWFB 0x8, W, ACCESS
390A  6E0C     MOVWF 0xC, ACCESS
390C  0EFF     MOVLW 0xFF
390E  2409     ADDWF 0x9, W, ACCESS
3910  6E01     MOVWF 0x1, ACCESS
3912  0EFF     MOVLW 0xFF
3914  200A     ADDWFC 0xA, W, ACCESS
3916  6E02     MOVWF 0x2, ACCESS
3918  0EFF     MOVLW 0xFF
391A  200B     ADDWFC 0xB, W, ACCESS
391C  6E03     MOVWF 0x3, ACCESS
391E  0EFF     MOVLW 0xFF
3920  200C     ADDWFC 0xC, W, ACCESS
3922  6E04     MOVWF 0x4, ACCESS
155:           			signs ^= 0x80;
3924  0E80     MOVLW 0x80
3926  1A0D     XORWF 0xD, F, ACCESS
156:           			grs = ~grs + 1;
3928  6C10     NEGF 0x10, ACCESS
157:           			if (!grs) {
392A  5010     MOVF 0x10, W, ACCESS
392C  A4D8     BTFSS 0xFD8, 2, ACCESS
392E  EF9B     GOTO 0x3936
3930  F01C     NOP
3932  EF9D     GOTO 0x393A
3934  F01C     NOP
3936  EFAD     GOTO 0x395A
3938  F01C     NOP
158:           				++B_FRACTION.i;
393A  0E01     MOVLW 0x1
393C  2601     ADDWF 0x1, F, ACCESS
393E  0E00     MOVLW 0x0
3940  2202     ADDWFC 0x2, F, ACCESS
3942  2203     ADDWFC 0x3, F, ACCESS
3944  2204     ADDWFC 0x4, F, ACCESS
3946  EFAD     GOTO 0x395A
3948  F01C     NOP
159:           			}
160:           		}
161:           		else {
162:           			B_FRACTION.i -= A_FRACTION.i;
394A  5005     MOVF 0x5, W, ACCESS
394C  5E01     SUBWF 0x1, F, ACCESS
394E  5006     MOVF 0x6, W, ACCESS
3950  5A02     SUBWFB 0x2, F, ACCESS
3952  5007     MOVF 0x7, W, ACCESS
3954  5A03     SUBWFB 0x3, F, ACCESS
3956  5008     MOVF 0x8, W, ACCESS
3958  5A04     SUBWFB 0x4, F, ACCESS
163:           		}
395A  5001     MOVF 0x1, W, ACCESS
395C  1002     IORWF 0x2, W, ACCESS
395E  1003     IORWF 0x3, W, ACCESS
3960  1004     IORWF 0x4, W, ACCESS
3962  A4D8     BTFSS 0xFD8, 2, ACCESS
3964  EFB6     GOTO 0x396C
3966  F01C     NOP
3968  EFB8     GOTO 0x3970
396A  F01C     NOP
396C  EFED     GOTO 0x39DA
396E  F01C     NOP
3970  5010     MOVF 0x10, W, ACCESS
3972  A4D8     BTFSS 0xFD8, 2, ACCESS
3974  EFBE     GOTO 0x397C
3976  F01C     NOP
3978  EFC0     GOTO 0x3980
397A  F01C     NOP
397C  EFED     GOTO 0x39DA
397E  F01C     NOP
164:           
165:           		/* True zero ? */
166:           		if (!B_FRACTION.i && !grs) {
167:           			return 0.0;
3980  0E00     MOVLW 0x0
3982  6E01     MOVWF 0x1, ACCESS
3984  0E00     MOVLW 0x0
3986  6E02     MOVWF 0x2, ACCESS
3988  0E00     MOVLW 0x0
398A  6E03     MOVWF 0x3, ACCESS
398C  0E00     MOVLW 0x0
398E  6E04     MOVWF 0x4, ACCESS
3990  EF88     GOTO 0x3B10
3992  F01D     NOP
168:           		}
169:           
170:           		/* Renormalize */
171:           		while (!(B_FRACTION.i & ((int32_t) 1 << SPFRCB))) {
39DA  AE03     BTFSS 0x3, 7, ACCESS
39DC  EFF2     GOTO 0x39E4
39DE  F01C     NOP
39E0  EFF4     GOTO 0x39E8
39E2  F01C     NOP
39E4  EFCA     GOTO 0x3994
39E6  F01C     NOP
172:           			B_FRACTION.i <<= 1;
3994  90D8     BCF 0xFD8, 0, ACCESS
3996  3601     RLCF 0x1, F, ACCESS
3998  3602     RLCF 0x2, F, ACCESS
399A  3603     RLCF 0x3, F, ACCESS
399C  3604     RLCF 0x4, F, ACCESS
173:           			if (grs & 0x80) {
399E  AE10     BTFSS 0x10, 7, ACCESS
39A0  EFD4     GOTO 0x39A8
39A2  F01C     NOP
39A4  EFD6     GOTO 0x39AC
39A6  F01C     NOP
39A8  EFD7     GOTO 0x39AE
39AA  F01C     NOP
174:           				B_FRACTION.i |= 0x1;
39AC  8001     BSF 0x1, 0, ACCESS
175:           			}
176:           			if (grs & 1) {
39AE  A010     BTFSS 0x10, 0, ACCESS
39B0  EFDC     GOTO 0x39B8
39B2  F01C     NOP
39B4  EFDE     GOTO 0x39BC
39B6  F01C     NOP
39B8  EFE2     GOTO 0x39C4
39BA  F01C     NOP
177:           				grs = (grs << 1) | 0x1;
39BC  80D8     BSF 0xFD8, 0, ACCESS
39BE  3610     RLCF 0x10, F, ACCESS
178:           			}
39C0  EFE4     GOTO 0x39C8
39C2  F01C     NOP
179:           			else {
180:           				grs <<= 1;
39C4  90D8     BCF 0xFD8, 0, ACCESS
39C6  3610     RLCF 0x10, F, ACCESS
181:           			}
182:           			if (bexp) {
39C8  500F     MOVF 0xF, W, ACCESS
39CA  B4D8     BTFSC 0xFD8, 2, ACCESS
39CC  EFEA     GOTO 0x39D4
39CE  F01C     NOP
39D0  EFEC     GOTO 0x39D8
39D2  F01C     NOP
39D4  EFED     GOTO 0x39DA
39D6  F01C     NOP
183:           				--bexp;
39D8  060F     DECF 0xF, F, ACCESS
184:           			}
185:           		}
186:           	}
187:           
188:           	/* Round, check overflow, underflow */
189:           
190:           	/* Round */
191:           	// reuse aexp as the rounding flag ...
192:           	aexp = 0;
39E8  0E00     MOVLW 0x0
39EA  6E0E     MOVWF 0xE, ACCESS
193:           	if (grs & 0x80) {
39EC  AE10     BTFSS 0x10, 7, ACCESS
39EE  EFFB     GOTO 0x39F6
39F0  F01C     NOP
39F2  EFFD     GOTO 0x39FA
39F4  F01C     NOP
39F6  EF15     GOTO 0x3A2A
39F8  F01D     NOP
194:           		if (grs & 0x7f) {
39FA  C510     MOVFF c, d
39FC  F509     NOP
39FE  0E7F     MOVLW 0x7F
3A00  1609     ANDWF 0x9, F, ACCESS
3A02  B4D8     BTFSC 0xFD8, 2, ACCESS
3A04  EF06     GOTO 0x3A0C
3A06  F01D     NOP
3A08  EF08     GOTO 0x3A10
3A0A  F01D     NOP
3A0C  EF0C     GOTO 0x3A18
3A0E  F01D     NOP
195:           			aexp = 1;
3A10  0E01     MOVLW 0x1
3A12  6E0E     MOVWF 0xE, ACCESS
196:           		}
3A14  EF15     GOTO 0x3A2A
3A16  F01D     NOP
197:           		else {
3A18  A001     BTFSS 0x1, 0, ACCESS
3A1A  EF11     GOTO 0x3A22
3A1C  F01D     NOP
3A1E  EF13     GOTO 0x3A26
3A20  F01D     NOP
3A22  EF15     GOTO 0x3A2A
3A24  F01D     NOP
3A26  EF08     GOTO 0x3A10
3A28  F01D     NOP
198:           			if (B_FRACTION.i & 1) {
199:           				aexp = 1;
200:           			}
201:           		}
202:           	}
3A2A  500E     MOVF 0xE, W, ACCESS
3A2C  B4D8     BTFSC 0xFD8, 2, ACCESS
3A2E  EF1B     GOTO 0x3A36
3A30  F01D     NOP
3A32  EF1D     GOTO 0x3A3A
3A34  F01D     NOP
3A36  EF48     GOTO 0x3A90
3A38  F01D     NOP
203:           	if (aexp) {
204:           		++B_FRACTION.i;
3A3A  0E01     MOVLW 0x1
3A3C  2601     ADDWF 0x1, F, ACCESS
3A3E  0E00     MOVLW 0x0
3A40  2202     ADDWFC 0x2, F, ACCESS
3A42  2203     ADDWFC 0x3, F, ACCESS
3A44  2204     ADDWFC 0x4, F, ACCESS
205:           		if (B_FRACTION.i & ((int32_t) 1 << (SPFRCB + 1))) {
3A46  A004     BTFSS 0x4, 0, ACCESS
3A48  EF28     GOTO 0x3A50
3A4A  F01D     NOP
3A4C  EF2A     GOTO 0x3A54
3A4E  F01D     NOP
3A50  EF48     GOTO 0x3A90
3A52  F01D     NOP
206:           			B_FRACTION.i = B_FRACTION.i >> 1;
3A54  C501     MOVFF __pcstackCOMRAM, d
3A56  F509     NOP
3A58  C502     MOVFF txData, r
3A5A  F50A     NOP
3A5C  C503     MOVFF _r, arg
3A5E  F50B     NOP
3A60  C504     MOVFF 0x504, s
3A62  F50C     NOP
3A64  340C     RLCF 0xC, W, ACCESS
3A66  320C     RRCF 0xC, F, ACCESS
3A68  320B     RRCF 0xB, F, ACCESS
3A6A  320A     RRCF 0xA, F, ACCESS
3A6C  3209     RRCF 0x9, F, ACCESS
3A6E  C509     MOVFF d, __pcstackCOMRAM
3A70  F501     NOP
3A72  C50A     MOVFF r, txData
3A74  F502     NOP
3A76  C50B     MOVFF arg, _r
3A78  F503     NOP
3A7A  C50C     MOVFF s, 0x504
3A7C  F504     NOP
207:           			if (!(bexp == 0xFF)) {
3A7E  280F     INCF 0xF, W, ACCESS
3A80  B4D8     BTFSC 0xFD8, 2, ACCESS
3A82  EF45     GOTO 0x3A8A
3A84  F01D     NOP
3A86  EF47     GOTO 0x3A8E
3A88  F01D     NOP
3A8A  EF48     GOTO 0x3A90
3A8C  F01D     NOP
208:           				++bexp;
3A8E  2A0F     INCF 0xF, F, ACCESS
209:           			}
210:           		}
211:           	}
212:           
213:           	/* Overflow ? Return infinity */
214:           	/* Underflow ? Flush to zero */
215:           	if (bexp == 0xFF || bexp == 0) {
3A90  280F     INCF 0xF, W, ACCESS
3A92  B4D8     BTFSC 0xFD8, 2, ACCESS
3A94  EF4E     GOTO 0x3A9C
3A96  F01D     NOP
3A98  EF50     GOTO 0x3AA0
3A9A  F01D     NOP
3A9C  EF58     GOTO 0x3AB0
3A9E  F01D     NOP
3AA0  500F     MOVF 0xF, W, ACCESS
3AA2  A4D8     BTFSS 0xFD8, 2, ACCESS
3AA4  EF56     GOTO 0x3AAC
3AA6  F01D     NOP
3AA8  EF58     GOTO 0x3AB0
3AAA  F01D     NOP
3AAC  EF6A     GOTO 0x3AD4
3AAE  F01D     NOP
216:           		B_FRACTION.i = 0;
3AB0  0E00     MOVLW 0x0
3AB2  6E01     MOVWF 0x1, ACCESS
3AB4  0E00     MOVLW 0x0
3AB6  6E02     MOVWF 0x2, ACCESS
3AB8  0E00     MOVLW 0x0
3ABA  6E03     MOVWF 0x3, ACCESS
3ABC  0E00     MOVLW 0x0
3ABE  6E04     MOVWF 0x4, ACCESS
217:                           // no negative 0 for now
218:                           if (bexp == 0) {
3AC0  500F     MOVF 0xF, W, ACCESS
3AC2  A4D8     BTFSS 0xFD8, 2, ACCESS
3AC4  EF66     GOTO 0x3ACC
3AC6  F01D     NOP
3AC8  EF68     GOTO 0x3AD0
3ACA  F01D     NOP
3ACC  EF6A     GOTO 0x3AD4
3ACE  F01D     NOP
219:           		        signs=0;
3AD0  0E00     MOVLW 0x0
3AD2  6E0D     MOVWF 0xD, ACCESS
220:                           }
221:           	}
222:           
223:           	/* Pack and return result */
224:           	// set the low bit of the exponent ...
225:           	if (bexp & 0x1) {
3AD4  A00F     BTFSS 0xF, 0, ACCESS
3AD6  EF6F     GOTO 0x3ADE
3AD8  F01D     NOP
3ADA  EF71     GOTO 0x3AE2
3ADC  F01D     NOP
3ADE  EF74     GOTO 0x3AE8
3AE0  F01D     NOP
226:           		B_FRACTION.fAsBytes.c |= 0x80;
3AE2  8E03     BSF 0x3, 7, ACCESS
227:           	}
3AE4  EF75     GOTO 0x3AEA
3AE6  F01D     NOP
228:           	// AND out the leading 1
229:           	else {
230:           		B_FRACTION.fAsBytes.c &= 0x7F;
3AE8  9E03     BCF 0x3, 7, ACCESS
231:           	}
232:           	B_FRACTION.fAsBytes.d = bexp >> 1;
3AEA  90D8     BCF 0xFD8, 0, ACCESS
3AEC  300F     RRCF 0xF, W, ACCESS
3AEE  6E04     MOVWF 0x4, ACCESS
233:           	if (signs & 0x80) {
3AF0  AE0D     BTFSS 0xD, 7, ACCESS
3AF2  EF7D     GOTO 0x3AFA
3AF4  F01D     NOP
3AF6  EF7F     GOTO 0x3AFE
3AF8  F01D     NOP
3AFA  EF80     GOTO 0x3B00
3AFC  F01D     NOP
234:           		B_FRACTION.fAsBytes.d |= 0x80;
3AFE  8E04     BSF 0x4, 7, ACCESS
235:           	}
236:           	return b;
3B00  C501     MOVFF __pcstackCOMRAM, __pcstackCOMRAM
3B02  F501     NOP
3B04  C502     MOVFF txData, txData
3B06  F502     NOP
3B08  C503     MOVFF _r, _r
3B0A  F503     NOP
3B0C  C504     MOVFF 0x504, 0x504
3B0E  F504     NOP
237:           }
3B10  0012     RETURN 0
238:           
239:           /* SP Subtract */
240:           #ifdef __PICC__
241:           SP
242:           SPSUB(SP a, SP b)
243:           #else
244:           SP
245:           SPSUB(SP b, SP a)
5A34  0E00     MOVLW 0x0
5A36  1A2C     XORWF 0x2C, F, ACCESS
5A38  0E00     MOVLW 0x0
5A3A  1A2D     XORWF 0x2D, F, ACCESS
5A3C  0E00     MOVLW 0x0
5A3E  1A2E     XORWF 0x2E, F, ACCESS
5A40  0E80     MOVLW 0x80
5A42  1A2F     XORWF 0x2F, F, ACCESS
246:           #endif
247:           {
248:           	(*(SFP *) & a).i ^= 0x80000000; 
249:           	return __fladd(b, a);
5A44  C528     MOVFF x, __pcstackCOMRAM
5A46  F501     NOP
5A48  C529     MOVFF 0x529, txData
5A4A  F502     NOP
5A4C  C52A     MOVFF 0x52A, _r
5A4E  F503     NOP
5A50  C52B     MOVFF 0x52B, 0x504
5A52  F504     NOP
5A54  C52C     MOVFF a, n
5A56  F505     NOP
5A58  C52D     MOVFF 0x52D, sign
5A5A  F506     NOP
5A5C  C52E     MOVFF 0x52E, s
5A5E  F507     NOP
5A60  C52F     MOVFF 0x52F, l
5A62  F508     NOP
5A64  EC29     CALL 0x3652, 0
5A66  F01B     NOP
5A68  C501     MOVFF __pcstackCOMRAM, x
5A6A  F528     NOP
5A6C  C502     MOVFF txData, 0x529
5A6E  F529     NOP
5A70  C503     MOVFF _r, 0x52A
5A72  F52A     NOP
5A74  C504     MOVFF 0x504, 0x52B
5A76  F52B     NOP
250:           }
5A78  0012     RETURN 0
251:           
---  C:/Program Files/Microchip/xc8/v2.20/pic/sources/c99/common/printf.c  ------------------------------
1:             #include <stdio.h>
2:             #include <stdarg.h>
3:             #include "stdio_impl.h"
4:             
5:             int printf(const char *restrict fmt, ...)
5C70  0E5C     MOVLW 0x5C
5C72  0105     MOVLB 0x5
5C74  6FAC     MOVWF ACTCON, BANKED
5C76  0E05     MOVLW 0x5
5C78  6FAD     MOVWF OSCCON1, BANKED
6:             {
7:             	int ret;
8:             	va_list ap;
9:             	va_start(ap, fmt);
10:            	ret = vfprintf(stdout, fmt, ap);
5C7A  0E00     MOVLW 0x0
5C7C  6E52     MOVWF 0x52, ACCESS
5C7E  0E00     MOVLW 0x0
5C80  6E53     MOVWF 0x53, ACCESS
5C82  C55A     MOVFF fmt, fmt
5C84  F554     NOP
5C86  C55B     MOVFF 0x55B, 0x555
5C88  F555     NOP
5C8A  0EAC     MOVLW 0xAC
5C8C  6E56     MOVWF 0x56, ACCESS
5C8E  0E05     MOVLW 0x5
5C90  6E57     MOVWF 0x57, ACCESS
5C92  EC54     CALL 0x58A8, 0
5C94  F02C     NOP
11:            	va_end(ap);
12:            	return ret;
13:            }
5C96  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.20/pic/sources/c99/common/nf_fputs.c  ----------------------------
1:             /* "No file system" fputs */
2:             #include <stdio.h>
3:             
4:             #include "stdio_impl.h"
5:             
6:             #ifdef STDIO_NO_FILE_IO
7:             
8:             int fputs(const char *s, FILE *fp)
5A7A  0E00     MOVLW 0x0
5A7C  6E12     MOVWF 0x12, ACCESS
5A7E  0E00     MOVLW 0x0
5A80  6E11     MOVWF 0x11, ACCESS
9:             {
10:                char c;
11:                int i;
12:            
13:                i = 0;
14:                while ((c = *(s + i))) {
5A82  EF4E     GOTO 0x5A9C
5A84  F02D     NOP
5A9C  5011     MOVF 0x11, W, ACCESS
5A9E  240C     ADDWF 0xC, W, ACCESS
5AA0  6ED9     MOVWF 0xFD9, ACCESS
5AA2  5012     MOVF 0x12, W, ACCESS
5AA4  200D     ADDWFC 0xD, W, ACCESS
5AA6  6EDA     MOVWF 0xFDA, ACCESS
5AA8  50DF     MOVF 0xFDF, W, ACCESS
5AAA  6E10     MOVWF 0x10, ACCESS
5AAC  5010     MOVF 0x10, W, ACCESS
5AAE  A4D8     BTFSS 0xFD8, 2, ACCESS
5AB0  EF5C     GOTO 0x5AB8
5AB2  F02D     NOP
5AB4  EF5E     GOTO 0x5ABC
5AB6  F02D     NOP
5AB8  EF43     GOTO 0x5A86
5ABA  F02D     NOP
15:            	fputc(c,fp);
5A86  C510     MOVFF c, _r
5A88  F503     NOP
5A8A  6A04     CLRF 0x4, ACCESS
5A8C  C50E     MOVFF fp, n
5A8E  F505     NOP
5A90  C50F     MOVFF bexp, sign
5A92  F506     NOP
5A94  EC83     CALL 0x5706, 0
5A96  F02B     NOP
16:                    ++i;
5A98  4A11     INFSNZ 0x11, F, ACCESS
5A9A  2A12     INCF 0x12, F, ACCESS
17:                }
18:                return i;
19:            }
5ABC  0012     RETURN 0
20:            
21:            #endif
---  C:/Program Files/Microchip/xc8/v2.20/pic/sources/c99/common/nf_fputc.c  ----------------------------
1:             #include <stdio.h>
2:             
3:             #include "stdio_impl.h"
4:             
5:             #ifdef STDIO_NO_FILE_IO
6:             /* "No file system" fputc */
7:             
8:             int fputc(int c, FILE *fp)
5706  5005     MOVF 0x5, W, ACCESS
5708  1006     IORWF 0x6, W, ACCESS
570A  B4D8     BTFSC 0xFD8, 2, ACCESS
570C  EF8A     GOTO 0x5714
570E  F02B     NOP
5710  EF8C     GOTO 0x5718
5712  F02B     NOP
5714  EF95     GOTO 0x572A
5716  F02B     NOP
5718  5005     MOVF 0x5, W, ACCESS
571A  1006     IORWF 0x6, W, ACCESS
571C  A4D8     BTFSS 0xFD8, 2, ACCESS
571E  EF93     GOTO 0x5726
5720  F02B     NOP
5722  EF95     GOTO 0x572A
5724  F02B     NOP
5726  EF9A     GOTO 0x5734
5728  F02B     NOP
9:             {
10:                extern void putch(char);
11:            
12:                if ((fp == stdout) || (fp == stderr)) {
13:                    putch(c);
572A  5003     MOVF 0x3, W, ACCESS
572C  ECC8     CALL 0x5D90, 0
572E  F02E     NOP
14:                } else {
5730  EFCD     GOTO 0x579A
5732  F02B     NOP
15:            	if((fp->limit == 0) || (fp->count < fp->limit)) {
5734  EE20     LFSR 2, 0x4
5736  F004     NOP
5738  5005     MOVF 0x5, W, ACCESS
573A  26D9     ADDWF 0xFD9, F, ACCESS
573C  5006     MOVF 0x6, W, ACCESS
573E  22DA     ADDWFC 0xFDA, F, ACCESS
5740  50DE     MOVF 0xFDE, W, ACCESS
5742  10DE     IORWF 0xFDE, W, ACCESS
5744  B4D8     BTFSC 0xFD8, 2, ACCESS
5746  EFA7     GOTO 0x574E
5748  F02B     NOP
574A  EFA9     GOTO 0x5752
574C  F02B     NOP
574E  EFC4     GOTO 0x5788
5750  F02B     NOP
5752  EE20     LFSR 2, 0x4
5754  F004     NOP
5756  5005     MOVF 0x5, W, ACCESS
5758  26D9     ADDWF 0xFD9, F, ACCESS
575A  5006     MOVF 0x6, W, ACCESS
575C  22DA     ADDWFC 0xFDA, F, ACCESS
575E  EE10     LFSR 1, 0x2
5760  F002     NOP
5762  5005     MOVF 0x5, W, ACCESS
5764  26E1     ADDWF 0xFE1, F, ACCESS
5766  5006     MOVF 0x6, W, ACCESS
5768  22E2     ADDWFC 0xFE2, F, ACCESS
576A  50DE     MOVF 0xFDE, W, ACCESS
576C  5CE6     SUBWF 0xFE6, W, ACCESS
576E  50E6     MOVF 0xFE6, W, ACCESS
5770  0A80     XORLW 0x80
5772  6E0B     MOVWF 0xB, ACCESS
5774  50DE     MOVF 0xFDE, W, ACCESS
5776  0A80     XORLW 0x80
5778  580B     SUBWFB 0xB, W, ACCESS
577A  B0D8     BTFSC 0xFD8, 0, ACCESS
577C  EFC2     GOTO 0x5784
577E  F02B     NOP
5780  EFC4     GOTO 0x5788
5782  F02B     NOP
5784  EFCD     GOTO 0x579A
5786  F02B     NOP
16:            	        fp->buffer[fp->count] = (char)c;
17:            		++fp->count;
5788  EE20     LFSR 2, 0x2
578A  F002     NOP
578C  5005     MOVF 0x5, W, ACCESS
578E  26D9     ADDWF 0xFD9, F, ACCESS
5790  5006     MOVF 0x6, W, ACCESS
5792  22DA     ADDWFC 0xFDA, F, ACCESS
5794  2ADE     INCF 0xFDE, F, ACCESS
5796  0E00     MOVLW 0x0
5798  22DD     ADDWFC 0xFDD, F, ACCESS
18:            	}
19:                }
20:                return (unsigned char)c;
21:            }
579A  0012     RETURN 0
22:            
23:            #endif
---  C:/Program Files/Microchip/xc8/v2.20/pic/sources/c99/common/isupper.c  -----------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isupper
4:             
5:             int isupper(int c)
5B78  0EBF     MOVLW 0xBF
5B7A  6E03     MOVWF 0x3, ACCESS
5B7C  0EFF     MOVLW 0xFF
5B7E  6E04     MOVWF 0x4, ACCESS
5B80  C501     MOVFF __pcstackCOMRAM, n
5B82  F505     NOP
5B84  C502     MOVFF txData, sign
5B86  F506     NOP
5B88  5003     MOVF 0x3, W, ACCESS
5B8A  2605     ADDWF 0x5, F, ACCESS
5B8C  5004     MOVF 0x4, W, ACCESS
5B8E  2206     ADDWFC 0x6, F, ACCESS
5B90  5006     MOVF 0x6, W, ACCESS
5B92  E10A     BNZ 0x5BA8
5B94  0E1A     MOVLW 0x1A
5B96  5C05     SUBWF 0x5, W, ACCESS
5B98  A0D8     BTFSS 0xFD8, 0, ACCESS
5B9A  EFD1     GOTO 0x5BA2
5B9C  F02D     NOP
5B9E  EFD4     GOTO 0x5BA8
5BA0  F02D     NOP
5BA2  0E01     MOVLW 0x1
5BA4  EFD5     GOTO 0x5BAA
5BA6  F02D     NOP
5BA8  0E00     MOVLW 0x0
5BAA  6E01     MOVWF 0x1, ACCESS
5BAC  6A02     CLRF 0x2, ACCESS
6:             {
7:             	return (unsigned)c-'A' < 26;
8:             }
5BAE  0012     RETURN 0
9:             
10:            int __isupper_l(int c, locale_t l)
11:            {
12:            	return isupper(c);
13:            }
14:            
15:            weak_alias(__isupper_l, isupper_l);
---  C:/Program Files/Microchip/xc8/v2.20/pic/sources/c99/common/fltol.c  -------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"flarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned long *)&f1)
11:            
12:            // Convert float to long
13:            #ifdef _OLDLIB
14:            long
15:            __fltol(double f1)
16:            {
17:            	unsigned char	sign1, exp1;
18:            	unsigned long	lval;
19:            
20:            	sign1 = __flunpack(&f1_as_mant1, &exp1);
21:            	lval = f1_as_mant1;
22:            	exp1 -= 127+23;
23:            	if((signed char)exp1 < 0) {
24:            		if((signed char)exp1 < -23)
25:            			return 0;
26:            		do
27:            			lval >>= 1;
28:            		while(++exp1 != 0);
29:            	} else {
30:            		if(exp1 >= 32)
31:            			return 00;
32:            		while(exp1 != 0) {
33:            			lval <<= 1;
34:            			exp1--;
35:            		}
36:            	}
37:            	if(sign1)
38:            		lval = -lval;
39:            	return lval;
40:            }
41:            #else
42:            long
43:            __fltol(double f1)
5020  342A     RLCF 0x2A, W, ACCESS
5022  342B     RLCF 0x2B, W, ACCESS
5024  6E31     MOVWF 0x31, ACCESS
5026  5031     MOVF 0x31, W, ACCESS
5028  A4D8     BTFSS 0xFD8, 2, ACCESS
502A  EF19     GOTO 0x5032
502C  F028     NOP
502E  EF1B     GOTO 0x5036
5030  F028     NOP
5032  EF25     GOTO 0x504A
5034  F028     NOP
44:            {
45:            	unsigned char	sign1, exp1;
46:            
47:            	if((exp1 = f1_as_mant1 >> 23) == 0)
48:            		return 0;
5036  0E00     MOVLW 0x0
5038  6E28     MOVWF 0x28, ACCESS
503A  0E00     MOVLW 0x0
503C  6E29     MOVWF 0x29, ACCESS
503E  0E00     MOVLW 0x0
5040  6E2A     MOVWF 0x2A, ACCESS
5042  0E00     MOVLW 0x0
5044  6E2B     MOVWF 0x2B, ACCESS
5046  EF92     GOTO 0x5124
5048  F028     NOP
49:            	sign1 = f1_as_mant1 >> 31;
504A  C528     MOVFF x, a
504C  F52C     NOP
504E  C529     MOVFF 0x529, 0x52D
5050  F52D     NOP
5052  C52A     MOVFF 0x52A, 0x52E
5054  F52E     NOP
5056  C52B     MOVFF 0x52B, 0x52F
5058  F52F     NOP
505A  0E20     MOVLW 0x20
505C  EF35     GOTO 0x506A
505E  F028     NOP
5060  90D8     BCF 0xFD8, 0, ACCESS
5062  322F     RRCF 0x2F, F, ACCESS
5064  322E     RRCF 0x2E, F, ACCESS
5066  322D     RRCF 0x2D, F, ACCESS
5068  322C     RRCF 0x2C, F, ACCESS
506A  2EE8     DECFSZ 0xFE8, F, ACCESS
506C  EF30     GOTO 0x5060
506E  F028     NOP
5070  502C     MOVF 0x2C, W, ACCESS
5072  6E30     MOVWF 0x30, ACCESS
50:            	f1_as_mant1 |= 0x800000UL;
5074  8E2A     BSF 0x2A, 7, ACCESS
51:            	f1_as_mant1 &= 0xFFFFFFUL;
5076  0EFF     MOVLW 0xFF
5078  1628     ANDWF 0x28, F, ACCESS
507A  0EFF     MOVLW 0xFF
507C  1629     ANDWF 0x29, F, ACCESS
507E  0EFF     MOVLW 0xFF
5080  162A     ANDWF 0x2A, F, ACCESS
5082  0E00     MOVLW 0x0
5084  162B     ANDWF 0x2B, F, ACCESS
52:            	exp1 -= 127+23;
5086  0E96     MOVLW 0x96
5088  5E31     SUBWF 0x31, F, ACCESS
53:            	if((signed char)exp1 < 0) {
508A  BE31     BTFSC 0x31, 7, ACCESS
508C  EF4C     GOTO 0x5098
508E  F028     NOP
5090  EF4A     GOTO 0x5094
5092  F028     NOP
5094  EF62     GOTO 0x50C4
5096  F028     NOP
54:            		if((signed char)exp1 < -23)
5098  5031     MOVF 0x31, W, ACCESS
509A  0A80     XORLW 0x80
509C  0F97     ADDLW 0x97
509E  B0D8     BTFSC 0xFD8, 0, ACCESS
50A0  EF54     GOTO 0x50A8
50A2  F028     NOP
50A4  EF56     GOTO 0x50AC
50A6  F028     NOP
50A8  EF58     GOTO 0x50B0
50AA  F028     NOP
50AC  EF1B     GOTO 0x5036
50AE  F028     NOP
55:            			return 0;
56:            		do
57:            			f1_as_mant1 >>= 1;
50B0  90D8     BCF 0xFD8, 0, ACCESS
50B2  322B     RRCF 0x2B, F, ACCESS
50B4  322A     RRCF 0x2A, F, ACCESS
50B6  3229     RRCF 0x29, F, ACCESS
50B8  3228     RRCF 0x28, F, ACCESS
50BA  3E31     INCFSZ 0x31, F, ACCESS
50BC  EF58     GOTO 0x50B0
50BE  F028     NOP
50C0  EF7A     GOTO 0x50F4
50C2  F028     NOP
58:            		while(++exp1 != 0);
59:            	} else {
60:            		if(exp1 >= 32)
50C4  0E1F     MOVLW 0x1F
50C6  6431     CPFSGT 0x31, ACCESS
50C8  EF68     GOTO 0x50D0
50CA  F028     NOP
50CC  EF6A     GOTO 0x50D4
50CE  F028     NOP
50D0  EF72     GOTO 0x50E4
50D2  F028     NOP
50D4  EF1B     GOTO 0x5036
50D6  F028     NOP
61:            			return 00;
62:            		while(exp1 != 0) {
50E4  5031     MOVF 0x31, W, ACCESS
50E6  A4D8     BTFSS 0xFD8, 2, ACCESS
50E8  EF78     GOTO 0x50F0
50EA  F028     NOP
50EC  EF7A     GOTO 0x50F4
50EE  F028     NOP
50F0  EF6C     GOTO 0x50D8
50F2  F028     NOP
63:            			f1_as_mant1 <<= 1;
50D8  90D8     BCF 0xFD8, 0, ACCESS
50DA  3628     RLCF 0x28, F, ACCESS
50DC  3629     RLCF 0x29, F, ACCESS
50DE  362A     RLCF 0x2A, F, ACCESS
50E0  362B     RLCF 0x2B, F, ACCESS
64:            			exp1--;
50E2  0631     DECF 0x31, F, ACCESS
65:            		}
66:            	}
67:            	if(sign1)
50F4  5030     MOVF 0x30, W, ACCESS
50F6  B4D8     BTFSC 0xFD8, 2, ACCESS
50F8  EF80     GOTO 0x5100
50FA  F028     NOP
50FC  EF82     GOTO 0x5104
50FE  F028     NOP
5100  EF8A     GOTO 0x5114
5102  F028     NOP
68:            		f1_as_mant1 = -f1_as_mant1;
5104  1E2B     COMF 0x2B, F, ACCESS
5106  1E2A     COMF 0x2A, F, ACCESS
5108  1E29     COMF 0x29, F, ACCESS
510A  6C28     NEGF 0x28, ACCESS
510C  0E00     MOVLW 0x0
510E  2229     ADDWFC 0x29, F, ACCESS
5110  222A     ADDWFC 0x2A, F, ACCESS
5112  222B     ADDWFC 0x2B, F, ACCESS
69:            	return f1_as_mant1;
5114  C528     MOVFF x, x
5116  F528     NOP
5118  C529     MOVFF 0x529, 0x529
511A  F529     NOP
511C  C52A     MOVFF 0x52A, 0x52A
511E  F52A     NOP
5120  C52B     MOVFF 0x52B, 0x52B
5122  F52B     NOP
70:            }
5124  0012     RETURN 0
71:            #endif
---  C:/Program Files/Microchip/xc8/v2.20/pic/sources/c99/common/floorf.c  ------------------------------
1:             #include "libm.h"
2:             
3:             float floorf(float x)
496E  C5D1     MOVFF __pbssBANK5, u
4970  F538     NOP
4972  C5D2     MOVFF 0x5D2, 0x539
4974  F539     NOP
4976  C5D3     MOVFF 0x5D3, 0x53A
4978  F53A     NOP
497A  C5D4     MOVFF 0x5D4, 0x53B
497C  F53B     NOP
497E  C528     MOVFF x, u
4980  F538     NOP
4982  C529     MOVFF 0x529, 0x539
4984  F539     NOP
4986  C52A     MOVFF 0x52A, 0x53A
4988  F53A     NOP
498A  C52B     MOVFF 0x52B, 0x53B
498C  F53B     NOP
4:             {
5:             	union {float f; uint32_t i;} u = {x};
6:             	int e = (int)(u.i >> 23 & 0xff) - 0x7f;
498E  0E81     MOVLW 0x81
4990  6E2C     MOVWF 0x2C, ACCESS
4992  0EFF     MOVLW 0xFF
4994  6E2D     MOVWF 0x2D, ACCESS
4996  C538     MOVFF u, 0x52E
4998  F52E     NOP
499A  C539     MOVFF 0x539, 0x52F
499C  F52F     NOP
499E  C53A     MOVFF 0x53A, sign1
49A0  F530     NOP
49A2  C53B     MOVFF 0x53B, exp1
49A4  F531     NOP
49A6  0E18     MOVLW 0x18
49A8  EFDB     GOTO 0x49B6
49AA  F024     NOP
49AC  90D8     BCF 0xFD8, 0, ACCESS
49AE  3231     RRCF 0x31, F, ACCESS
49B0  3230     RRCF 0x30, F, ACCESS
49B2  322F     RRCF 0x2F, F, ACCESS
49B4  322E     RRCF 0x2E, F, ACCESS
49B6  2EE8     DECFSZ 0xFE8, F, ACCESS
49B8  EFD6     GOTO 0x49AC
49BA  F024     NOP
49BC  502E     MOVF 0x2E, W, ACCESS
49BE  242C     ADDWF 0x2C, W, ACCESS
49C0  6E36     MOVWF 0x36, ACCESS
49C2  0E00     MOVLW 0x0
49C4  202D     ADDWFC 0x2D, W, ACCESS
49C6  6E37     MOVWF 0x37, ACCESS
7:             	uint32_t m;
8:             
9:             	if (e >= 23)
49C8  BE37     BTFSC 0x37, 7, ACCESS
49CA  EFF0     GOTO 0x49E0
49CC  F024     NOP
49CE  5037     MOVF 0x37, W, ACCESS
49D0  E109     BNZ 0x49E4
49D2  0E17     MOVLW 0x17
49D4  5C36     SUBWF 0x36, W, ACCESS
49D6  A0D8     BTFSS 0xFD8, 0, ACCESS
49D8  EFF0     GOTO 0x49E0
49DA  F024     NOP
49DC  EFF2     GOTO 0x49E4
49DE  F024     NOP
49E0  EFFC     GOTO 0x49F8
49E2  F024     NOP
10:            		return x;
49E4  C528     MOVFF x, x
49E6  F528     NOP
49E8  C529     MOVFF 0x529, 0x529
49EA  F529     NOP
49EC  C52A     MOVFF 0x52A, 0x52A
49EE  F52A     NOP
49F0  C52B     MOVFF 0x52B, 0x52B
49F2  F52B     NOP
49F4  EFBF     GOTO 0x4B7E
49F6  F025     NOP
11:            	if (e >= 0) {
49F8  BE37     BTFSC 0x37, 7, ACCESS
49FA  EF01     GOTO 0x4A02
49FC  F025     NOP
49FE  EF03     GOTO 0x4A06
4A00  F025     NOP
4A02  EF73     GOTO 0x4AE6
4A04  F025     NOP
12:            		m = 0x007fffff >> e;
4A06  C536     MOVFF e, a
4A08  F52C     NOP
4A0A  0EFF     MOVLW 0xFF
4A0C  6E2D     MOVWF 0x2D, ACCESS
4A0E  0EFF     MOVLW 0xFF
4A10  6E2E     MOVWF 0x2E, ACCESS
4A12  0E7F     MOVLW 0x7F
4A14  6E2F     MOVWF 0x2F, ACCESS
4A16  0E00     MOVLW 0x0
4A18  6E30     MOVWF 0x30, ACCESS
4A1A  662C     TSTFSZ 0x2C, ACCESS
4A1C  EF12     GOTO 0x4A24
4A1E  F025     NOP
4A20  EF1A     GOTO 0x4A34
4A22  F025     NOP
4A24  3430     RLCF 0x30, W, ACCESS
4A26  3230     RRCF 0x30, F, ACCESS
4A28  322F     RRCF 0x2F, F, ACCESS
4A2A  322E     RRCF 0x2E, F, ACCESS
4A2C  322D     RRCF 0x2D, F, ACCESS
4A2E  2E2C     DECFSZ 0x2C, F, ACCESS
4A30  EF0D     GOTO 0x4A1A
4A32  F025     NOP
4A34  C52D     MOVFF 0x52D, m
4A36  F532     NOP
4A38  C52E     MOVFF 0x52E, 0x533
4A3A  F533     NOP
4A3C  C52F     MOVFF 0x52F, w
4A3E  F534     NOP
4A40  C530     MOVFF sign1, 0x535
4A42  F535     NOP
13:            		if ((u.i & m) == 0)
4A44  5032     MOVF 0x32, W, ACCESS
4A46  1438     ANDWF 0x38, W, ACCESS
4A48  6E2C     MOVWF 0x2C, ACCESS
4A4A  5033     MOVF 0x33, W, ACCESS
4A4C  1439     ANDWF CLKRCON, W, ACCESS
4A4E  6E2D     MOVWF 0x2D, ACCESS
4A50  5034     MOVF 0x34, W, ACCESS
4A52  143A     ANDWF CLKRCLK, W, ACCESS
4A54  6E2E     MOVWF 0x2E, ACCESS
4A56  5035     MOVF 0x35, W, ACCESS
4A58  143B     ANDWF 0x3B, W, ACCESS
4A5A  6E2F     MOVWF 0x2F, ACCESS
4A5C  502C     MOVF 0x2C, W, ACCESS
4A5E  102D     IORWF 0x2D, W, ACCESS
4A60  102E     IORWF 0x2E, W, ACCESS
4A62  102F     IORWF 0x2F, W, ACCESS
4A64  A4D8     BTFSS 0xFD8, 2, ACCESS
4A66  EF37     GOTO 0x4A6E
4A68  F025     NOP
4A6A  EF39     GOTO 0x4A72
4A6C  F025     NOP
4A6E  EF3B     GOTO 0x4A76
4A70  F025     NOP
4A72  EFF2     GOTO 0x49E4
4A74  F024     NOP
14:            			return x;
15:            		FORCE_EVAL(x + 0x1p120f);
16:            		if (u.i >> 31)
4A76  C538     MOVFF u, a
4A78  F52C     NOP
4A7A  C539     MOVFF 0x539, 0x52D
4A7C  F52D     NOP
4A7E  C53A     MOVFF 0x53A, 0x52E
4A80  F52E     NOP
4A82  C53B     MOVFF 0x53B, 0x52F
4A84  F52F     NOP
4A86  0E20     MOVLW 0x20
4A88  EF4B     GOTO 0x4A96
4A8A  F025     NOP
4A8C  90D8     BCF 0xFD8, 0, ACCESS
4A8E  322F     RRCF 0x2F, F, ACCESS
4A90  322E     RRCF 0x2E, F, ACCESS
4A92  322D     RRCF 0x2D, F, ACCESS
4A94  322C     RRCF 0x2C, F, ACCESS
4A96  2EE8     DECFSZ 0xFE8, F, ACCESS
4A98  EF46     GOTO 0x4A8C
4A9A  F025     NOP
4A9C  502C     MOVF 0x2C, W, ACCESS
4A9E  102D     IORWF 0x2D, W, ACCESS
4AA0  102E     IORWF 0x2E, W, ACCESS
4AA2  102F     IORWF 0x2F, W, ACCESS
4AA4  B4D8     BTFSC 0xFD8, 2, ACCESS
4AA6  EF57     GOTO 0x4AAE
4AA8  F025     NOP
4AAA  EF59     GOTO 0x4AB2
4AAC  F025     NOP
4AAE  EF61     GOTO 0x4AC2
4AB0  F025     NOP
17:            			u.i += m;
4AB2  5032     MOVF 0x32, W, ACCESS
4AB4  2638     ADDWF 0x38, F, ACCESS
4AB6  5033     MOVF 0x33, W, ACCESS
4AB8  2239     ADDWFC CLKRCON, F, ACCESS
4ABA  5034     MOVF 0x34, W, ACCESS
4ABC  223A     ADDWFC CLKRCLK, F, ACCESS
4ABE  5035     MOVF 0x35, W, ACCESS
4AC0  223B     ADDWFC 0x3B, F, ACCESS
18:            		u.i &= ~m;
4AC2  1C32     COMF 0x32, W, ACCESS
4AC4  6E2C     MOVWF 0x2C, ACCESS
4AC6  1C33     COMF 0x33, W, ACCESS
4AC8  6E2D     MOVWF 0x2D, ACCESS
4ACA  1C34     COMF 0x34, W, ACCESS
4ACC  6E2E     MOVWF 0x2E, ACCESS
4ACE  1C35     COMF 0x35, W, ACCESS
4AD0  6E2F     MOVWF 0x2F, ACCESS
4AD2  502C     MOVF 0x2C, W, ACCESS
4AD4  1638     ANDWF 0x38, F, ACCESS
4AD6  502D     MOVF 0x2D, W, ACCESS
4AD8  1639     ANDWF CLKRCON, F, ACCESS
4ADA  502E     MOVF 0x2E, W, ACCESS
4ADC  163A     ANDWF CLKRCLK, F, ACCESS
4ADE  502F     MOVF 0x2F, W, ACCESS
4AE0  163B     ANDWF 0x3B, F, ACCESS
19:            	} else {
4AE2  EFB7     GOTO 0x4B6E
4AE4  F025     NOP
20:            		FORCE_EVAL(x + 0x1p120f);
21:            		if (u.i >> 31 == 0)
4AE6  C538     MOVFF u, a
4AE8  F52C     NOP
4AEA  C539     MOVFF 0x539, 0x52D
4AEC  F52D     NOP
4AEE  C53A     MOVFF 0x53A, 0x52E
4AF0  F52E     NOP
4AF2  C53B     MOVFF 0x53B, 0x52F
4AF4  F52F     NOP
4AF6  0E20     MOVLW 0x20
4AF8  EF83     GOTO 0x4B06
4AFA  F025     NOP
4AFC  90D8     BCF 0xFD8, 0, ACCESS
4AFE  322F     RRCF 0x2F, F, ACCESS
4B00  322E     RRCF 0x2E, F, ACCESS
4B02  322D     RRCF 0x2D, F, ACCESS
4B04  322C     RRCF 0x2C, F, ACCESS
4B06  2EE8     DECFSZ 0xFE8, F, ACCESS
4B08  EF7E     GOTO 0x4AFC
4B0A  F025     NOP
4B0C  502C     MOVF 0x2C, W, ACCESS
4B0E  102D     IORWF 0x2D, W, ACCESS
4B10  102E     IORWF 0x2E, W, ACCESS
4B12  102F     IORWF 0x2F, W, ACCESS
4B14  A4D8     BTFSS 0xFD8, 2, ACCESS
4B16  EF8F     GOTO 0x4B1E
4B18  F025     NOP
4B1A  EF91     GOTO 0x4B22
4B1C  F025     NOP
4B1E  EF9B     GOTO 0x4B36
4B20  F025     NOP
22:            			u.i = 0;
4B22  0E00     MOVLW 0x0
4B24  6E38     MOVWF 0x38, ACCESS
4B26  0E00     MOVLW 0x0
4B28  6E39     MOVWF CLKRCON, ACCESS
4B2A  0E00     MOVLW 0x0
4B2C  6E3A     MOVWF CLKRCLK, ACCESS
4B2E  0E00     MOVLW 0x0
4B30  6E3B     MOVWF 0x3B, ACCESS
4B32  EFB7     GOTO 0x4B6E
4B34  F025     NOP
23:            		else if (u.i << 1)
4B36  90D8     BCF 0xFD8, 0, ACCESS
4B38  3438     RLCF 0x38, W, ACCESS
4B3A  6E2C     MOVWF 0x2C, ACCESS
4B3C  3439     RLCF CLKRCON, W, ACCESS
4B3E  6E2D     MOVWF 0x2D, ACCESS
4B40  343A     RLCF CLKRCLK, W, ACCESS
4B42  6E2E     MOVWF 0x2E, ACCESS
4B44  343B     RLCF 0x3B, W, ACCESS
4B46  6E2F     MOVWF 0x2F, ACCESS
4B48  502C     MOVF 0x2C, W, ACCESS
4B4A  102D     IORWF 0x2D, W, ACCESS
4B4C  102E     IORWF 0x2E, W, ACCESS
4B4E  102F     IORWF 0x2F, W, ACCESS
4B50  B4D8     BTFSC 0xFD8, 2, ACCESS
4B52  EFAD     GOTO 0x4B5A
4B54  F025     NOP
4B56  EFAF     GOTO 0x4B5E
4B58  F025     NOP
4B5A  EFB7     GOTO 0x4B6E
4B5C  F025     NOP
24:            			u.f = -1.0;
4B5E  0E00     MOVLW 0x0
4B60  6E38     MOVWF 0x38, ACCESS
4B62  0E00     MOVLW 0x0
4B64  6E39     MOVWF CLKRCON, ACCESS
4B66  0E80     MOVLW 0x80
4B68  6E3A     MOVWF CLKRCLK, ACCESS
4B6A  0EBF     MOVLW 0xBF
4B6C  6E3B     MOVWF 0x3B, ACCESS
25:            	}
26:            	return u.f;
4B6E  C538     MOVFF u, x
4B70  F528     NOP
4B72  C539     MOVFF 0x539, 0x529
4B74  F529     NOP
4B76  C53A     MOVFF 0x53A, 0x52A
4B78  F52A     NOP
4B7A  C53B     MOVFF 0x53B, 0x52B
4B7C  F52B     NOP
27:            }
4B7E  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.20/pic/sources/c99/common/flneg.c  -------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	mant1	(*(unsigned long *)&f1)
11:            
12:            // Negate a float
13:            
14:            double
15:            __flneg(double f1)
5BB0  5001     MOVF 0x1, W, ACCESS
5BB2  1002     IORWF 0x2, W, ACCESS
5BB4  1003     IORWF 0x3, W, ACCESS
5BB6  1004     IORWF 0x4, W, ACCESS
5BB8  B4D8     BTFSC 0xFD8, 2, ACCESS
5BBA  EFE1     GOTO 0x5BC2
5BBC  F02D     NOP
5BBE  EFE3     GOTO 0x5BC6
5BC0  F02D     NOP
5BC2  EFEB     GOTO 0x5BD6
5BC4  F02D     NOP
16:            {
17:            	if(mant1 != 0x0)
18:            		mant1 ^= 0x80000000UL;
5BC6  0E00     MOVLW 0x0
5BC8  1A01     XORWF 0x1, F, ACCESS
5BCA  0E00     MOVLW 0x0
5BCC  1A02     XORWF 0x2, F, ACCESS
5BCE  0E00     MOVLW 0x0
5BD0  1A03     XORWF 0x3, F, ACCESS
5BD2  0E80     MOVLW 0x80
5BD4  1A04     XORWF 0x4, F, ACCESS
19:            	return f1;
5BD6  C501     MOVFF __pcstackCOMRAM, __pcstackCOMRAM
5BD8  F501     NOP
5BDA  C502     MOVFF txData, txData
5BDC  F502     NOP
5BDE  C503     MOVFF _r, _r
5BE0  F503     NOP
5BE2  C504     MOVFF 0x504, 0x504
5BE4  F504     NOP
20:            }
5BE6  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.20/pic/sources/c99/common/flge.c  --------------------------------
1:             #define	f1	(*(unsigned long *)&ff1)
2:             #define	f2	(*(unsigned long *)&ff2)
3:             __bit
4:             __flge(double ff1, double ff2)
5126  0E00     MOVLW 0x0
5128  1428     ANDWF 0x28, W, ACCESS
512A  6E30     MOVWF 0x30, ACCESS
512C  0E00     MOVLW 0x0
512E  1429     ANDWF 0x29, W, ACCESS
5130  6E31     MOVWF 0x31, ACCESS
5132  0E80     MOVLW 0x80
5134  142A     ANDWF 0x2A, W, ACCESS
5136  6E32     MOVWF 0x32, ACCESS
5138  0E7F     MOVLW 0x7F
513A  142B     ANDWF 0x2B, W, ACCESS
513C  6E33     MOVWF 0x33, ACCESS
513E  5030     MOVF 0x30, W, ACCESS
5140  1031     IORWF 0x31, W, ACCESS
5142  1032     IORWF 0x32, W, ACCESS
5144  1033     IORWF 0x33, W, ACCESS
5146  A4D8     BTFSS 0xFD8, 2, ACCESS
5148  EFA8     GOTO 0x5150
514A  F028     NOP
514C  EFAA     GOTO 0x5154
514E  F028     NOP
5150  EFB2     GOTO 0x5164
5152  F028     NOP
5:             {
6:                     // flush denorms and zeroes to +ve 0.0
7:                     if((f1 &  0x7F800000UL)== 0)
8:             		f1 = 0x00000000UL;
5154  0E00     MOVLW 0x0
5156  6E28     MOVWF 0x28, ACCESS
5158  0E00     MOVLW 0x0
515A  6E29     MOVWF 0x29, ACCESS
515C  0E00     MOVLW 0x0
515E  6E2A     MOVWF 0x2A, ACCESS
5160  0E00     MOVLW 0x0
5162  6E2B     MOVWF 0x2B, ACCESS
9:             	if((f2 &  0x7F800000UL)== 0)
5164  0E00     MOVLW 0x0
5166  142C     ANDWF 0x2C, W, ACCESS
5168  6E30     MOVWF 0x30, ACCESS
516A  0E00     MOVLW 0x0
516C  142D     ANDWF 0x2D, W, ACCESS
516E  6E31     MOVWF 0x31, ACCESS
5170  0E80     MOVLW 0x80
5172  142E     ANDWF 0x2E, W, ACCESS
5174  6E32     MOVWF 0x32, ACCESS
5176  0E7F     MOVLW 0x7F
5178  142F     ANDWF 0x2F, W, ACCESS
517A  6E33     MOVWF 0x33, ACCESS
517C  5030     MOVF 0x30, W, ACCESS
517E  1031     IORWF 0x31, W, ACCESS
5180  1032     IORWF 0x32, W, ACCESS
5182  1033     IORWF 0x33, W, ACCESS
5184  A4D8     BTFSS 0xFD8, 2, ACCESS
5186  EFC7     GOTO 0x518E
5188  F028     NOP
518A  EFC9     GOTO 0x5192
518C  F028     NOP
518E  EFD1     GOTO 0x51A2
5190  F028     NOP
10:            	        f2 = 0x00000000UL;
5192  0E00     MOVLW 0x0
5194  6E2C     MOVWF 0x2C, ACCESS
5196  0E00     MOVLW 0x0
5198  6E2D     MOVWF 0x2D, ACCESS
519A  0E00     MOVLW 0x0
519C  6E2E     MOVWF 0x2E, ACCESS
519E  0E00     MOVLW 0x0
51A0  6E2F     MOVWF 0x2F, ACCESS
11:            	// compute >= a clever way
12:            	if(f1 &  0x80000000UL)
51A2  AE2B     BTFSS 0x2B, 7, ACCESS
51A4  EFD6     GOTO 0x51AC
51A6  F028     NOP
51A8  EFD8     GOTO 0x51B0
51AA  F028     NOP
51AC  EFE1     GOTO 0x51C2
51AE  F028     NOP
13:            		f1 = 0x80000000UL - f1;
51B0  6C28     NEGF 0x28, ACCESS
51B2  1E29     COMF 0x29, F, ACCESS
51B4  B0D8     BTFSC 0xFD8, 0, ACCESS
51B6  2A29     INCF 0x29, F, ACCESS
51B8  1E2A     COMF 0x2A, F, ACCESS
51BA  B0D8     BTFSC 0xFD8, 0, ACCESS
51BC  2A2A     INCF 0x2A, F, ACCESS
51BE  0E80     MOVLW 0x80
51C0  562B     SUBFWB 0x2B, F, ACCESS
14:            	if(f2 &  0x80000000UL)
51C2  AE2F     BTFSS 0x2F, 7, ACCESS
51C4  EFE6     GOTO 0x51CC
51C6  F028     NOP
51C8  EFE8     GOTO 0x51D0
51CA  F028     NOP
51CC  EFF1     GOTO 0x51E2
51CE  F028     NOP
15:            		f2 = 0x80000000UL - f2;
51D0  6C2C     NEGF 0x2C, ACCESS
51D2  1E2D     COMF 0x2D, F, ACCESS
51D4  B0D8     BTFSC 0xFD8, 0, ACCESS
51D6  2A2D     INCF 0x2D, F, ACCESS
51D8  1E2E     COMF 0x2E, F, ACCESS
51DA  B0D8     BTFSC 0xFD8, 0, ACCESS
51DC  2A2E     INCF 0x2E, F, ACCESS
51DE  0E80     MOVLW 0x80
51E0  562F     SUBFWB 0x2F, F, ACCESS
16:            	f1 ^= 0x80000000UL;
51E2  0E00     MOVLW 0x0
51E4  1A28     XORWF 0x28, F, ACCESS
51E6  0E00     MOVLW 0x0
51E8  1A29     XORWF 0x29, F, ACCESS
51EA  0E00     MOVLW 0x0
51EC  1A2A     XORWF 0x2A, F, ACCESS
51EE  0E80     MOVLW 0x80
51F0  1A2B     XORWF 0x2B, F, ACCESS
17:            	f2 ^= 0x80000000UL;
51F2  0E00     MOVLW 0x0
51F4  1A2C     XORWF 0x2C, F, ACCESS
51F6  0E00     MOVLW 0x0
51F8  1A2D     XORWF 0x2D, F, ACCESS
51FA  0E00     MOVLW 0x0
51FC  1A2E     XORWF 0x2E, F, ACCESS
51FE  0E80     MOVLW 0x80
5200  1A2F     XORWF 0x2F, F, ACCESS
18:            	return f1 >= f2;
5202  502C     MOVF 0x2C, W, ACCESS
5204  5C28     SUBWF 0x28, W, ACCESS
5206  502D     MOVF 0x2D, W, ACCESS
5208  5829     SUBWFB 0x29, W, ACCESS
520A  502E     MOVF 0x2E, W, ACCESS
520C  582A     SUBWFB 0x2A, W, ACCESS
520E  502F     MOVF 0x2F, W, ACCESS
5210  582B     SUBWFB 0x2B, W, ACCESS
5212  B0D8     BTFSC 0xFD8, 0, ACCESS
5214  EF0E     GOTO 0x521C
5216  F029     NOP
5218  EF10     GOTO 0x5220
521A  F029     NOP
521C  EF13     GOTO 0x5226
521E  F029     NOP
5220  90D8     BCF 0xFD8, 0, ACCESS
5222  EF14     GOTO 0x5228
5224  F029     NOP
5226  80D8     BSF 0xFD8, 0, ACCESS
19:            }
5228  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.20/pic/sources/c99/common/fleq.c  --------------------------------
1:             #define	f1	(*(unsigned long *)&ff1)
2:             #define	f2	(*(unsigned long *)&ff2)
3:             __bit
4:             __fleq(double ff1, double ff2)
565C  0E00     MOVLW 0x0
565E  1401     ANDWF 0x1, W, ACCESS
5660  6E09     MOVWF 0x9, ACCESS
5662  0E00     MOVLW 0x0
5664  1402     ANDWF 0x2, W, ACCESS
5666  6E0A     MOVWF 0xA, ACCESS
5668  0E80     MOVLW 0x80
566A  1403     ANDWF 0x3, W, ACCESS
566C  6E0B     MOVWF 0xB, ACCESS
566E  0E7F     MOVLW 0x7F
5670  1404     ANDWF 0x4, W, ACCESS
5672  6E0C     MOVWF 0xC, ACCESS
5674  5009     MOVF 0x9, W, ACCESS
5676  100A     IORWF 0xA, W, ACCESS
5678  100B     IORWF 0xB, W, ACCESS
567A  100C     IORWF 0xC, W, ACCESS
567C  A4D8     BTFSS 0xFD8, 2, ACCESS
567E  EF43     GOTO 0x5686
5680  F02B     NOP
5682  EF45     GOTO 0x568A
5684  F02B     NOP
5686  EF4D     GOTO 0x569A
5688  F02B     NOP
5:             {
6:                     // flush denorms and zeroes to +ve 0.0
7:                     if((f1 &  0x7F800000UL)== 0)
8:             		f1 = 0x00000000UL;
568A  0E00     MOVLW 0x0
568C  6E01     MOVWF 0x1, ACCESS
568E  0E00     MOVLW 0x0
5690  6E02     MOVWF 0x2, ACCESS
5692  0E00     MOVLW 0x0
5694  6E03     MOVWF 0x3, ACCESS
5696  0E00     MOVLW 0x0
5698  6E04     MOVWF 0x4, ACCESS
9:             	if((f2 &  0x7F800000UL)== 0)
569A  0E00     MOVLW 0x0
569C  1405     ANDWF 0x5, W, ACCESS
569E  6E09     MOVWF 0x9, ACCESS
56A0  0E00     MOVLW 0x0
56A2  1406     ANDWF 0x6, W, ACCESS
56A4  6E0A     MOVWF 0xA, ACCESS
56A6  0E80     MOVLW 0x80
56A8  1407     ANDWF 0x7, W, ACCESS
56AA  6E0B     MOVWF 0xB, ACCESS
56AC  0E7F     MOVLW 0x7F
56AE  1408     ANDWF 0x8, W, ACCESS
56B0  6E0C     MOVWF 0xC, ACCESS
56B2  5009     MOVF 0x9, W, ACCESS
56B4  100A     IORWF 0xA, W, ACCESS
56B6  100B     IORWF 0xB, W, ACCESS
56B8  100C     IORWF 0xC, W, ACCESS
56BA  A4D8     BTFSS 0xFD8, 2, ACCESS
56BC  EF62     GOTO 0x56C4
56BE  F02B     NOP
56C0  EF64     GOTO 0x56C8
56C2  F02B     NOP
56C4  EF6C     GOTO 0x56D8
56C6  F02B     NOP
10:            	        f2 = 0x00000000UL;
56C8  0E00     MOVLW 0x0
56CA  6E05     MOVWF 0x5, ACCESS
56CC  0E00     MOVLW 0x0
56CE  6E06     MOVWF 0x6, ACCESS
56D0  0E00     MOVLW 0x0
56D2  6E07     MOVWF 0x7, ACCESS
56D4  0E00     MOVLW 0x0
56D6  6E08     MOVWF 0x8, ACCESS
11:            	return f1 == f2;
56D8  5005     MOVF 0x5, W, ACCESS
56DA  1801     XORWF 0x1, W, ACCESS
56DC  E10F     BNZ 0x56FC
56DE  5006     MOVF 0x6, W, ACCESS
56E0  1802     XORWF 0x2, W, ACCESS
56E2  E10C     BNZ 0x56FC
56E4  5007     MOVF 0x7, W, ACCESS
56E6  1803     XORWF 0x3, W, ACCESS
56E8  E109     BNZ 0x56FC
56EA  5008     MOVF 0x8, W, ACCESS
56EC  1804     XORWF 0x4, W, ACCESS
56EE  B4D8     BTFSC 0xFD8, 2, ACCESS
56F0  EF7C     GOTO 0x56F8
56F2  F02B     NOP
56F4  EF7E     GOTO 0x56FC
56F6  F02B     NOP
56F8  EF81     GOTO 0x5702
56FA  F02B     NOP
56FC  90D8     BCF 0xFD8, 0, ACCESS
56FE  EF82     GOTO 0x5704
5700  F02B     NOP
5702  80D8     BSF 0xFD8, 0, ACCESS
12:            }
5704  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.20/pic/sources/c99/common/doprnt.c  ------------------------------
1:             /* vfprintf with configurable support for format conversions */
2:             /* This code is specifically for XC8 */
3:             #include <ctype.h>
4:             #include <math.h>
5:             #include <stdarg.h>
6:             #include <stddef.h>
7:             #include <stdint.h>
8:             #include <stdio.h>
9:             #include <stdlib.h>
10:            #include <string.h>
11:            #include <inline.h>
12:            
13:            /* Configuration options */
14:            #ifdef _VFPF_ALL
15:            #define _VFPF_CONVERT
16:            #define _VFPF_FLAGS
17:            #define _VFPF_WIDTH
18:            #define _VFPF_PRECISION
19:            
20:            #define _VFPF_HH
21:            #define _VFPF_H
22:            #define _VFPF_L
23:            #define _VFPF_LL
24:            #define _VFPF_J
25:            #define _VFPF_T
26:            #define _VFPF_Z
27:            
28:            #define _VFPF_A
29:            #define _VFPF_C
30:            #define _VFPF_D
31:            #define _VFPF_E
32:            #define _VFPF_F
33:            #define _VFPF_G
34:            #define _VFPF_O
35:            #define _VFPF_N
36:            #define _VFPF_P
37:            #define _VFPF_S
38:            #define _VFPF_U
39:            #define _VFPF_X
40:            #endif
41:            
42:            #ifndef ARRAYSIZE
43:            #define ARRAYSIZE(a)	(sizeof(a)/sizeof(a[0]))
44:            #endif
45:            #ifndef CSTRLEN
46:            #define CSTRLEN(s)	(ARRAYSIZE(s)-1)
47:            #endif
48:            
49:            /* Flags, precision, width */
50:            #define MINUS_FLAG (1 << 0)
51:            #define ZERO_FLAG (1 << 1)
52:            #define PLUS_FLAG (1 << 2)
53:            #define SPACE_FLAG (1 << 3)
54:            #define POUND_FLAG (1 << 4)
55:            static int flags, prec, width;
56:            
57:            #ifdef _VFPF_CONVERT
58:            /* This buffer must be at least 32 bytes long for this code to be safe */
59:            /* Output that would exceed buffer capacity is truncated */
60:            #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
61:            #define DBLEN 80
62:            #define EXPLEN 5
63:            #else
64:            #define DBLEN 32
65:            #endif
66:            static char dbuf[DBLEN];
67:            
68:            /* Character count */
69:            static int nout;
70:            
71:            /* Output the string in dbuf, padded on the left or right */
72:            static _INLINE int pad(FILE *fp, char *buf, int p)
5422  0105     MOVLB 0x5
73:            {
74:                int i, w;
75:            
76:                /* Left justify ? Put out string */
77:                if (flags & MINUS_FLAG) {
78:                    fputs((const char *)buf, fp);
5432  C515     MOVFF buf, s
5434  F50C     NOP
5436  C516     MOVFF 0x516, signs
5438  F50D     NOP
543A  C513     MOVFF quotient, fp
543C  F50E     NOP
543E  C514     MOVFF 0x514, bexp
5440  F50F     NOP
5442  EC3D     CALL 0x5A7A, 0
5444  F02D     NOP
79:                }
80:            
81:                /* Put out padding */
82:                w = (p < 0) ? 0 : p;
5446  BE18     BTFSC 0x18, 7, ACCESS
5448  EF28     GOTO 0x5450
544A  F02A     NOP
544C  EF2A     GOTO 0x5454
544E  F02A     NOP
5450  EF30     GOTO 0x5460
5452  F02A     NOP
5454  C517     MOVFF p, grs
5456  F51C     NOP
5458  C518     MOVFF 0x518, 0x51D
545A  F51D     NOP
545C  EF34     GOTO 0x5468
545E  F02A     NOP
5460  0E00     MOVLW 0x0
5462  6E1D     MOVWF 0x1D, ACCESS
5464  0E00     MOVLW 0x0
5466  6E1C     MOVWF 0x1C, ACCESS
83:                i = 0;
5468  0E00     MOVLW 0x0
546A  6E1B     MOVWF 0x1B, ACCESS
546C  0E00     MOVLW 0x0
546E  6E1A     MOVWF 0x1A, ACCESS
84:                while (i < w) {
5470  EF46     GOTO 0x548C
5472  F02A     NOP
548C  501C     MOVF 0x1C, W, ACCESS
548E  5C1A     SUBWF 0x1A, W, ACCESS
5490  501B     MOVF 0x1B, W, ACCESS
5492  0A80     XORLW 0x80
5494  6E19     MOVWF 0x19, ACCESS
5496  501D     MOVF 0x1D, W, ACCESS
5498  0A80     XORLW 0x80
549A  5819     SUBWFB 0x19, W, ACCESS
549C  A0D8     BTFSS 0xFD8, 0, ACCESS
549E  EF53     GOTO 0x54A6
54A0  F02A     NOP
54A2  EF55     GOTO 0x54AA
54A4  F02A     NOP
54A6  EF3A     GOTO 0x5474
54A8  F02A     NOP
85:                    fputc(' ', fp);
5474  0E00     MOVLW 0x0
5476  6E04     MOVWF 0x4, ACCESS
5478  0E20     MOVLW 0x20
547A  6E03     MOVWF 0x3, ACCESS
547C  C513     MOVFF quotient, n
547E  F505     NOP
5480  C514     MOVFF 0x514, sign
5482  F506     NOP
5484  EC83     CALL 0x5706, 0
5486  F02B     NOP
86:                    ++i;
5488  4A1A     INFSNZ 0x1A, F, ACCESS
548A  2A1B     INCF 0x1B, F, ACCESS
87:                }
88:            
89:                /* Right justify ? Put out string */
90:                if (!(flags & MINUS_FLAG)) {
54AA  0105     MOVLB 0x5
54AC  B1DF     BTFSC CLCnGLS3, 0, BANKED
54AE  EF5B     GOTO 0x54B6
54B0  F02A     NOP
54B2  EF5D     GOTO 0x54BA
54B4  F02A     NOP
54B6  EF67     GOTO 0x54CE
54B8  F02A     NOP
91:                    fputs((const char *)buf, fp);
54BA  C515     MOVFF buf, s
54BC  F50C     NOP
54BE  C516     MOVFF 0x516, signs
54C0  F50D     NOP
54C2  C513     MOVFF quotient, fp
54C4  F50E     NOP
54C6  C514     MOVFF 0x514, bexp
54C8  F50F     NOP
54CA  EC3D     CALL 0x5A7A, 0
54CC  F02D     NOP
92:                }
93:            
94:                return strlen(buf) + w;
54CE  C515     MOVFF buf, __pcstackCOMRAM
54D0  F501     NOP
54D2  C516     MOVFF 0x516, txData
54D4  F502     NOP
54D6  EC9F     CALL 0x5B3E, 0
54D8  F02D     NOP
54DA  501C     MOVF 0x1C, W, ACCESS
54DC  2401     ADDWF 0x1, W, ACCESS
54DE  6E13     MOVWF 0x13, ACCESS
54E0  501D     MOVF 0x1D, W, ACCESS
54E2  2002     ADDWFC 0x2, W, ACCESS
54E4  6E14     MOVWF 0x14, ACCESS
95:            }
54E6  0012     RETURN 0
96:            #endif
97:            
98:            #ifdef _VFPF_A
99:            static _INLINE int atoa(FILE *fp, long double f, char c)
100:           {
101:               char mode, nmode;
102:               int d, e, i, m, n, ne, p, pp, sign, t, w;
103:               long double g, h, l, ou, u;
104:           
105:               /* Record sign, get absolute value */
106:               sign = 0;
107:               g = f;
108:               if (g < 0.0) {
109:                   sign = 1;
110:                   g = -g;
111:               }
112:           
113:               /* Print sign, prefix */
114:               n = 0;
115:               w = width;
116:               if (sign || (flags & PLUS_FLAG)) {
117:                   dbuf[n] = sign ? '-' : '+';
118:                   ++n;
119:                   --w;
120:               }
121:               dbuf[n++] = '0';
122:               dbuf[n++] = isupper((int)c) ? 'X' : 'x';
123:           
124:               /* Catch infinities, NaNs here */
125:               if (isinf(g)) {
126:                   if (isupper((int)c)) {
127:                       strcpy(&dbuf[n], "INF");
128:                   } else {
129:                       strcpy(&dbuf[n], "inf");
130:                   }
131:                   w -= CSTRLEN("inf");
132:                   return pad(fp, &dbuf[0], w);
133:               }
134:               if (isnan(g)) {
135:                   if (isupper((int)c)) {
136:                       strcpy(&dbuf[n], "NAN");
137:                   } else {
138:                       strcpy(&dbuf[n], "nan");
139:                   }
140:                   w -= CSTRLEN("inf");
141:                   return pad(fp, &dbuf[0], w);
142:               }
143:           
144:               /* First find the largest power of 2 not larger than number to print */
145:               u = 1.0;
146:               e = 0;
147:               if (!(g == 0.0)) {
148:                   while (!(g < (u*2.0))) {
149:                       u = u*2.0;
150:                       ++e;
151:                   }
152:                   while (g < u) {
153:                       u = u/2.0;
154:                       --e;
155:                   }
156:               }
157:           
158:               /* Get precision */
159:               p = (prec < 0) ? 6 : prec;
160:           
161:               /* Hex places, total */
162:               m = p + 1;
163:           
164:               /* Go through the conversion once to get to the rounding step */
165:               i = 0;
166:               h = g;
167:               ou = u;
168:               while (i < m) {
169:                   l = floor(h/u);
170:                   d = (int)l;
171:                   h -= l*u;
172:                   u = u/16.0;
173:                   ++i;
174:               }
175:               
176:               /* Remainder >= halfway ? */
177:               l = u*8.0;
178:               if (h < l) {
179:                   l = 0.0;
180:               } else {
181:                   /* On tie choose even number */
182:                   if ((h == l) && !(d % 2)) {
183:                       l = 0.0;
184:                   }
185:               }
186:           
187:               /* Round */
188:               h = g + l;
189:               
190:               /* Convert again, after rounding */
191:               u = ou;
192:               ne = 0;
193:               pp = 0;
194:               t = 0;
195:               i = 0;
196:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
197:                   l = floor(h/u);
198:                   d = (int)l;
199:                   if (!(flags & POUND_FLAG) && !d && (ne < 0)) {
200:                       ++t;
201:                   } else {
202:                       if (!pp && (ne < 0)) {
203:                           dbuf[n++] = '.';
204:                           --w;
205:                           pp = 1;
206:                       }
207:                       while (t) {
208:                           dbuf[n++] = '0';
209:                           --w;
210:                           --t;
211:                       }
212:                       d = (d < 10) ? '0' + d : 'a' + (d - 10);
213:                       if (isupper((int)c) && isalpha(d)) {
214:                           d = toupper(d);
215:                       }
216:                       dbuf[n++] = d;
217:                       --w;
218:                   }
219:                   h -= l*u;
220:                   u = u/16.0;
221:                   --ne;
222:                   ++i;
223:               }
224:               if (!pp && (flags & POUND_FLAG)) {
225:                   dbuf[n++] = '.';
226:               }
227:               dbuf[n] = '\0';
228:           
229:               /* Convert exponent */
230:               i = sizeof(dbuf) - 1;
231:               dbuf[i] = '\0';
232:               sign = 0;
233:               if (e < 0) {
234:                   sign = 1;
235:                   e = -e;
236:               }
237:               p = 1;
238:               while (e || (0 < p)) {
239:                   --i;
240:                   dbuf[i] = '0' + (e % 10);
241:                   e = e / 10;
242:                   --p;
243:                   --w;
244:               }
245:               --i;
246:               dbuf[i] = sign ? '-' : '+';
247:               --w;
248:               --i;
249:               dbuf[i] = isupper((int)c) ? 'P' : 'p';
250:               --w;
251:               strcpy(&dbuf[n], &dbuf[i]);
252:           
253:               /* Put out padded string */
254:               return pad(fp, &dbuf[0], w);
255:           }
256:           #endif
257:           
258:           #ifdef _VFPF_C
259:           static _INLINE int ctoa(FILE *fp, char c)
260:           {
261:               int l, w;
262:           
263:               /* Get width */
264:               w = width ? width - 1 : width;
265:           
266:               /* Put out padded string */
267:               dbuf[0] = c;
268:               dbuf[1] = '\0';
269:               return pad(fp, &dbuf[0], w);
270:           }
271:           #endif
272:           
273:           #ifdef _VFPF_D
274:           static _INLINE int dtoa(FILE *fp, long long d)
4688  C520     MOVFF new_exp, u
275:           {
276:               int i, p, s, w;
277:               long long n;
278:           
279:               /* Record sign, get absolute value */
280:               n = d;
281:               s = n < 0 ? 1 : 0;
46A8  BE3F     BTFSC 0x3F, 7, ACCESS
46AA  EF59     GOTO 0x46B2
46AC  F023     NOP
46AE  EF5C     GOTO 0x46B8
46B0  F023     NOP
46B2  0E01     MOVLW 0x1
46B4  EF5D     GOTO 0x46BA
46B6  F023     NOP
46B8  0E00     MOVLW 0x0
46BA  6E36     MOVWF 0x36, ACCESS
46BC  6A37     CLRF 0x37, ACCESS
282:               if (s) {
46BE  5036     MOVF 0x36, W, ACCESS
46C0  1037     IORWF 0x37, W, ACCESS
46C2  B4D8     BTFSC 0xFD8, 2, ACCESS
46C4  EF66     GOTO 0x46CC
46C6  F023     NOP
46C8  EF68     GOTO 0x46D0
46CA  F023     NOP
46CC  EF78     GOTO 0x46F0
46CE  F023     NOP
283:                   n = -n;
46D0  1E3F     COMF 0x3F, F, ACCESS
46D2  1E3E     COMF 0x3E, F, ACCESS
46D4  1E3D     COMF 0x3D, F, ACCESS
46D6  1E3C     COMF 0x3C, F, ACCESS
46D8  1E3B     COMF 0x3B, F, ACCESS
46DA  1E3A     COMF CLKRCLK, F, ACCESS
46DC  1E39     COMF CLKRCON, F, ACCESS
46DE  6C38     NEGF 0x38, ACCESS
46E0  0E00     MOVLW 0x0
46E2  2239     ADDWFC CLKRCON, F, ACCESS
46E4  223A     ADDWFC CLKRCLK, F, ACCESS
46E6  223B     ADDWFC 0x3B, F, ACCESS
46E8  223C     ADDWFC 0x3C, F, ACCESS
46EA  223D     ADDWFC 0x3D, F, ACCESS
46EC  223E     ADDWFC 0x3E, F, ACCESS
46EE  223F     ADDWFC 0x3F, F, ACCESS
284:               }
285:           
286:               /* Adjust flags, precision, width */
287:               if (!(prec < 0)) {
46F0  0105     MOVLB 0x5
46F2  BFDE     BTFSC CLCnGLS2, 7, BANKED
46F4  EF7E     GOTO 0x46FC
46F6  F023     NOP
46F8  EF80     GOTO 0x4700
46FA  F023     NOP
46FC  EF81     GOTO 0x4702
46FE  F023     NOP
288:                   flags &= ~ZERO_FLAG;
4700  93DF     BCF CLCnGLS3, 1, BANKED
289:               }
290:               p = (0 < prec) ? prec : 1;
4702  BFDE     BTFSC CLCnGLS2, 7, BANKED
4704  EF8E     GOTO 0x471C
4706  F023     NOP
4708  51DE     MOVF CLCnGLS2, W, BANKED
470A  E106     BNZ 0x4718
470C  05DD     DECF CLCnGLS1, W, BANKED
470E  B0D8     BTFSC 0xFD8, 0, ACCESS
4710  EF8C     GOTO 0x4718
4712  F023     NOP
4714  EF8E     GOTO 0x471C
4716  F023     NOP
4718  EF94     GOTO 0x4728
471A  F023     NOP
471C  0E00     MOVLW 0x0
471E  6E33     MOVWF 0x33, ACCESS
4720  0E01     MOVLW 0x1
4722  6E32     MOVWF 0x32, ACCESS
4724  EF98     GOTO 0x4730
4726  F023     NOP
4728  C5DD     MOVFF prec, m
472A  F532     NOP
472C  C5DE     MOVFF 0x5DE, 0x533
472E  F533     NOP
291:               w = width;
4730  C5DB     MOVFF width, w
4732  F534     NOP
4734  C5DC     MOVFF 0x5DC, 0x535
4736  F535     NOP
292:               if (s || (flags & PLUS_FLAG)) {
4738  5036     MOVF 0x36, W, ACCESS
473A  1037     IORWF 0x37, W, ACCESS
473C  A4D8     BTFSS 0xFD8, 2, ACCESS
473E  EFA3     GOTO 0x4746
4740  F023     NOP
4742  EFA5     GOTO 0x474A
4744  F023     NOP
4746  EFAC     GOTO 0x4758
4748  F023     NOP
474A  A5DF     BTFSS CLCnGLS3, 2, BANKED
474C  EFAA     GOTO 0x4754
474E  F023     NOP
4750  EFAC     GOTO 0x4758
4752  F023     NOP
4754  EFAF     GOTO 0x475E
4756  F023     NOP
293:                   --w;
4758  0634     DECF 0x34, F, ACCESS
475A  A0D8     BTFSS 0xFD8, 0, ACCESS
475C  0635     DECF 0x35, F, ACCESS
294:               }
295:           
296:               /* Convert to decimal, possibly filling on the left with zeroes */
297:               i = sizeof(dbuf) - 1;
475E  0E00     MOVLW 0x0
4760  6E41     MOVWF NVMCON1, ACCESS
4762  0E4F     MOVLW 0x4F
4764  6E40     MOVWF NVMCON0, ACCESS
298:               dbuf[i] = '\0';
4766  0E00     MOVLW 0x0
4768  0106     MOVLB 0x6
476A  6F4F     MOVWF 0x4F, BANKED
299:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
476C  EF34     GOTO 0x4868
476E  F024     NOP
4868  BE41     BTFSC NVMCON1, 7, ACCESS
486A  EF3F     GOTO 0x487E
486C  F024     NOP
486E  5041     MOVF NVMCON1, W, ACCESS
4870  E108     BNZ 0x4882
4872  0440     DECF NVMCON0, W, ACCESS
4874  A0D8     BTFSS 0xFD8, 0, ACCESS
4876  EF3F     GOTO 0x487E
4878  F024     NOP
487A  EF41     GOTO 0x4882
487C  F024     NOP
487E  EF72     GOTO 0x48E4
4880  F024     NOP
4882  5038     MOVF 0x38, W, ACCESS
4884  1039     IORWF CLKRCON, W, ACCESS
4886  103A     IORWF CLKRCLK, W, ACCESS
4888  103B     IORWF 0x3B, W, ACCESS
488A  103C     IORWF 0x3C, W, ACCESS
488C  103D     IORWF 0x3D, W, ACCESS
488E  103E     IORWF 0x3E, W, ACCESS
4890  103F     IORWF 0x3F, W, ACCESS
4892  A4D8     BTFSS 0xFD8, 2, ACCESS
4894  EF4E     GOTO 0x489C
4896  F024     NOP
4898  EF50     GOTO 0x48A0
489A  F024     NOP
489C  EFB8     GOTO 0x4770
489E  F023     NOP
48A0  BE33     BTFSC 0x33, 7, ACCESS
48A2  EF5D     GOTO 0x48BA
48A4  F024     NOP
48A6  5033     MOVF 0x33, W, ACCESS
48A8  E106     BNZ 0x48B6
48AA  0432     DECF 0x32, W, ACCESS
48AC  B0D8     BTFSC 0xFD8, 0, ACCESS
48AE  EF5B     GOTO 0x48B6
48B0  F024     NOP
48B2  EF5D     GOTO 0x48BA
48B4  F024     NOP
48B6  EFB8     GOTO 0x4770
48B8  F023     NOP
48BA  BE35     BTFSC 0x35, 7, ACCESS
48BC  EF68     GOTO 0x48D0
48BE  F024     NOP
48C0  5035     MOVF 0x35, W, ACCESS
48C2  E108     BNZ 0x48D4
48C4  0434     DECF 0x34, W, ACCESS
48C6  A0D8     BTFSS 0xFD8, 0, ACCESS
48C8  EF68     GOTO 0x48D0
48CA  F024     NOP
48CC  EF6A     GOTO 0x48D4
48CE  F024     NOP
48D0  EF72     GOTO 0x48E4
48D2  F024     NOP
48D4  0105     MOVLB 0x5
48D6  B3DF     BTFSC CLCnGLS3, 1, BANKED
48D8  EF70     GOTO 0x48E0
48DA  F024     NOP
48DC  EF72     GOTO 0x48E4
48DE  F024     NOP
48E0  EFB8     GOTO 0x4770
48E2  F023     NOP
300:                   --i;
4770  0640     DECF NVMCON0, F, ACCESS
4772  A0D8     BTFSS 0xFD8, 0, ACCESS
4774  0641     DECF NVMCON1, F, ACCESS
301:                   dbuf[i] = '0' + abs(n % 10);
4776  0E00     MOVLW 0x0
4778  2440     ADDWF NVMCON0, W, ACCESS
477A  6ED9     MOVWF 0xFD9, ACCESS
477C  0E06     MOVLW 0x6
477E  2041     ADDWFC NVMCON1, W, ACCESS
4780  6EDA     MOVWF 0xFDA, ACCESS
4782  C538     MOVFF u, __pcstackCOMRAM
4784  F501     NOP
4786  C539     MOVFF 0x539, txData
4788  F502     NOP
478A  C53A     MOVFF 0x53A, _r
478C  F503     NOP
478E  C53B     MOVFF 0x53B, 0x504
4790  F504     NOP
4792  C53C     MOVFF fp, n
4794  F505     NOP
4796  C53D     MOVFF 0x53D, sign
4798  F506     NOP
479A  C53E     MOVFF f, s
479C  F507     NOP
479E  C53F     MOVFF 0x53F, l
47A0  F508     NOP
47A2  0E0A     MOVLW 0xA
47A4  6E09     MOVWF 0x9, ACCESS
47A6  0E00     MOVLW 0x0
47A8  6E0A     MOVWF 0xA, ACCESS
47AA  0E00     MOVLW 0x0
47AC  6E0B     MOVWF 0xB, ACCESS
47AE  0E00     MOVLW 0x0
47B0  6E0C     MOVWF 0xC, ACCESS
47B2  0E00     MOVLW 0x0
47B4  6E0D     MOVWF 0xD, ACCESS
47B6  0E00     MOVLW 0x0
47B8  6E0E     MOVWF 0xE, ACCESS
47BA  0E00     MOVLW 0x0
47BC  6E0F     MOVWF 0xF, ACCESS
47BE  0E00     MOVLW 0x0
47C0  6E10     MOVWF 0x10, ACCESS
47C2  EC5E     CALL 0x4EBC, 0
47C4  F027     NOP
47C6  C501     MOVFF __pcstackCOMRAM, x
47C8  F528     NOP
47CA  C502     MOVFF txData, 0x529
47CC  F529     NOP
47CE  C503     MOVFF _r, 0x52A
47D0  F52A     NOP
47D2  C504     MOVFF 0x504, 0x52B
47D4  F52B     NOP
47D6  C505     MOVFF n, a
47D8  F52C     NOP
47DA  C506     MOVFF sign, 0x52D
47DC  F52D     NOP
47DE  C507     MOVFF s, 0x52E
47E0  F52E     NOP
47E2  C508     MOVFF l, 0x52F
47E4  F52F     NOP
47E6  C528     MOVFF x, quotient
47E8  F513     NOP
47EA  C52A     MOVFF 0x52A, 0x514
47EC  F514     NOP
47EE  EC7F     CALL 0x5AFE, 0
47F0  F02D     NOP
47F2  5013     MOVF 0x13, W, ACCESS
47F4  0F30     ADDLW 0x30
47F6  6EDF     MOVWF 0xFDF, ACCESS
302:                   --p;
47F8  0632     DECF 0x32, F, ACCESS
47FA  A0D8     BTFSS 0xFD8, 0, ACCESS
47FC  0633     DECF 0x33, F, ACCESS
303:                   --w;
47FE  0634     DECF 0x34, F, ACCESS
4800  A0D8     BTFSS 0xFD8, 0, ACCESS
4802  0635     DECF 0x35, F, ACCESS
304:                   n = n / 10;
4804  C538     MOVFF u, __pcstackCOMRAM
4806  F501     NOP
4808  C539     MOVFF 0x539, txData
480A  F502     NOP
480C  C53A     MOVFF 0x53A, _r
480E  F503     NOP
4810  C53B     MOVFF 0x53B, 0x504
4812  F504     NOP
4814  C53C     MOVFF fp, n
4816  F505     NOP
4818  C53D     MOVFF 0x53D, sign
481A  F506     NOP
481C  C53E     MOVFF f, s
481E  F507     NOP
4820  C53F     MOVFF 0x53F, l
4822  F508     NOP
4824  0E0A     MOVLW 0xA
4826  6E09     MOVWF 0x9, ACCESS
4828  0E00     MOVLW 0x0
482A  6E0A     MOVWF 0xA, ACCESS
482C  0E00     MOVLW 0x0
482E  6E0B     MOVWF 0xB, ACCESS
4830  0E00     MOVLW 0x0
4832  6E0C     MOVWF 0xC, ACCESS
4834  0E00     MOVLW 0x0
4836  6E0D     MOVWF 0xD, ACCESS
4838  0E00     MOVLW 0x0
483A  6E0E     MOVWF 0xE, ACCESS
483C  0E00     MOVLW 0x0
483E  6E0F     MOVWF 0xF, ACCESS
4840  0E00     MOVLW 0x0
4842  6E10     MOVWF 0x10, ACCESS
4844  EC9A     CALL 0x4D34, 0
4846  F026     NOP
4848  C501     MOVFF __pcstackCOMRAM, u
484A  F538     NOP
484C  C502     MOVFF txData, 0x539
484E  F539     NOP
4850  C503     MOVFF _r, 0x53A
4852  F53A     NOP
4854  C504     MOVFF 0x504, 0x53B
4856  F53B     NOP
4858  C505     MOVFF n, fp
485A  F53C     NOP
485C  C506     MOVFF sign, 0x53D
485E  F53D     NOP
4860  C507     MOVFF s, f
4862  F53E     NOP
4864  C508     MOVFF l, 0x53F
4866  F53F     NOP
305:               }
306:           
307:               /* Display sign if required */
308:               if (s || (flags & PLUS_FLAG)) {
48E4  5036     MOVF 0x36, W, ACCESS
48E6  1037     IORWF 0x37, W, ACCESS
48E8  A4D8     BTFSS 0xFD8, 2, ACCESS
48EA  EF79     GOTO 0x48F2
48EC  F024     NOP
48EE  EF7B     GOTO 0x48F6
48F0  F024     NOP
48F2  EF83     GOTO 0x4906
48F4  F024     NOP
48F6  0105     MOVLB 0x5
48F8  A5DF     BTFSS CLCnGLS3, 2, BANKED
48FA  EF81     GOTO 0x4902
48FC  F024     NOP
48FE  EF83     GOTO 0x4906
4900  F024     NOP
4902  EFA2     GOTO 0x4944
4904  F024     NOP
309:                   --i;
4906  0640     DECF NVMCON0, F, ACCESS
4908  A0D8     BTFSS 0xFD8, 0, ACCESS
490A  0641     DECF NVMCON1, F, ACCESS
310:                   dbuf[i] = s ? '-' : '+';
490C  5036     MOVF 0x36, W, ACCESS
490E  1037     IORWF 0x37, W, ACCESS
4910  A4D8     BTFSS 0xFD8, 2, ACCESS
4912  EF8D     GOTO 0x491A
4914  F024     NOP
4916  EF8F     GOTO 0x491E
4918  F024     NOP
491A  EF95     GOTO 0x492A
491C  F024     NOP
491E  0E00     MOVLW 0x0
4920  6E31     MOVWF 0x31, ACCESS
4922  0E2B     MOVLW 0x2B
4924  6E30     MOVWF 0x30, ACCESS
4926  EF99     GOTO 0x4932
4928  F024     NOP
492A  0E00     MOVLW 0x0
492C  6E31     MOVWF 0x31, ACCESS
492E  0E2D     MOVLW 0x2D
4930  6E30     MOVWF 0x30, ACCESS
4932  0E00     MOVLW 0x0
4934  2440     ADDWF NVMCON0, W, ACCESS
4936  6ED9     MOVWF 0xFD9, ACCESS
4938  0E06     MOVLW 0x6
493A  2041     ADDWFC NVMCON1, W, ACCESS
493C  6EDA     MOVWF 0xFDA, ACCESS
4940  F4C0     NOP
4942  F4DF     NOP
311:               }
312:           
313:               /* Put out padded string */
314:               return pad(fp, &dbuf[i], w);
4944  C51E     MOVFF fp, quotient
4946  F513     NOP
4948  C51F     MOVFF sign, 0x514
494A  F514     NOP
494C  0E00     MOVLW 0x0
494E  2440     ADDWF NVMCON0, W, ACCESS
4950  6E15     MOVWF 0x15, ACCESS
4952  0E06     MOVLW 0x6
4954  2041     ADDWFC NVMCON1, W, ACCESS
4956  6E16     MOVWF 0x16, ACCESS
4958  C534     MOVFF w, p
495A  F517     NOP
495C  C535     MOVFF 0x535, 0x518
495E  F518     NOP
4960  EC11     CALL 0x5422, 0
4962  F02A     NOP
4964  C513     MOVFF quotient, fp
4966  F51E     NOP
4968  C514     MOVFF 0x514, sign
496A  F51F     NOP
315:           }
496C  0012     RETURN 0
316:           #endif
317:           
318:           #if defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
319:           static _INLINE int efgtoa(FILE *fp, long double f, char c)
253A  0E00     MOVLW 0x0
320:           {
321:               char mode, nmode;
322:               int d, e, i, m, n, ne, p, pp, sign, t, w;
323:               long double g, h, l, ou, u;
324:           
325:               /* Record sign, get absolute value */
326:               sign = 0;
327:               g = f;
2544  C53E     MOVFF f, g
2546  F58C     NOP
2548  C53F     MOVFF 0x53F, 0x58D
254A  F58D     NOP
254C  C540     MOVFF i, 0x58E
254E  F58E     NOP
2550  C541     MOVFF 0x541, 0x58F
2552  F58F     NOP
328:               if (g < 0.0) {
2554  BF8F     BTFSC SPI2TCNT, 7, BANKED
2556  EFB1     GOTO 0x2562
2558  F012     NOP
255A  EFAF     GOTO 0x255E
255C  F012     NOP
255E  EFC7     GOTO 0x258E
2560  F012     NOP
329:                   sign = 1;
2562  0E00     MOVLW 0x0
2564  6F7B     MOVWF WDTPSH, BANKED
2566  0E01     MOVLW 0x1
2568  6F7A     MOVWF WDTPS, BANKED
330:                   g = -g;
256A  C58C     MOVFF g, __pcstackCOMRAM
256C  F501     NOP
256E  C58D     MOVFF 0x58D, txData
2570  F502     NOP
2572  C58E     MOVFF 0x58E, _r
2574  F503     NOP
2576  C58F     MOVFF 0x58F, 0x504
2578  F504     NOP
257A  ECD8     CALL 0x5BB0, 0
257C  F02D     NOP
257E  C501     MOVFF __pcstackCOMRAM, g
2580  F58C     NOP
2582  C502     MOVFF txData, 0x58D
2584  F58D     NOP
2586  C503     MOVFF _r, 0x58E
2588  F58E     NOP
258A  C504     MOVFF 0x504, 0x58F
258C  F58F     NOP
331:               }
332:           
333:               /* Print sign */
334:               n = 0;
258E  0E00     MOVLW 0x0
2590  0105     MOVLB 0x5
2592  6F93     MOVWF SPI2CON2, BANKED
2594  0E00     MOVLW 0x0
2596  6F92     MOVWF SPI2CON1, BANKED
335:               w = width;
2598  C5DB     MOVFF width, w
259A  F57F     NOP
259C  C5DC     MOVFF 0x5DC, 0x580
259E  F580     NOP
336:               if (sign || (flags & PLUS_FLAG)) {
25A0  517A     MOVF WDTPS, W, BANKED
25A2  117B     IORWF WDTPSH, W, BANKED
25A4  A4D8     BTFSS 0xFD8, 2, ACCESS
25A6  EFD7     GOTO 0x25AE
25A8  F012     NOP
25AA  EFD9     GOTO 0x25B2
25AC  F012     NOP
25AE  EFE0     GOTO 0x25C0
25B0  F012     NOP
25B2  A5DF     BTFSS CLCnGLS3, 2, BANKED
25B4  EFDE     GOTO 0x25BC
25B6  F012     NOP
25B8  EFE0     GOTO 0x25C0
25BA  F012     NOP
25BC  EFFA     GOTO 0x25F4
25BE  F012     NOP
337:                   dbuf[n] = sign ? '-' : '+';
25C0  517A     MOVF WDTPS, W, BANKED
25C2  117B     IORWF WDTPSH, W, BANKED
25C4  A4D8     BTFSS 0xFD8, 2, ACCESS
25C6  EFE7     GOTO 0x25CE
25C8  F012     NOP
25CA  EFE9     GOTO 0x25D2
25CC  F012     NOP
25CE  EFEF     GOTO 0x25DE
25D0  F012     NOP
25D2  0E00     MOVLW 0x0
25D4  6F65     MOVWF PMD5, BANKED
25D6  0E2B     MOVLW 0x2B
25D8  6F64     MOVWF PMD4, BANKED
25DA  EFF3     GOTO 0x25E6
25DC  F012     NOP
25DE  0E00     MOVLW 0x0
25E0  6F65     MOVWF PMD5, BANKED
25E2  0E2D     MOVLW 0x2D
25E4  6F64     MOVWF PMD4, BANKED
25E6  C564     MOVFF 0x564, dbuf
25E8  F600     NOP
338:                   ++n;
25EA  4B92     INFSNZ SPI2CON1, F, BANKED
25EC  2B93     INCF SPI2CON2, F, BANKED
339:                   --w;
25EE  077F     DECF DAC1CON, F, BANKED
25F0  A0D8     BTFSS 0xFD8, 0, ACCESS
25F2  0780     DECF SPI1RXB, F, BANKED
340:               }
341:           
342:               /* Catch infinities, NaNs here */
343:               if (isinf(g)) {
25F4  C58C     MOVFF g, __pcstackCOMRAM
25F6  F501     NOP
25F8  C58D     MOVFF 0x58D, txData
25FA  F502     NOP
25FC  C58E     MOVFF 0x58E, _r
25FE  F503     NOP
2600  C58F     MOVFF 0x58F, 0x504
2602  F504     NOP
2604  EC15     CALL 0x522A, 0
2606  F029     NOP
2608  0401     DECF 0x1, W, ACCESS
260A  1002     IORWF 0x2, W, ACCESS
260C  A4D8     BTFSS 0xFD8, 2, ACCESS
260E  EF0B     GOTO 0x2616
2610  F013     NOP
2612  EF0D     GOTO 0x261A
2614  F013     NOP
2616  EF64     GOTO 0x26C8
2618  F013     NOP
344:                   if (isupper((int)c)) {
261A  0EBF     MOVLW 0xBF
261C  6E43     MOVWF NVMADR, ACCESS
261E  0EFF     MOVLW 0xFF
2620  6E44     MOVWF NVMADRH, ACCESS
2622  5042     MOVF NVMLOCK, W, ACCESS
2624  6E45     MOVWF NVMADRU, ACCESS
2626  6A46     CLRF NVMDAT, ACCESS
2628  5043     MOVF NVMADR, W, ACCESS
262A  2645     ADDWF NVMADRU, F, ACCESS
262C  5044     MOVF NVMADRH, W, ACCESS
262E  2246     ADDWFC NVMDAT, F, ACCESS
2630  5046     MOVF NVMDAT, W, ACCESS
2632  E10A     BNZ 0x2648
2634  0E1A     MOVLW 0x1A
2636  5C45     SUBWF NVMADRU, W, ACCESS
2638  A0D8     BTFSS 0xFD8, 0, ACCESS
263A  EF21     GOTO 0x2642
263C  F013     NOP
263E  EF24     GOTO 0x2648
2640  F013     NOP
2642  0E01     MOVLW 0x1
2644  EF25     GOTO 0x264A
2646  F013     NOP
2648  0E00     MOVLW 0x0
264A  0105     MOVLB 0x5
264C  6F66     MOVWF PMD6, BANKED
264E  6B67     CLRF PMD7, BANKED
2650  5166     MOVF PMD6, W, BANKED
2652  1167     IORWF PMD7, W, BANKED
2654  B4D8     BTFSC 0xFD8, 2, ACCESS
2656  EF2F     GOTO 0x265E
2658  F013     NOP
265A  EF31     GOTO 0x2662
265C  F013     NOP
265E  EF3F     GOTO 0x267E
2660  F013     NOP
345:                       strcpy(&dbuf[n], "INF");
2662  0E00     MOVLW 0x0
2664  2592     ADDWF SPI2CON1, W, BANKED
2666  6E01     MOVWF 0x1, ACCESS
2668  0E06     MOVLW 0x6
266A  2193     ADDWFC SPI2CON2, W, BANKED
266C  6E02     MOVWF 0x2, ACCESS
266E  0E26     MOVLW 0x26
2670  6E03     MOVWF 0x3, ACCESS
2672  0E25     MOVLW 0x25
2674  6E04     MOVWF 0x4, ACCESS
2676  EC89     CALL 0x5912, 0
2678  F02C     NOP
346:                   } else {
267A  EF4B     GOTO 0x2696
267C  F013     NOP
347:                       strcpy(&dbuf[n], "inf");
267E  0E00     MOVLW 0x0
2680  2592     ADDWF SPI2CON1, W, BANKED
2682  6E01     MOVWF 0x1, ACCESS
2684  0E06     MOVLW 0x6
2686  2193     ADDWFC SPI2CON2, W, BANKED
2688  6E02     MOVWF 0x2, ACCESS
268A  0E2E     MOVLW 0x2E
268C  6E03     MOVWF 0x3, ACCESS
268E  0E25     MOVLW 0x25
2690  6E04     MOVWF 0x4, ACCESS
2692  EC89     CALL 0x5912, 0
2694  F02C     NOP
348:                   }
349:                   w -= CSTRLEN("inf");
2696  0105     MOVLB 0x5
2698  0EFD     MOVLW 0xFD
269A  277F     ADDWF DAC1CON, F, BANKED
269C  0EFF     MOVLW 0xFF
269E  2380     ADDWFC SPI1RXB, F, BANKED
350:                   return pad(fp, &dbuf[0], w);
26A0  C53C     MOVFF fp, quotient
26A2  F513     NOP
26A4  C53D     MOVFF 0x53D, 0x514
26A6  F514     NOP
26A8  0E00     MOVLW 0x0
26AA  6E15     MOVWF 0x15, ACCESS
26AC  0E06     MOVLW 0x6
26AE  6E16     MOVWF 0x16, ACCESS
26B0  C57F     MOVFF w, p
26B2  F517     NOP
26B4  C580     MOVFF 0x580, 0x518
26B6  F518     NOP
26B8  EC11     CALL 0x5422, 0
26BA  F02A     NOP
26BC  C513     MOVFF quotient, fp
26BE  F53C     NOP
26C0  C514     MOVFF 0x514, 0x53D
26C2  F53D     NOP
26C4  EF9D     GOTO 0x313A
26C6  F018     NOP
351:               }
352:               if (isnan(g)) {
26C8  C58C     MOVFF g, __pcstackCOMRAM
26CA  F501     NOP
26CC  C58D     MOVFF 0x58D, txData
26CE  F502     NOP
26D0  C58E     MOVFF 0x58E, _r
26D2  F503     NOP
26D4  C58F     MOVFF 0x58F, 0x504
26D6  F504     NOP
26D8  EC15     CALL 0x522A, 0
26DA  F029     NOP
26DC  5001     MOVF 0x1, W, ACCESS
26DE  1002     IORWF 0x2, W, ACCESS
26E0  A4D8     BTFSS 0xFD8, 2, ACCESS
26E2  EF75     GOTO 0x26EA
26E4  F013     NOP
26E6  EF77     GOTO 0x26EE
26E8  F013     NOP
26EA  EFCE     GOTO 0x279C
26EC  F013     NOP
353:                   if (isupper((int)c)) {
26EE  0EBF     MOVLW 0xBF
26F0  6E43     MOVWF NVMADR, ACCESS
26F2  0EFF     MOVLW 0xFF
26F4  6E44     MOVWF NVMADRH, ACCESS
26F6  5042     MOVF NVMLOCK, W, ACCESS
26F8  6E45     MOVWF NVMADRU, ACCESS
26FA  6A46     CLRF NVMDAT, ACCESS
26FC  5043     MOVF NVMADR, W, ACCESS
26FE  2645     ADDWF NVMADRU, F, ACCESS
2700  5044     MOVF NVMADRH, W, ACCESS
2702  2246     ADDWFC NVMDAT, F, ACCESS
2704  5046     MOVF NVMDAT, W, ACCESS
2706  E10A     BNZ 0x271C
2708  0E1A     MOVLW 0x1A
270A  5C45     SUBWF NVMADRU, W, ACCESS
270C  A0D8     BTFSS 0xFD8, 0, ACCESS
270E  EF8B     GOTO 0x2716
2710  F013     NOP
2712  EF8E     GOTO 0x271C
2714  F013     NOP
2716  0E01     MOVLW 0x1
2718  EF8F     GOTO 0x271E
271A  F013     NOP
271C  0E00     MOVLW 0x0
271E  0105     MOVLB 0x5
2720  6F68     MOVWF PMD8, BANKED
2722  6B69     CLRF 0x69, BANKED
2724  5168     MOVF PMD8, W, BANKED
2726  1169     IORWF 0x69, W, BANKED
2728  B4D8     BTFSC 0xFD8, 2, ACCESS
272A  EF99     GOTO 0x2732
272C  F013     NOP
272E  EF9B     GOTO 0x2736
2730  F013     NOP
2732  EFA9     GOTO 0x2752
2734  F013     NOP
354:                       strcpy(&dbuf[n], "NAN");
2736  0E00     MOVLW 0x0
2738  2592     ADDWF SPI2CON1, W, BANKED
273A  6E01     MOVWF 0x1, ACCESS
273C  0E06     MOVLW 0x6
273E  2193     ADDWFC SPI2CON2, W, BANKED
2740  6E02     MOVWF 0x2, ACCESS
2742  0E2A     MOVLW 0x2A
2744  6E03     MOVWF 0x3, ACCESS
2746  0E25     MOVLW 0x25
2748  6E04     MOVWF 0x4, ACCESS
274A  EC89     CALL 0x5912, 0
274C  F02C     NOP
355:                   } else {
274E  EFB5     GOTO 0x276A
2750  F013     NOP
356:                       strcpy(&dbuf[n], "nan");
2752  0E00     MOVLW 0x0
2754  2592     ADDWF SPI2CON1, W, BANKED
2756  6E01     MOVWF 0x1, ACCESS
2758  0E06     MOVLW 0x6
275A  2193     ADDWFC SPI2CON2, W, BANKED
275C  6E02     MOVWF 0x2, ACCESS
275E  0E32     MOVLW 0x32
2760  6E03     MOVWF 0x3, ACCESS
2762  0E25     MOVLW 0x25
2764  6E04     MOVWF 0x4, ACCESS
2766  EC89     CALL 0x5912, 0
2768  F02C     NOP
357:                   }
358:                   w -= CSTRLEN("inf");
276A  0105     MOVLB 0x5
276C  0EFD     MOVLW 0xFD
276E  277F     ADDWF DAC1CON, F, BANKED
2770  0EFF     MOVLW 0xFF
2772  2380     ADDWFC SPI1RXB, F, BANKED
359:                   return pad(fp, &dbuf[0], w);
2774  C53C     MOVFF fp, quotient
2776  F513     NOP
2778  C53D     MOVFF 0x53D, 0x514
277A  F514     NOP
277C  0E00     MOVLW 0x0
277E  6E15     MOVWF 0x15, ACCESS
2780  0E06     MOVLW 0x6
2782  6E16     MOVWF 0x16, ACCESS
2784  C57F     MOVFF w, p
2786  F517     NOP
2788  C580     MOVFF 0x580, 0x518
278A  F518     NOP
278C  EC11     CALL 0x5422, 0
278E  F02A     NOP
2790  C513     MOVFF quotient, fp
2792  F53C     NOP
2794  C514     MOVFF 0x514, 0x53D
2796  F53D     NOP
2798  EF9D     GOTO 0x313A
279A  F018     NOP
360:               }
361:           
362:               /* First find the largest power of 10 not larger than number to print */
363:               u = 1.0;
279C  0E00     MOVLW 0x0
279E  0105     MOVLB 0x5
27A0  6F94     MOVWF SPI2STATUS, BANKED
27A2  0E00     MOVLW 0x0
27A4  6F95     MOVWF SPI2TWIDTH, BANKED
27A6  0E80     MOVLW 0x80
27A8  6F96     MOVWF SPI2BAUD, BANKED
27AA  0E3F     MOVLW 0x3F
27AC  6F97     MOVWF SPI2INTF, BANKED
364:               e = 0;
27AE  0E00     MOVLW 0x0
27B0  6F91     MOVWF SPI2CON0, BANKED
27B2  0E00     MOVLW 0x0
27B4  6F90     MOVWF SPI2TCNTH, BANKED
365:               if (!(g == 0.0)) {
27B6  C58C     MOVFF g, __pcstackCOMRAM
27B8  F501     NOP
27BA  C58D     MOVFF 0x58D, txData
27BC  F502     NOP
27BE  C58E     MOVFF 0x58E, _r
27C0  F503     NOP
27C2  C58F     MOVFF 0x58F, 0x504
27C4  F504     NOP
27C6  0E00     MOVLW 0x0
27C8  6E05     MOVWF 0x5, ACCESS
27CA  0E00     MOVLW 0x0
27CC  6E06     MOVWF 0x6, ACCESS
27CE  0E00     MOVLW 0x0
27D0  6E07     MOVWF 0x7, ACCESS
27D2  0E00     MOVLW 0x0
27D4  6E08     MOVWF 0x8, ACCESS
27D6  EC2E     CALL 0x565C, 0
27D8  F02B     NOP
27DA  B0D8     BTFSC 0xFD8, 0, ACCESS
27DC  EFF2     GOTO 0x27E4
27DE  F013     NOP
27E0  EFF4     GOTO 0x27E8
27E2  F013     NOP
27E4  EF77     GOTO 0x28EE
27E6  F014     NOP
27E8  EF13     GOTO 0x2826
27EA  F014     NOP
366:                   while (!(g < (u*10.0))) {
2826  C58C     MOVFF g, x
2828  F528     NOP
282A  C58D     MOVFF 0x58D, 0x529
282C  F529     NOP
282E  C58E     MOVFF 0x58E, 0x52A
2830  F52A     NOP
2832  C58F     MOVFF 0x58F, 0x52B
2834  F52B     NOP
2836  0E00     MOVLW 0x0
2838  6E13     MOVWF 0x13, ACCESS
283A  0E00     MOVLW 0x0
283C  6E14     MOVWF 0x14, ACCESS
283E  0E20     MOVLW 0x20
2840  6E15     MOVWF 0x15, ACCESS
2842  0E41     MOVLW 0x41
2844  6E16     MOVWF 0x16, ACCESS
2846  C594     MOVFF u, bexp
2848  F50F     NOP
284A  C595     MOVFF 0x595, c
284C  F510     NOP
284E  C596     MOVFF 0x596, counter
2850  F511     NOP
2852  C597     MOVFF 0x597, sign
2854  F512     NOP
2856  EC89     CALL 0x3B12, 0
2858  F01D     NOP
285A  C50F     MOVFF bexp, a
285C  F52C     NOP
285E  C510     MOVFF c, 0x52D
2860  F52D     NOP
2862  C511     MOVFF counter, 0x52E
2864  F52E     NOP
2866  C512     MOVFF sign, 0x52F
2868  F52F     NOP
286A  EC93     CALL 0x5126, 0
286C  F028     NOP
286E  B0D8     BTFSC 0xFD8, 0, ACCESS
2870  EF3C     GOTO 0x2878
2872  F014     NOP
2874  EF3E     GOTO 0x287C
2876  F014     NOP
2878  EFF6     GOTO 0x27EC
287A  F013     NOP
287C  EF5E     GOTO 0x28BC
287E  F014     NOP
367:                       u = u*10.0;
27EC  C594     MOVFF u, bexp
27EE  F50F     NOP
27F0  C595     MOVFF 0x595, c
27F2  F510     NOP
27F4  C596     MOVFF 0x596, counter
27F6  F511     NOP
27F8  C597     MOVFF 0x597, sign
27FA  F512     NOP
27FC  0E00     MOVLW 0x0
27FE  6E13     MOVWF 0x13, ACCESS
2800  0E00     MOVLW 0x0
2802  6E14     MOVWF 0x14, ACCESS
2804  0E20     MOVLW 0x20
2806  6E15     MOVWF 0x15, ACCESS
2808  0E41     MOVLW 0x41
280A  6E16     MOVWF 0x16, ACCESS
280C  EC89     CALL 0x3B12, 0
280E  F01D     NOP
2810  C50F     MOVFF bexp, u
2812  F594     NOP
2814  C510     MOVFF c, 0x595
2816  F595     NOP
2818  C511     MOVFF counter, 0x596
281A  F596     NOP
281C  C512     MOVFF sign, 0x597
281E  F597     NOP
368:                       ++e;
2820  0105     MOVLB 0x5
2822  4B90     INFSNZ SPI2TCNTH, F, BANKED
2824  2B91     INCF SPI2CON0, F, BANKED
369:                   }
370:                   while (g < u) {
28BC  C58C     MOVFF g, x
28BE  F528     NOP
28C0  C58D     MOVFF 0x58D, 0x529
28C2  F529     NOP
28C4  C58E     MOVFF 0x58E, 0x52A
28C6  F52A     NOP
28C8  C58F     MOVFF 0x58F, 0x52B
28CA  F52B     NOP
28CC  C594     MOVFF u, a
28CE  F52C     NOP
28D0  C595     MOVFF 0x595, 0x52D
28D2  F52D     NOP
28D4  C596     MOVFF 0x596, 0x52E
28D6  F52E     NOP
28D8  C597     MOVFF 0x597, 0x52F
28DA  F52F     NOP
28DC  EC93     CALL 0x5126, 0
28DE  F028     NOP
28E0  A0D8     BTFSS 0xFD8, 0, ACCESS
28E2  EF75     GOTO 0x28EA
28E4  F014     NOP
28E6  EF77     GOTO 0x28EE
28E8  F014     NOP
28EA  EF40     GOTO 0x2880
28EC  F014     NOP
371:                       u = u/10.0;
2880  C594     MOVFF u, bexp
2882  F50F     NOP
2884  C595     MOVFF 0x595, c
2886  F510     NOP
2888  C596     MOVFF 0x596, counter
288A  F511     NOP
288C  C597     MOVFF 0x597, sign
288E  F512     NOP
2890  0E00     MOVLW 0x0
2892  6E13     MOVWF 0x13, ACCESS
2894  0E00     MOVLW 0x0
2896  6E14     MOVWF 0x14, ACCESS
2898  0E20     MOVLW 0x20
289A  6E15     MOVWF 0x15, ACCESS
289C  0E41     MOVLW 0x41
289E  6E16     MOVWF 0x16, ACCESS
28A0  ECB0     CALL 0x3F60, 0
28A2  F01F     NOP
28A4  C50F     MOVFF bexp, u
28A6  F594     NOP
28A8  C510     MOVFF c, 0x595
28AA  F595     NOP
28AC  C511     MOVFF counter, 0x596
28AE  F596     NOP
28B0  C512     MOVFF sign, 0x597
28B2  F597     NOP
372:                       --e;
28B4  0105     MOVLB 0x5
28B6  0790     DECF SPI2TCNTH, F, BANKED
28B8  A0D8     BTFSS 0xFD8, 0, ACCESS
28BA  0791     DECF SPI2CON0, F, BANKED
373:                   }
374:               }
375:           
376:               /* Get mode, precision */
377:               mode = tolower((int)c);
28EE  C542     MOVFF c, s
28F0  F507     NOP
28F2  6A08     CLRF 0x8, ACCESS
28F4  ECBC     CALL 0x5978, 0
28F6  F02C     NOP
28F8  5007     MOVF 0x7, W, ACCESS
28FA  0105     MOVLB 0x5
28FC  6F81     MOVWF SPI1TXB, BANKED
378:               nmode = mode;
28FE  C581     MOVFF mode, nmode
2900  F57E     NOP
379:               if (mode == 'g') {
2902  0E67     MOVLW 0x67
2904  1981     XORWF SPI1TXB, W, BANKED
2906  A4D8     BTFSS 0xFD8, 2, ACCESS
2908  EF88     GOTO 0x2910
290A  F014     NOP
290C  EF8A     GOTO 0x2914
290E  F014     NOP
2910  EFB0     GOTO 0x2960
2912  F014     NOP
380:           		if (prec == 0) {
2914  51DD     MOVF CLCnGLS1, W, BANKED
2916  11DE     IORWF CLCnGLS2, W, BANKED
2918  A4D8     BTFSS 0xFD8, 2, ACCESS
291A  EF91     GOTO 0x2922
291C  F014     NOP
291E  EF93     GOTO 0x2926
2920  F014     NOP
2922  EF97     GOTO 0x292E
2924  F014     NOP
381:           			prec = 1;
2926  0E00     MOVLW 0x0
2928  6FDE     MOVWF CLCnGLS2, BANKED
292A  0E01     MOVLW 0x1
292C  6FDD     MOVWF CLCnGLS1, BANKED
382:           		}
383:                   p = (0 < prec) ? prec : 6;
292E  BFDE     BTFSC CLCnGLS2, 7, BANKED
2930  EFA4     GOTO 0x2948
2932  F014     NOP
2934  51DE     MOVF CLCnGLS2, W, BANKED
2936  E106     BNZ 0x2944
2938  05DD     DECF CLCnGLS1, W, BANKED
293A  B0D8     BTFSC 0xFD8, 0, ACCESS
293C  EFA2     GOTO 0x2944
293E  F014     NOP
2940  EFA4     GOTO 0x2948
2942  F014     NOP
2944  EFAA     GOTO 0x2954
2946  F014     NOP
2948  0E00     MOVLW 0x0
294A  6F7D     MOVWF DAC1DAT, BANKED
294C  0E06     MOVLW 0x6
294E  6F7C     MOVWF WDTTMR, BANKED
2950  EFB9     GOTO 0x2972
2952  F014     NOP
2954  C5DD     MOVFF prec, p
2956  F57C     NOP
2958  C5DE     MOVFF 0x5DE, 0x57D
295A  F57D     NOP
295C  EFB9     GOTO 0x2972
295E  F014     NOP
384:               } else {
385:                   p = (prec < 0) ? 6 : prec;
2960  BFDE     BTFSC CLCnGLS2, 7, BANKED
2962  EFB5     GOTO 0x296A
2964  F014     NOP
2966  EFB7     GOTO 0x296E
2968  F014     NOP
296A  EFA4     GOTO 0x2948
296C  F014     NOP
296E  EFAA     GOTO 0x2954
2970  F014     NOP
386:               }
387:           
388:               /* Choose e or f mode from g mode */
389:               if (mode == 'g') {
2972  0E67     MOVLW 0x67
2974  1981     XORWF SPI1TXB, W, BANKED
2976  A4D8     BTFSS 0xFD8, 2, ACCESS
2978  EFC0     GOTO 0x2980
297A  F014     NOP
297C  EFC2     GOTO 0x2984
297E  F014     NOP
2980  EFF1     GOTO 0x29E2
2982  F014     NOP
390:                   if (!(e < -4) && !((p - 1) < e)) {
2984  AF91     BTFSS SPI2CON0, 7, BANKED
2986  EFD0     GOTO 0x29A0
2988  F014     NOP
298A  0EFC     MOVLW 0xFC
298C  5D90     SUBWF SPI2TCNTH, W, BANKED
298E  0EFF     MOVLW 0xFF
2990  5991     SUBWFB SPI2CON0, W, BANKED
2992  A0D8     BTFSS 0xFD8, 0, ACCESS
2994  EFCE     GOTO 0x299C
2996  F014     NOP
2998  EFD0     GOTO 0x29A0
299A  F014     NOP
299C  EFEF     GOTO 0x29DE
299E  F014     NOP
29A0  0EFF     MOVLW 0xFF
29A2  6E43     MOVWF NVMADR, ACCESS
29A4  0EFF     MOVLW 0xFF
29A6  6E44     MOVWF NVMADRH, ACCESS
29A8  C57C     MOVFF p, 0x545
29AA  F545     NOP
29AC  C57D     MOVFF 0x57D, 0x546
29AE  F546     NOP
29B0  5043     MOVF NVMADR, W, ACCESS
29B2  2645     ADDWF NVMADRU, F, ACCESS
29B4  5044     MOVF NVMADRH, W, ACCESS
29B6  2246     ADDWFC NVMDAT, F, ACCESS
29B8  5190     MOVF SPI2TCNTH, W, BANKED
29BA  5C45     SUBWF NVMADRU, W, ACCESS
29BC  5046     MOVF NVMDAT, W, ACCESS
29BE  0A80     XORLW 0x80
29C0  6E47     MOVWF NVMDATH, ACCESS
29C2  5191     MOVF SPI2CON0, W, BANKED
29C4  0A80     XORLW 0x80
29C6  5847     SUBWFB NVMDATH, W, ACCESS
29C8  A0D8     BTFSS 0xFD8, 0, ACCESS
29CA  EFE9     GOTO 0x29D2
29CC  F014     NOP
29CE  EFEB     GOTO 0x29D6
29D0  F014     NOP
29D2  EFEF     GOTO 0x29DE
29D4  F014     NOP
391:                       nmode = 'f';
29D6  0E66     MOVLW 0x66
29D8  6F7E     MOVWF 0x7E, BANKED
392:                   } else {
29DA  EFF1     GOTO 0x29E2
29DC  F014     NOP
393:                       nmode = 'e';
29DE  0E65     MOVLW 0x65
29E0  6F7E     MOVWF 0x7E, BANKED
394:                   }
395:               }
396:           
397:               /* Decimal places or significant digits */
398:               m = p;
29E2  C57C     MOVFF p, m
29E4  F574     NOP
29E6  C57D     MOVFF 0x57D, 0x575
29E8  F575     NOP
399:               if (!(mode == 'g') || ((nmode == 'f') && (e < 0))) {
29EA  0E67     MOVLW 0x67
29EC  1981     XORWF SPI1TXB, W, BANKED
29EE  A4D8     BTFSS 0xFD8, 2, ACCESS
29F0  EFFC     GOTO 0x29F8
29F2  F014     NOP
29F4  EFFE     GOTO 0x29FC
29F6  F014     NOP
29F8  EF0E     GOTO 0x2A1C
29FA  F015     NOP
29FC  0E66     MOVLW 0x66
29FE  197E     XORWF 0x7E, W, BANKED
2A00  A4D8     BTFSS 0xFD8, 2, ACCESS
2A02  EF05     GOTO 0x2A0A
2A04  F015     NOP
2A06  EF07     GOTO 0x2A0E
2A08  F015     NOP
2A0A  EF10     GOTO 0x2A20
2A0C  F015     NOP
2A0E  BF91     BTFSC SPI2CON0, 7, BANKED
2A10  EF0E     GOTO 0x2A1C
2A12  F015     NOP
2A14  EF0C     GOTO 0x2A18
2A16  F015     NOP
2A18  EF10     GOTO 0x2A20
2A1A  F015     NOP
400:                   ++m;
2A1C  4B74     INFSNZ CM2CON0, F, BANKED
2A1E  2B75     INCF CM2CON1, F, BANKED
401:               }
402:           
403:               /* Adjust starting exponent, string length for 'f' conversions */
404:               if (nmode == 'f') {
2A20  0E66     MOVLW 0x66
2A22  197E     XORWF 0x7E, W, BANKED
2A24  A4D8     BTFSS 0xFD8, 2, ACCESS
2A26  EF17     GOTO 0x2A2E
2A28  F015     NOP
2A2A  EF19     GOTO 0x2A32
2A2C  F015     NOP
2A2E  EF39     GOTO 0x2A72
2A30  F015     NOP
405:                   if (e < 0) {
2A32  BF91     BTFSC SPI2CON0, 7, BANKED
2A34  EF20     GOTO 0x2A40
2A36  F015     NOP
2A38  EF1E     GOTO 0x2A3C
2A3A  F015     NOP
2A3C  EF2C     GOTO 0x2A58
2A3E  F015     NOP
406:                       u = 1.0;
2A40  0E00     MOVLW 0x0
2A42  6F94     MOVWF SPI2STATUS, BANKED
2A44  0E00     MOVLW 0x0
2A46  6F95     MOVWF SPI2TWIDTH, BANKED
2A48  0E80     MOVLW 0x80
2A4A  6F96     MOVWF SPI2BAUD, BANKED
2A4C  0E3F     MOVLW 0x3F
2A4E  6F97     MOVWF SPI2INTF, BANKED
407:                       e = 0;
2A50  0E00     MOVLW 0x0
2A52  6F91     MOVWF SPI2CON0, BANKED
2A54  0E00     MOVLW 0x0
2A56  6F90     MOVWF SPI2TCNTH, BANKED
408:                   }
409:                   if (!(mode == 'g')) {
2A58  0E67     MOVLW 0x67
2A5A  1981     XORWF SPI1TXB, W, BANKED
2A5C  B4D8     BTFSC 0xFD8, 2, ACCESS
2A5E  EF33     GOTO 0x2A66
2A60  F015     NOP
2A62  EF35     GOTO 0x2A6A
2A64  F015     NOP
2A66  EF39     GOTO 0x2A72
2A68  F015     NOP
410:                       m += e;
2A6A  5190     MOVF SPI2TCNTH, W, BANKED
2A6C  2774     ADDWF CM2CON0, F, BANKED
2A6E  5191     MOVF SPI2CON0, W, BANKED
2A70  2375     ADDWFC CM2CON1, F, BANKED
411:                   }
412:               }
413:           
414:               /* Go through the conversion once to get to the rounding step */
415:               i = 0;
2A72  0E00     MOVLW 0x0
2A74  6F8B     MOVWF SPI1INTE, BANKED
2A76  0E00     MOVLW 0x0
2A78  6F8A     MOVWF SPI1INTF, BANKED
416:               h = g;
2A7A  C58C     MOVFF g, h
2A7C  F582     NOP
2A7E  C58D     MOVFF 0x58D, 0x583
2A80  F583     NOP
2A82  C58E     MOVFF 0x58E, 0x584
2A84  F584     NOP
2A86  C58F     MOVFF 0x58F, 0x585
2A88  F585     NOP
417:               ou = u;
2A8A  C594     MOVFF u, __pcstackBANK5
2A8C  F560     NOP
2A8E  C595     MOVFF 0x595, 0x561
2A90  F561     NOP
2A92  C596     MOVFF 0x596, 0x562
2A94  F562     NOP
2A96  C597     MOVFF 0x597, 0x563
2A98  F563     NOP
418:               while (i < m) {
2A9A  EFCA     GOTO 0x2B94
2A9C  F015     NOP
2B94  5174     MOVF CM2CON0, W, BANKED
2B96  5D8A     SUBWF SPI1INTF, W, BANKED
2B98  518B     MOVF SPI1INTE, W, BANKED
2B9A  0A80     XORLW 0x80
2B9C  6E43     MOVWF NVMADR, ACCESS
2B9E  5175     MOVF CM2CON1, W, BANKED
2BA0  0A80     XORLW 0x80
2BA2  5843     SUBWFB NVMADR, W, ACCESS
2BA4  A0D8     BTFSS 0xFD8, 0, ACCESS
2BA6  EFD7     GOTO 0x2BAE
2BA8  F015     NOP
2BAA  EFD9     GOTO 0x2BB2
2BAC  F015     NOP
2BAE  EF4F     GOTO 0x2A9E
2BB0  F015     NOP
419:                   l = floor(h/u);
2A9E  C582     MOVFF h, bexp
2AA0  F50F     NOP
2AA2  C583     MOVFF 0x583, c
2AA4  F510     NOP
2AA6  C584     MOVFF 0x584, counter
2AA8  F511     NOP
2AAA  C585     MOVFF 0x585, sign
2AAC  F512     NOP
2AAE  C594     MOVFF u, quotient
2AB0  F513     NOP
2AB2  C595     MOVFF 0x595, 0x514
2AB4  F514     NOP
2AB6  C596     MOVFF 0x596, buf
2AB8  F515     NOP
2ABA  C597     MOVFF 0x597, 0x516
2ABC  F516     NOP
2ABE  ECB0     CALL 0x3F60, 0
2AC0  F01F     NOP
2AC2  C50F     MOVFF bexp, x
2AC4  F528     NOP
2AC6  C510     MOVFF c, 0x529
2AC8  F529     NOP
2ACA  C511     MOVFF counter, 0x52A
2ACC  F52A     NOP
2ACE  C512     MOVFF sign, 0x52B
2AD0  F52B     NOP
2AD2  ECB7     CALL 0x496E, 0
2AD4  F024     NOP
2AD6  C528     MOVFF x, l
2AD8  F586     NOP
2ADA  C529     MOVFF 0x529, 0x587
2ADC  F587     NOP
2ADE  C52A     MOVFF 0x52A, 0x588
2AE0  F588     NOP
2AE2  C52B     MOVFF 0x52B, 0x589
2AE4  F589     NOP
420:                   d = (int)l;
2AE6  C586     MOVFF l, x
2AE8  F528     NOP
2AEA  C587     MOVFF 0x587, 0x529
2AEC  F529     NOP
2AEE  C588     MOVFF 0x588, 0x52A
2AF0  F52A     NOP
2AF2  C589     MOVFF 0x589, 0x52B
2AF4  F52B     NOP
2AF6  EC10     CALL 0x5020, 0
2AF8  F028     NOP
2AFA  C528     MOVFF x, d
2AFC  F578     NOP
2AFE  C529     MOVFF 0x529, 0x579
2B00  F579     NOP
421:                   h -= l*u;
2B02  C582     MOVFF h, x
2B04  F528     NOP
2B06  C583     MOVFF 0x583, 0x529
2B08  F529     NOP
2B0A  C584     MOVFF 0x584, 0x52A
2B0C  F52A     NOP
2B0E  C585     MOVFF 0x585, 0x52B
2B10  F52B     NOP
2B12  C594     MOVFF u, quotient
2B14  F513     NOP
2B16  C595     MOVFF 0x595, 0x514
2B18  F514     NOP
2B1A  C596     MOVFF 0x596, buf
2B1C  F515     NOP
2B1E  C597     MOVFF 0x597, 0x516
2B20  F516     NOP
2B22  C586     MOVFF l, bexp
2B24  F50F     NOP
2B26  C587     MOVFF 0x587, c
2B28  F510     NOP
2B2A  C588     MOVFF 0x588, counter
2B2C  F511     NOP
2B2E  C589     MOVFF 0x589, sign
2B30  F512     NOP
2B32  EC89     CALL 0x3B12, 0
2B34  F01D     NOP
2B36  C50F     MOVFF bexp, a
2B38  F52C     NOP
2B3A  C510     MOVFF c, 0x52D
2B3C  F52D     NOP
2B3E  C511     MOVFF counter, 0x52E
2B40  F52E     NOP
2B42  C512     MOVFF sign, 0x52F
2B44  F52F     NOP
2B46  EC1A     CALL 0x5A34, 0
2B48  F02D     NOP
2B4A  C528     MOVFF x, h
2B4C  F582     NOP
2B4E  C529     MOVFF 0x529, 0x583
2B50  F583     NOP
2B52  C52A     MOVFF 0x52A, 0x584
2B54  F584     NOP
2B56  C52B     MOVFF 0x52B, 0x585
2B58  F585     NOP
422:                   u = u/10.0;
2B5A  C594     MOVFF u, bexp
2B5C  F50F     NOP
2B5E  C595     MOVFF 0x595, c
2B60  F510     NOP
2B62  C596     MOVFF 0x596, counter
2B64  F511     NOP
2B66  C597     MOVFF 0x597, sign
2B68  F512     NOP
2B6A  0E00     MOVLW 0x0
2B6C  6E13     MOVWF 0x13, ACCESS
2B6E  0E00     MOVLW 0x0
2B70  6E14     MOVWF 0x14, ACCESS
2B72  0E20     MOVLW 0x20
2B74  6E15     MOVWF 0x15, ACCESS
2B76  0E41     MOVLW 0x41
2B78  6E16     MOVWF 0x16, ACCESS
2B7A  ECB0     CALL 0x3F60, 0
2B7C  F01F     NOP
2B7E  C50F     MOVFF bexp, u
2B80  F594     NOP
2B82  C510     MOVFF c, 0x595
2B84  F595     NOP
2B86  C511     MOVFF counter, 0x596
2B88  F596     NOP
2B8A  C512     MOVFF sign, 0x597
2B8C  F597     NOP
423:                   ++i;
2B8E  0105     MOVLB 0x5
2B90  4B8A     INFSNZ SPI1INTF, F, BANKED
2B92  2B8B     INCF SPI1INTE, F, BANKED
424:               }
425:               
426:               /* Remainder >= halfway ? */
427:               l = u*5.0;
2BB2  C594     MOVFF u, bexp
2BB4  F50F     NOP
2BB6  C595     MOVFF 0x595, c
2BB8  F510     NOP
2BBA  C596     MOVFF 0x596, counter
2BBC  F511     NOP
2BBE  C597     MOVFF 0x597, sign
2BC0  F512     NOP
2BC2  0E00     MOVLW 0x0
2BC4  6E13     MOVWF 0x13, ACCESS
2BC6  0E00     MOVLW 0x0
2BC8  6E14     MOVWF 0x14, ACCESS
2BCA  0EA0     MOVLW 0xA0
2BCC  6E15     MOVWF 0x15, ACCESS
2BCE  0E40     MOVLW 0x40
2BD0  6E16     MOVWF 0x16, ACCESS
2BD2  EC89     CALL 0x3B12, 0
2BD4  F01D     NOP
2BD6  C50F     MOVFF bexp, l
2BD8  F586     NOP
2BDA  C510     MOVFF c, 0x587
2BDC  F587     NOP
2BDE  C511     MOVFF counter, 0x588
2BE0  F588     NOP
2BE2  C512     MOVFF sign, 0x589
2BE4  F589     NOP
428:               if (h < l) {
2BE6  C582     MOVFF h, x
2BE8  F528     NOP
2BEA  C583     MOVFF 0x583, 0x529
2BEC  F529     NOP
2BEE  C584     MOVFF 0x584, 0x52A
2BF0  F52A     NOP
2BF2  C585     MOVFF 0x585, 0x52B
2BF4  F52B     NOP
2BF6  C586     MOVFF l, a
2BF8  F52C     NOP
2BFA  C587     MOVFF 0x587, 0x52D
2BFC  F52D     NOP
2BFE  C588     MOVFF 0x588, 0x52E
2C00  F52E     NOP
2C02  C589     MOVFF 0x589, 0x52F
2C04  F52F     NOP
2C06  EC93     CALL 0x5126, 0
2C08  F028     NOP
2C0A  B0D8     BTFSC 0xFD8, 0, ACCESS
2C0C  EF0A     GOTO 0x2C14
2C0E  F016     NOP
2C10  EF0C     GOTO 0x2C18
2C12  F016     NOP
2C14  EF17     GOTO 0x2C2E
2C16  F016     NOP
429:                   l = 0.0;
2C18  0E00     MOVLW 0x0
2C1A  0105     MOVLB 0x5
2C1C  6F86     MOVWF SPI1CON2, BANKED
2C1E  0E00     MOVLW 0x0
2C20  6F87     MOVWF SPI1STATUS, BANKED
2C22  0E00     MOVLW 0x0
2C24  6F88     MOVWF SPI1TWIDTH, BANKED
2C26  0E00     MOVLW 0x0
2C28  6F89     MOVWF SPI1BAUD, BANKED
430:               } else {
2C2A  EF40     GOTO 0x2C80
2C2C  F016     NOP
431:                   /* On tie choose even number */
432:                   if ((h == l) && !(d % 2)) {
2C2E  C582     MOVFF h, __pcstackCOMRAM
2C30  F501     NOP
2C32  C583     MOVFF 0x583, txData
2C34  F502     NOP
2C36  C584     MOVFF 0x584, _r
2C38  F503     NOP
2C3A  C585     MOVFF 0x585, 0x504
2C3C  F504     NOP
2C3E  C586     MOVFF l, n
2C40  F505     NOP
2C42  C587     MOVFF 0x587, sign
2C44  F506     NOP
2C46  C588     MOVFF 0x588, s
2C48  F507     NOP
2C4A  C589     MOVFF 0x589, l
2C4C  F508     NOP
2C4E  EC2E     CALL 0x565C, 0
2C50  F02B     NOP
2C52  A0D8     BTFSS 0xFD8, 0, ACCESS
2C54  EF2E     GOTO 0x2C5C
2C56  F016     NOP
2C58  EF30     GOTO 0x2C60
2C5A  F016     NOP
2C5C  EF40     GOTO 0x2C80
2C5E  F016     NOP
2C60  0105     MOVLB 0x5
2C62  B178     BTFSC WDTCON0, 0, BANKED
2C64  EF36     GOTO 0x2C6C
2C66  F016     NOP
2C68  EF38     GOTO 0x2C70
2C6A  F016     NOP
2C6C  EF40     GOTO 0x2C80
2C6E  F016     NOP
433:                       l = 0.0;
2C70  0E00     MOVLW 0x0
2C72  6F86     MOVWF SPI1CON2, BANKED
2C74  0E00     MOVLW 0x0
2C76  6F87     MOVWF SPI1STATUS, BANKED
2C78  0E00     MOVLW 0x0
2C7A  6F88     MOVWF SPI1TWIDTH, BANKED
2C7C  0E00     MOVLW 0x0
2C7E  6F89     MOVWF SPI1BAUD, BANKED
434:                   }
435:               }
436:           
437:               /* Round */
438:               h = g + l;
2C80  C58C     MOVFF g, __pcstackCOMRAM
2C82  F501     NOP
2C84  C58D     MOVFF 0x58D, txData
2C86  F502     NOP
2C88  C58E     MOVFF 0x58E, _r
2C8A  F503     NOP
2C8C  C58F     MOVFF 0x58F, 0x504
2C8E  F504     NOP
2C90  C586     MOVFF l, n
2C92  F505     NOP
2C94  C587     MOVFF 0x587, sign
2C96  F506     NOP
2C98  C588     MOVFF 0x588, s
2C9A  F507     NOP
2C9C  C589     MOVFF 0x589, l
2C9E  F508     NOP
2CA0  EC29     CALL 0x3652, 0
2CA2  F01B     NOP
2CA4  C501     MOVFF __pcstackCOMRAM, h
2CA6  F582     NOP
2CA8  C502     MOVFF txData, 0x583
2CAA  F583     NOP
2CAC  C503     MOVFF _r, 0x584
2CAE  F584     NOP
2CB0  C504     MOVFF 0x504, 0x585
2CB2  F585     NOP
439:               
440:               /* Convert again, after rounding */
441:               u = ou;
2CB4  C560     MOVFF __pcstackBANK5, u
2CB6  F594     NOP
2CB8  C561     MOVFF 0x561, 0x595
2CBA  F595     NOP
2CBC  C562     MOVFF 0x562, 0x596
2CBE  F596     NOP
2CC0  C563     MOVFF 0x563, 0x597
2CC2  F597     NOP
442:               ne = (nmode == 'e') ? 0 : e;
2CC4  0E65     MOVLW 0x65
2CC6  0105     MOVLB 0x5
2CC8  197E     XORWF 0x7E, W, BANKED
2CCA  B4D8     BTFSC 0xFD8, 2, ACCESS
2CCC  EF6A     GOTO 0x2CD4
2CCE  F016     NOP
2CD0  EF6C     GOTO 0x2CD8
2CD2  F016     NOP
2CD4  EF72     GOTO 0x2CE4
2CD6  F016     NOP
2CD8  C590     MOVFF e, ne
2CDA  F576     NOP
2CDC  C591     MOVFF 0x591, 0x577
2CDE  F577     NOP
2CE0  EF76     GOTO 0x2CEC
2CE2  F016     NOP
2CE4  0E00     MOVLW 0x0
2CE6  6F77     MOVWF CM2PCH, BANKED
2CE8  0E00     MOVLW 0x0
2CEA  6F76     MOVWF CM2NCH, BANKED
443:               pp = 0;
2CEC  0E00     MOVLW 0x0
2CEE  6F73     MOVWF CM1PCH, BANKED
2CF0  0E00     MOVLW 0x0
2CF2  6F72     MOVWF CM1NCH, BANKED
444:               t = 0;
2CF4  0E00     MOVLW 0x0
2CF6  6F71     MOVWF CM1CON1, BANKED
2CF8  0E00     MOVLW 0x0
2CFA  6F70     MOVWF CM1CON0, BANKED
445:               i = 0;
2CFC  0E00     MOVLW 0x0
2CFE  6F8B     MOVWF SPI1INTE, BANKED
2D00  0E00     MOVLW 0x0
2D02  6F8A     MOVWF SPI1INTF, BANKED
446:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
2D04  EF71     GOTO 0x2EE2
2D06  F017     NOP
2EE2  5174     MOVF CM2CON0, W, BANKED
2EE4  5D8A     SUBWF SPI1INTF, W, BANKED
2EE6  518B     MOVF SPI1INTE, W, BANKED
2EE8  0A80     XORLW 0x80
2EEA  6E43     MOVWF NVMADR, ACCESS
2EEC  5175     MOVF CM2CON1, W, BANKED
2EEE  0A80     XORLW 0x80
2EF0  5843     SUBWFB NVMADR, W, ACCESS
2EF2  B0D8     BTFSC 0xFD8, 0, ACCESS
2EF4  EF7E     GOTO 0x2EFC
2EF6  F017     NOP
2EF8  EF80     GOTO 0x2F00
2EFA  F017     NOP
2EFC  EF8E     GOTO 0x2F1C
2EFE  F017     NOP
2F00  BF93     BTFSC SPI2CON2, 7, BANKED
2F02  EF8C     GOTO 0x2F18
2F04  F017     NOP
2F06  5193     MOVF SPI2CON2, W, BANKED
2F08  E109     BNZ 0x2F1C
2F0A  0E4B     MOVLW 0x4B
2F0C  5D92     SUBWF SPI2CON1, W, BANKED
2F0E  A0D8     BTFSS 0xFD8, 0, ACCESS
2F10  EF8C     GOTO 0x2F18
2F12  F017     NOP
2F14  EF8E     GOTO 0x2F1C
2F16  F017     NOP
2F18  EF84     GOTO 0x2D08
2F1A  F016     NOP
447:                   l = floor(h/u);
2D08  C582     MOVFF h, bexp
2D0A  F50F     NOP
2D0C  C583     MOVFF 0x583, c
2D0E  F510     NOP
2D10  C584     MOVFF 0x584, counter
2D12  F511     NOP
2D14  C585     MOVFF 0x585, sign
2D16  F512     NOP
2D18  C594     MOVFF u, quotient
2D1A  F513     NOP
2D1C  C595     MOVFF 0x595, 0x514
2D1E  F514     NOP
2D20  C596     MOVFF 0x596, buf
2D22  F515     NOP
2D24  C597     MOVFF 0x597, 0x516
2D26  F516     NOP
2D28  ECB0     CALL 0x3F60, 0
2D2A  F01F     NOP
2D2C  C50F     MOVFF bexp, x
2D2E  F528     NOP
2D30  C510     MOVFF c, 0x529
2D32  F529     NOP
2D34  C511     MOVFF counter, 0x52A
2D36  F52A     NOP
2D38  C512     MOVFF sign, 0x52B
2D3A  F52B     NOP
2D3C  ECB7     CALL 0x496E, 0
2D3E  F024     NOP
2D40  C528     MOVFF x, l
2D42  F586     NOP
2D44  C529     MOVFF 0x529, 0x587
2D46  F587     NOP
2D48  C52A     MOVFF 0x52A, 0x588
2D4A  F588     NOP
2D4C  C52B     MOVFF 0x52B, 0x589
2D4E  F589     NOP
448:                   d = (int)l;
2D50  C586     MOVFF l, x
2D52  F528     NOP
2D54  C587     MOVFF 0x587, 0x529
2D56  F529     NOP
2D58  C588     MOVFF 0x588, 0x52A
2D5A  F52A     NOP
2D5C  C589     MOVFF 0x589, 0x52B
2D5E  F52B     NOP
2D60  EC10     CALL 0x5020, 0
2D62  F028     NOP
2D64  C528     MOVFF x, d
2D66  F578     NOP
2D68  C529     MOVFF 0x529, 0x579
2D6A  F579     NOP
449:                   if (!(flags & POUND_FLAG) && !d && (mode == 'g') && (ne < 0)) {
2D6C  0105     MOVLB 0x5
2D6E  B9DF     BTFSC CLCnGLS3, 4, BANKED
2D70  EFBC     GOTO 0x2D78
2D72  F016     NOP
2D74  EFBE     GOTO 0x2D7C
2D76  F016     NOP
2D78  EFDB     GOTO 0x2DB6
2D7A  F016     NOP
2D7C  5178     MOVF WDTCON0, W, BANKED
2D7E  1179     IORWF WDTCON1, W, BANKED
2D80  A4D8     BTFSS 0xFD8, 2, ACCESS
2D82  EFC5     GOTO 0x2D8A
2D84  F016     NOP
2D86  EFC7     GOTO 0x2D8E
2D88  F016     NOP
2D8A  EFDB     GOTO 0x2DB6
2D8C  F016     NOP
2D8E  0E67     MOVLW 0x67
2D90  1981     XORWF SPI1TXB, W, BANKED
2D92  A4D8     BTFSS 0xFD8, 2, ACCESS
2D94  EFCE     GOTO 0x2D9C
2D96  F016     NOP
2D98  EFD0     GOTO 0x2DA0
2D9A  F016     NOP
2D9C  EFDB     GOTO 0x2DB6
2D9E  F016     NOP
2DA0  BF77     BTFSC CM2PCH, 7, BANKED
2DA2  EFD7     GOTO 0x2DAE
2DA4  F016     NOP
2DA6  EFD5     GOTO 0x2DAA
2DA8  F016     NOP
2DAA  EFDB     GOTO 0x2DB6
2DAC  F016     NOP
450:                       ++t;
2DAE  4B70     INFSNZ CM1CON0, F, BANKED
2DB0  2B71     INCF CM1CON1, F, BANKED
451:                   } else {
2DB2  EF25     GOTO 0x2E4A
2DB4  F017     NOP
452:                       if (!pp && (ne < 0)) {
2DB6  5172     MOVF CM1NCH, W, BANKED
2DB8  1173     IORWF CM1PCH, W, BANKED
2DBA  A4D8     BTFSS 0xFD8, 2, ACCESS
2DBC  EFE2     GOTO 0x2DC4
2DBE  F016     NOP
2DC0  EFE4     GOTO 0x2DC8
2DC2  F016     NOP
2DC4  EF0E     GOTO 0x2E1C
2DC6  F017     NOP
2DC8  BF77     BTFSC CM2PCH, 7, BANKED
2DCA  EFEB     GOTO 0x2DD6
2DCC  F016     NOP
2DCE  EFE9     GOTO 0x2DD2
2DD0  F016     NOP
2DD2  EF0E     GOTO 0x2E1C
2DD4  F017     NOP
453:                           dbuf[n++] = '.';
2DD6  0E00     MOVLW 0x0
2DD8  2592     ADDWF SPI2CON1, W, BANKED
2DDA  6ED9     MOVWF 0xFD9, ACCESS
2DDC  0E06     MOVLW 0x6
2DDE  2193     ADDWFC SPI2CON2, W, BANKED
2DE0  6EDA     MOVWF 0xFDA, ACCESS
2DE2  0E2E     MOVLW 0x2E
2DE4  6EDF     MOVWF 0xFDF, ACCESS
2DE6  4B92     INFSNZ SPI2CON1, F, BANKED
2DE8  2B93     INCF SPI2CON2, F, BANKED
454:                           --w;
2DEA  077F     DECF DAC1CON, F, BANKED
2DEC  A0D8     BTFSS 0xFD8, 0, ACCESS
2DEE  0780     DECF SPI1RXB, F, BANKED
455:                           pp = 1;
2DF0  0E00     MOVLW 0x0
2DF2  6F73     MOVWF CM1PCH, BANKED
2DF4  0E01     MOVLW 0x1
2DF6  6F72     MOVWF CM1NCH, BANKED
2DF8  EF0E     GOTO 0x2E1C
2DFA  F017     NOP
456:                       }
457:                       while (t) {
2E1C  5170     MOVF CM1CON0, W, BANKED
2E1E  1171     IORWF CM1CON1, W, BANKED
2E20  A4D8     BTFSS 0xFD8, 2, ACCESS
2E22  EF15     GOTO 0x2E2A
2E24  F017     NOP
2E26  EF17     GOTO 0x2E2E
2E28  F017     NOP
2E2A  EFFE     GOTO 0x2DFC
2E2C  F016     NOP
458:                           dbuf[n++] = '0';
2DFC  0E00     MOVLW 0x0
2DFE  2592     ADDWF SPI2CON1, W, BANKED
2E00  6ED9     MOVWF 0xFD9, ACCESS
2E02  0E06     MOVLW 0x6
2E04  2193     ADDWFC SPI2CON2, W, BANKED
2E06  6EDA     MOVWF 0xFDA, ACCESS
2E08  0E30     MOVLW 0x30
2E0A  6EDF     MOVWF 0xFDF, ACCESS
2E0C  4B92     INFSNZ SPI2CON1, F, BANKED
2E0E  2B93     INCF SPI2CON2, F, BANKED
459:                           --w;
2E10  077F     DECF DAC1CON, F, BANKED
2E12  A0D8     BTFSS 0xFD8, 0, ACCESS
2E14  0780     DECF SPI1RXB, F, BANKED
460:                           --t;
2E16  0770     DECF CM1CON0, F, BANKED
2E18  A0D8     BTFSS 0xFD8, 0, ACCESS
2E1A  0771     DECF CM1CON1, F, BANKED
461:                       }
462:                       dbuf[n++] = '0' + d;
2E2E  0E00     MOVLW 0x0
2E30  2592     ADDWF SPI2CON1, W, BANKED
2E32  6ED9     MOVWF 0xFD9, ACCESS
2E34  0E06     MOVLW 0x6
2E36  2193     ADDWFC SPI2CON2, W, BANKED
2E38  6EDA     MOVWF 0xFDA, ACCESS
2E3A  5178     MOVF WDTCON0, W, BANKED
2E3C  0F30     ADDLW 0x30
2E3E  6EDF     MOVWF 0xFDF, ACCESS
2E40  4B92     INFSNZ SPI2CON1, F, BANKED
2E42  2B93     INCF SPI2CON2, F, BANKED
463:                       --w;
2E44  077F     DECF DAC1CON, F, BANKED
2E46  A0D8     BTFSS 0xFD8, 0, ACCESS
2E48  0780     DECF SPI1RXB, F, BANKED
464:                   }
465:                   h -= l*u;
2E4A  C582     MOVFF h, x
2E4C  F528     NOP
2E4E  C583     MOVFF 0x583, 0x529
2E50  F529     NOP
2E52  C584     MOVFF 0x584, 0x52A
2E54  F52A     NOP
2E56  C585     MOVFF 0x585, 0x52B
2E58  F52B     NOP
2E5A  C594     MOVFF u, quotient
2E5C  F513     NOP
2E5E  C595     MOVFF 0x595, 0x514
2E60  F514     NOP
2E62  C596     MOVFF 0x596, buf
2E64  F515     NOP
2E66  C597     MOVFF 0x597, 0x516
2E68  F516     NOP
2E6A  C586     MOVFF l, bexp
2E6C  F50F     NOP
2E6E  C587     MOVFF 0x587, c
2E70  F510     NOP
2E72  C588     MOVFF 0x588, counter
2E74  F511     NOP
2E76  C589     MOVFF 0x589, sign
2E78  F512     NOP
2E7A  EC89     CALL 0x3B12, 0
2E7C  F01D     NOP
2E7E  C50F     MOVFF bexp, a
2E80  F52C     NOP
2E82  C510     MOVFF c, 0x52D
2E84  F52D     NOP
2E86  C511     MOVFF counter, 0x52E
2E88  F52E     NOP
2E8A  C512     MOVFF sign, 0x52F
2E8C  F52F     NOP
2E8E  EC1A     CALL 0x5A34, 0
2E90  F02D     NOP
2E92  C528     MOVFF x, h
2E94  F582     NOP
2E96  C529     MOVFF 0x529, 0x583
2E98  F583     NOP
2E9A  C52A     MOVFF 0x52A, 0x584
2E9C  F584     NOP
2E9E  C52B     MOVFF 0x52B, 0x585
2EA0  F585     NOP
466:                   u = u/10.0;
2EA2  C594     MOVFF u, bexp
2EA4  F50F     NOP
2EA6  C595     MOVFF 0x595, c
2EA8  F510     NOP
2EAA  C596     MOVFF 0x596, counter
2EAC  F511     NOP
2EAE  C597     MOVFF 0x597, sign
2EB0  F512     NOP
2EB2  0E00     MOVLW 0x0
2EB4  6E13     MOVWF 0x13, ACCESS
2EB6  0E00     MOVLW 0x0
2EB8  6E14     MOVWF 0x14, ACCESS
2EBA  0E20     MOVLW 0x20
2EBC  6E15     MOVWF 0x15, ACCESS
2EBE  0E41     MOVLW 0x41
2EC0  6E16     MOVWF 0x16, ACCESS
2EC2  ECB0     CALL 0x3F60, 0
2EC4  F01F     NOP
2EC6  C50F     MOVFF bexp, u
2EC8  F594     NOP
2ECA  C510     MOVFF c, 0x595
2ECC  F595     NOP
2ECE  C511     MOVFF counter, 0x596
2ED0  F596     NOP
2ED2  C512     MOVFF sign, 0x597
2ED4  F597     NOP
467:                   --ne;
2ED6  0105     MOVLB 0x5
2ED8  0776     DECF CM2NCH, F, BANKED
2EDA  A0D8     BTFSS 0xFD8, 0, ACCESS
2EDC  0777     DECF CM2PCH, F, BANKED
468:                   ++i;
2EDE  4B8A     INFSNZ SPI1INTF, F, BANKED
2EE0  2B8B     INCF SPI1INTE, F, BANKED
469:               }
470:               if (!pp && (flags & POUND_FLAG)) {
2F1C  5172     MOVF CM1NCH, W, BANKED
2F1E  1173     IORWF CM1PCH, W, BANKED
2F20  A4D8     BTFSS 0xFD8, 2, ACCESS
2F22  EF95     GOTO 0x2F2A
2F24  F017     NOP
2F26  EF97     GOTO 0x2F2E
2F28  F017     NOP
2F2A  EFA8     GOTO 0x2F50
2F2C  F017     NOP
2F2E  A9DF     BTFSS CLCnGLS3, 4, BANKED
2F30  EF9C     GOTO 0x2F38
2F32  F017     NOP
2F34  EF9E     GOTO 0x2F3C
2F36  F017     NOP
2F38  EFA8     GOTO 0x2F50
2F3A  F017     NOP
471:                   dbuf[n++] = '.';
2F3C  0E00     MOVLW 0x0
2F3E  2592     ADDWF SPI2CON1, W, BANKED
2F40  6ED9     MOVWF 0xFD9, ACCESS
2F42  0E06     MOVLW 0x6
2F44  2193     ADDWFC SPI2CON2, W, BANKED
2F46  6EDA     MOVWF 0xFDA, ACCESS
2F48  0E2E     MOVLW 0x2E
2F4A  6EDF     MOVWF 0xFDF, ACCESS
2F4C  4B92     INFSNZ SPI2CON1, F, BANKED
2F4E  2B93     INCF SPI2CON2, F, BANKED
472:               }
473:               dbuf[n] = '\0';
2F50  0E00     MOVLW 0x0
2F52  2592     ADDWF SPI2CON1, W, BANKED
2F54  6ED9     MOVWF 0xFD9, ACCESS
2F56  0E06     MOVLW 0x6
2F58  2193     ADDWFC SPI2CON2, W, BANKED
2F5A  6EDA     MOVWF 0xFDA, ACCESS
2F5C  0E00     MOVLW 0x0
2F5E  6EDF     MOVWF 0xFDF, ACCESS
474:           
475:               /* Convert exponent */
476:               if (nmode == 'e') {
2F60  0E65     MOVLW 0x65
2F62  197E     XORWF 0x7E, W, BANKED
2F64  A4D8     BTFSS 0xFD8, 2, ACCESS
2F66  EFB7     GOTO 0x2F6E
2F68  F017     NOP
2F6A  EFB9     GOTO 0x2F72
2F6C  F017     NOP
2F6E  EF8B     GOTO 0x3116
2F70  F018     NOP
477:                   i = sizeof(dbuf) - 1;
2F72  0E00     MOVLW 0x0
2F74  6F8B     MOVWF SPI1INTE, BANKED
2F76  0E4F     MOVLW 0x4F
2F78  6F8A     MOVWF SPI1INTF, BANKED
478:                   dbuf[i] = '\0';
2F7A  0E00     MOVLW 0x0
2F7C  258A     ADDWF SPI1INTF, W, BANKED
2F7E  6ED9     MOVWF 0xFD9, ACCESS
2F80  0E06     MOVLW 0x6
2F82  218B     ADDWFC SPI1INTE, W, BANKED
2F84  6EDA     MOVWF 0xFDA, ACCESS
2F86  0E00     MOVLW 0x0
2F88  6EDF     MOVWF 0xFDF, ACCESS
479:                   sign = 0;
2F8A  0E00     MOVLW 0x0
2F8C  6F7B     MOVWF WDTPSH, BANKED
2F8E  0E00     MOVLW 0x0
2F90  6F7A     MOVWF WDTPS, BANKED
480:                   if (e < 0) {
2F92  BF91     BTFSC SPI2CON0, 7, BANKED
2F94  EFD0     GOTO 0x2FA0
2F96  F017     NOP
2F98  EFCE     GOTO 0x2F9C
2F9A  F017     NOP
2F9C  EFD8     GOTO 0x2FB0
2F9E  F017     NOP
481:                       sign = 1;
2FA0  0E00     MOVLW 0x0
2FA2  6F7B     MOVWF WDTPSH, BANKED
2FA4  0E01     MOVLW 0x1
2FA6  6F7A     MOVWF WDTPS, BANKED
482:                       e = -e;
2FA8  6D90     NEGF SPI2TCNTH, BANKED
2FAA  1F91     COMF SPI2CON0, F, BANKED
2FAC  B0D8     BTFSC 0xFD8, 0, ACCESS
2FAE  2B91     INCF SPI2CON0, F, BANKED
483:                   }
484:                   p = 2;
2FB0  0E00     MOVLW 0x0
2FB2  6F7D     MOVWF DAC1DAT, BANKED
2FB4  0E02     MOVLW 0x2
2FB6  6F7C     MOVWF WDTTMR, BANKED
485:                   while (e || (0 < p)) {
2FB8  EF09     GOTO 0x3012
2FBA  F018     NOP
3012  5190     MOVF SPI2TCNTH, W, BANKED
3014  1191     IORWF SPI2CON0, W, BANKED
3016  A4D8     BTFSS 0xFD8, 2, ACCESS
3018  EF10     GOTO 0x3020
301A  F018     NOP
301C  EF12     GOTO 0x3024
301E  F018     NOP
3020  EFDE     GOTO 0x2FBC
3022  F017     NOP
3024  BF7D     BTFSC DAC1DAT, 7, BANKED
3026  EF1F     GOTO 0x303E
3028  F018     NOP
302A  517D     MOVF DAC1DAT, W, BANKED
302C  E106     BNZ 0x303A
302E  057C     DECF WDTTMR, W, BANKED
3030  B0D8     BTFSC 0xFD8, 0, ACCESS
3032  EF1D     GOTO 0x303A
3034  F018     NOP
3036  EF1F     GOTO 0x303E
3038  F018     NOP
303A  EFDE     GOTO 0x2FBC
303C  F017     NOP
486:                       --i;
2FBC  078A     DECF SPI1INTF, F, BANKED
2FBE  A0D8     BTFSS 0xFD8, 0, ACCESS
2FC0  078B     DECF SPI1INTE, F, BANKED
487:                       dbuf[i] = '0' + (e % 10);
2FC2  0E00     MOVLW 0x0
2FC4  258A     ADDWF SPI1INTF, W, BANKED
2FC6  6ED9     MOVWF 0xFD9, ACCESS
2FC8  0E06     MOVLW 0x6
2FCA  218B     ADDWFC SPI1INTE, W, BANKED
2FCC  6EDA     MOVWF 0xFDA, ACCESS
2FCE  C590     MOVFF e, __pcstackCOMRAM
2FD0  F501     NOP
2FD2  C591     MOVFF 0x591, txData
2FD4  F502     NOP
2FD6  0E00     MOVLW 0x0
2FD8  6E04     MOVWF 0x4, ACCESS
2FDA  0E0A     MOVLW 0xA
2FDC  6E03     MOVWF 0x3, ACCESS
2FDE  ECD6     CALL 0x55AC, 0
2FE0  F02A     NOP
2FE2  5001     MOVF 0x1, W, ACCESS
2FE4  0F30     ADDLW 0x30
2FE6  6EDF     MOVWF 0xFDF, ACCESS
488:                       e = e / 10;
2FE8  C590     MOVFF e, s
2FEA  F507     NOP
2FEC  C591     MOVFF 0x591, l
2FEE  F508     NOP
2FF0  0E00     MOVLW 0x0
2FF2  6E0A     MOVWF 0xA, ACCESS
2FF4  0E0A     MOVLW 0xA
2FF6  6E09     MOVWF 0x9, ACCESS
2FF8  EC74     CALL 0x54E8, 0
2FFA  F02A     NOP
2FFC  C507     MOVFF s, e
2FFE  F590     NOP
3000  C508     MOVFF l, 0x591
3002  F591     NOP
489:                       --p;
3004  0105     MOVLB 0x5
3006  077C     DECF WDTTMR, F, BANKED
3008  A0D8     BTFSS 0xFD8, 0, ACCESS
300A  077D     DECF DAC1DAT, F, BANKED
490:                       --w;
300C  077F     DECF DAC1CON, F, BANKED
300E  A0D8     BTFSS 0xFD8, 0, ACCESS
3010  0780     DECF SPI1RXB, F, BANKED
491:                   }
492:                   --i;
303E  078A     DECF SPI1INTF, F, BANKED
3040  A0D8     BTFSS 0xFD8, 0, ACCESS
3042  078B     DECF SPI1INTE, F, BANKED
493:                   dbuf[i] = sign ? '-' : '+';
3044  517A     MOVF WDTPS, W, BANKED
3046  117B     IORWF WDTPSH, W, BANKED
3048  A4D8     BTFSS 0xFD8, 2, ACCESS
304A  EF29     GOTO 0x3052
304C  F018     NOP
304E  EF2B     GOTO 0x3056
3050  F018     NOP
3052  EF31     GOTO 0x3062
3054  F018     NOP
3056  0E00     MOVLW 0x0
3058  6F6B     MOVWF MD1CON1, BANKED
305A  0E2B     MOVLW 0x2B
305C  6F6A     MOVWF MD1CON0, BANKED
305E  EF35     GOTO 0x306A
3060  F018     NOP
3062  0E00     MOVLW 0x0
3064  6F6B     MOVWF MD1CON1, BANKED
3066  0E2D     MOVLW 0x2D
3068  6F6A     MOVWF MD1CON0, BANKED
306A  0E00     MOVLW 0x0
306C  258A     ADDWF SPI1INTF, W, BANKED
306E  6ED9     MOVWF 0xFD9, ACCESS
3070  0E06     MOVLW 0x6
3072  218B     ADDWFC SPI1INTE, W, BANKED
3074  6EDA     MOVWF 0xFDA, ACCESS
3078  F5A8     NOP
307A  F4DF     NOP
494:                   --w;
307C  077F     DECF DAC1CON, F, BANKED
307E  A0D8     BTFSS 0xFD8, 0, ACCESS
3080  0780     DECF SPI1RXB, F, BANKED
495:                   --i;
3082  078A     DECF SPI1INTF, F, BANKED
3084  A0D8     BTFSS 0xFD8, 0, ACCESS
3086  078B     DECF SPI1INTE, F, BANKED
496:                   dbuf[i] = isupper((int)c) ? 'E' : 'e';
3088  0EBF     MOVLW 0xBF
308A  6E43     MOVWF NVMADR, ACCESS
308C  0EFF     MOVLW 0xFF
308E  6E44     MOVWF NVMADRH, ACCESS
3090  5042     MOVF NVMLOCK, W, ACCESS
3092  6E45     MOVWF NVMADRU, ACCESS
3094  6A46     CLRF NVMDAT, ACCESS
3096  5043     MOVF NVMADR, W, ACCESS
3098  2645     ADDWF NVMADRU, F, ACCESS
309A  5044     MOVF NVMADRH, W, ACCESS
309C  2246     ADDWFC NVMDAT, F, ACCESS
309E  5046     MOVF NVMDAT, W, ACCESS
30A0  E10A     BNZ 0x30B6
30A2  0E1A     MOVLW 0x1A
30A4  5C45     SUBWF NVMADRU, W, ACCESS
30A6  A0D8     BTFSS 0xFD8, 0, ACCESS
30A8  EF58     GOTO 0x30B0
30AA  F018     NOP
30AC  EF5B     GOTO 0x30B6
30AE  F018     NOP
30B0  0E01     MOVLW 0x1
30B2  EF5C     GOTO 0x30B8
30B4  F018     NOP
30B6  0E00     MOVLW 0x0
30B8  6F6E     MOVWF MD1CARH, BANKED
30BA  6B6F     CLRF CMOUT, BANKED
30BC  516E     MOVF MD1CARH, W, BANKED
30BE  116F     IORWF CMOUT, W, BANKED
30C0  A4D8     BTFSS 0xFD8, 2, ACCESS
30C2  EF65     GOTO 0x30CA
30C4  F018     NOP
30C6  EF67     GOTO 0x30CE
30C8  F018     NOP
30CA  EF6D     GOTO 0x30DA
30CC  F018     NOP
30CE  0E00     MOVLW 0x0
30D0  6F6D     MOVWF MD1CARL, BANKED
30D2  0E65     MOVLW 0x65
30D4  6F6C     MOVWF MD1SRC, BANKED
30D6  EF71     GOTO 0x30E2
30D8  F018     NOP
30DA  0E00     MOVLW 0x0
30DC  6F6D     MOVWF MD1CARL, BANKED
30DE  0E45     MOVLW 0x45
30E0  6F6C     MOVWF MD1SRC, BANKED
30E2  0E00     MOVLW 0x0
30E4  258A     ADDWF SPI1INTF, W, BANKED
30E6  6ED9     MOVWF 0xFD9, ACCESS
30E8  0E06     MOVLW 0x6
30EA  218B     ADDWFC SPI1INTE, W, BANKED
30EC  6EDA     MOVWF 0xFDA, ACCESS
30F0  F5B0     NOP
30F2  F4DF     NOP
497:                   --w;
30F4  077F     DECF DAC1CON, F, BANKED
30F6  A0D8     BTFSS 0xFD8, 0, ACCESS
30F8  0780     DECF SPI1RXB, F, BANKED
498:                   strcpy(&dbuf[n], &dbuf[i]);
30FA  0E00     MOVLW 0x0
30FC  2592     ADDWF SPI2CON1, W, BANKED
30FE  6E01     MOVWF 0x1, ACCESS
3100  0E06     MOVLW 0x6
3102  2193     ADDWFC SPI2CON2, W, BANKED
3104  6E02     MOVWF 0x2, ACCESS
3106  0E00     MOVLW 0x0
3108  258A     ADDWF SPI1INTF, W, BANKED
310A  6E03     MOVWF 0x3, ACCESS
310C  0E06     MOVLW 0x6
310E  218B     ADDWFC SPI1INTE, W, BANKED
3110  6E04     MOVWF 0x4, ACCESS
3112  EC89     CALL 0x5912, 0
3114  F02C     NOP
499:               }
500:           
501:               /* Put out padded string */
502:               return pad(fp, &dbuf[0], w);
3116  C53C     MOVFF fp, quotient
3118  F513     NOP
311A  C53D     MOVFF 0x53D, 0x514
311C  F514     NOP
311E  0E00     MOVLW 0x0
3120  6E15     MOVWF 0x15, ACCESS
3122  0E06     MOVLW 0x6
3124  6E16     MOVWF 0x16, ACCESS
3126  C57F     MOVFF w, p
3128  F517     NOP
312A  C580     MOVFF 0x580, 0x518
312C  F518     NOP
312E  EC11     CALL 0x5422, 0
3130  F02A     NOP
3132  C513     MOVFF quotient, fp
3134  F53C     NOP
3136  C514     MOVFF 0x514, 0x53D
3138  F53D     NOP
503:           }
313A  0012     RETURN 0
504:           #endif
505:           
506:           #ifdef _VFPF_O
507:           static _INLINE int otoa(FILE *fp, unsigned long long d)
508:           {
509:               int i, p, t, w;
510:               unsigned long long n;
511:           
512:               /* Adjust flags, precision, width */
513:               if (!(prec < 0)) {
514:                   flags &= ~ZERO_FLAG;
515:               }
516:               p = (0 < prec) ? prec : 1;
517:               w = width;
518:           
519:               /* Convert to octal, possibly filling on the left with zeroes */
520:               n = d;
521:               i = sizeof(dbuf) - 1;
522:               dbuf[i] = '\0';
523:               t = 0;
524:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
525:                   --i;
526:                   t = n & 07;
527:                   dbuf[i] = '0' + t;
528:                   --p;
529:                   --w;
530:                   n = n >> 3;
531:               }
532:           
533:               /* Display prefix if required */
534:               if ((flags & POUND_FLAG) && t) {
535:                   --i;
536:                   dbuf[i] = '0';
537:                   --w;
538:               }
539:           
540:               /* Put out padded string */
541:               return pad(fp, &dbuf[i], w);
542:           }
543:           #endif
544:           
545:           #ifdef _VFPF_S
546:           static _INLINE int stoa(FILE *fp, char *s)
547:           {
548:               char *cp, nuls[] = "(null)";
549:               int i, l, p, w;
550:           
551:               /* Check for null string */
552:               cp = s;
553:               if (!cp) {
554:                   cp = nuls;
555:               }
556:           
557:               /* Get length, precision, width */
558:               l = strlen(cp);
559:               p = prec;
560:               l = (!(p < 0) && (p < l)) ? p : l;
561:               p = l;
562:               w = width;
563:           
564:               /* Right justify, pad on left ? */
565:               if (!(flags & MINUS_FLAG)) {
566:                   while (l < w) {
567:                       fputc(' ', fp);
568:                       ++l;
569:                   }
570:               }
571:           
572:               /* Put out string */
573:               i = 0;
574:               while (i < p) {
575:                   fputc(*cp, fp);
576:                   ++cp;
577:                   ++i;
578:               }
579:           
580:               /* Left justify, pad on right ? */
581:               if (flags & MINUS_FLAG) {
582:                   while (l < w) {
583:                       fputc(' ', fp);
584:                       ++l;
585:                   }
586:               }
587:           
588:               return l;
589:           }
590:           #endif
591:           
592:           #ifdef _VFPF_U
593:           static _INLINE int utoa(FILE *fp, unsigned long long d)
594:           {
595:               int i, p, w;
596:               unsigned long long n;
597:           
598:               /* Adjust flags, precision, width */
599:               if (!(prec < 0)) {
600:                   flags &= ~ZERO_FLAG;
601:               }
602:               p = (0 < prec) ? prec : 1;
603:               w = width;
604:           
605:               /* Convert to decimal, possibly filling on the left with zeroes */
606:               n = d;
607:               i = sizeof(dbuf) - 1;
608:               dbuf[i] = '\0';
609:               while (i && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
610:                   --i;
611:                   dbuf[i] = '0' + (n % 10);
612:                   --p;
613:                   --w;
614:                   n = n / 10;
615:               }
616:           
617:               /* Put out padded string */
618:               return pad(fp, &dbuf[i], w);
619:           }
620:           #endif
621:           
622:           #if defined(_VFPF_X) || defined(_VFPF_P)
623:           static _INLINE int xtoa(FILE *fp, unsigned long long d, char x)
624:           {
625:               int c, i, p, w;
626:               unsigned long long n;
627:           
628:               /* Adjust, flags, precision, width */
629:               if (!(prec < 0)) {
630:                   flags &= ~ZERO_FLAG;
631:               }
632:               p = (0 < prec) ? prec : 1;
633:               w = width;
634:               if (flags & POUND_FLAG) {
635:                   w -= 2;
636:               }
637:           
638:               /* Convert to hexadecimal, possibly filling on the left with zeroes */
639:               n = d;
640:               i = sizeof(dbuf) - 1;
641:               dbuf[i] = '\0';
642:               while (!(i < 2) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
643:                   --i;
644:                   c = n & 0x0f;
645:                   c = (c < 10) ? '0' + c : 'a' + (c - 10);
646:                   if (isupper((int)x) && isalpha(c)) {
647:                       c = toupper(c);
648:                   }
649:                   dbuf[i] = (char)c;
650:                   --p;
651:                   --w;
652:                   n = n >> 4;
653:               }
654:           
655:               /* Display prefix if required */
656:               if (flags & POUND_FLAG) {
657:                   --i;
658:                   dbuf[i] = x;
659:                   --i;
660:                   dbuf[i] = '0';
661:               }
662:           
663:               /* Put out padded string */
664:               return pad(fp, &dbuf[i], w);
665:           }
666:           #endif
667:           
668:           /* Consume and convert the next part of the format string */
669:           #ifdef _VFPF_CONVERT
670:           static _INLINE int vfpfcnvrt(FILE *fp, char *fmt[], va_list ap)
671:           {
672:               char c, *cp, ct[3];
673:               int done, i;
674:               long long ll;
675:               unsigned long long llu;
676:               long double f;
677:               void *vp;
678:           
679:               /* Conversion ? */
680:               if ((*fmt)[0] == '%') {
681:                   ++*fmt;
316A  F528     NOP
316C  F4D9     NOP
3170  F52C     NOP
3172  F4DA     NOP
3174  2ADE     INCF 0xFDE, F, ACCESS
3176  0E00     MOVLW 0x0
3178  22DD     ADDWFC 0xFDD, F, ACCESS
682:           
683:                   flags = width = 0;
317A  0E00     MOVLW 0x0
317C  0105     MOVLB 0x5
317E  6FDC     MOVWF CLCnGLS0, BANKED
3180  0E00     MOVLW 0x0
3182  6FDB     MOVWF CLCnSEL3, BANKED
3184  C5DB     MOVFF width, flags
3186  F5DF     NOP
3188  C5DC     MOVFF 0x5DC, 0x5E0
318A  F5E0     NOP
684:                   prec = -1;
318C  69DD     SETF CLCnGLS1, BANKED
318E  69DE     SETF CLCnGLS2, BANKED
685:           
686:           #ifdef _VFPF_FLAGS
687:                   /* Get flags */
688:                   done = 0;
689:                   while (!done) {
690:                       switch ((*fmt)[0]) {
691:                           case '-' :
692:                               flags |= MINUS_FLAG;
693:                               ++*fmt;
694:                               break;
695:                           case '0' :
696:                               flags |= ZERO_FLAG;
697:                               ++*fmt;
698:                               break;
699:                           case '+' :
700:                               flags |= PLUS_FLAG;
701:                               ++*fmt;
702:                               break;
703:                           case ' ' :
704:                               flags |= SPACE_FLAG;
705:                               ++*fmt;
706:                               break;
707:                           case '#' :
708:                               flags |= POUND_FLAG;
709:                               ++*fmt;
710:                               break;
711:                           default:
712:                               done = 1;
713:                               break;
714:                       }
715:                   }
716:                   if (flags & MINUS_FLAG) {
717:                       flags &= ~ZERO_FLAG;
718:                   }
719:           #endif
720:           
721:           #ifdef _VFPF_WIDTH
722:                   /* Get field width */
723:                   if ((*fmt)[0] == '*') {
724:                       ++*fmt;
725:                       width = va_arg(ap, int);
726:                       if (width < 0) {
727:                           flags |= MINUS_FLAG;
728:                           width = -width;
729:                       }
730:                   } else {
731:                       width = atoi(*fmt);
732:                       while (isdigit((*fmt)[0])) {
733:                           ++*fmt;
734:                       }
735:                   }
736:           #endif
737:           
738:           #ifdef _VFPF_PRECISION
739:                   /* Get precision */
740:                   if ((*fmt)[0] == '.') {
741:                       prec = 0;
742:                       ++*fmt;
743:                       if ((*fmt)[0] == '*') {
744:                           ++*fmt;
745:                           prec = va_arg(ap, int);
746:                       } else {
747:                           prec = atoi(*fmt);
748:                           while (isdigit((*fmt)[0])) {
749:                               ++*fmt;
750:                           }
751:                       }
752:                   }
753:           #endif
754:           
755:           #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
756:                   /* Case-folded conversion types */
757:                   ct[0] = tolower((int)(*fmt)[0]);
3192  F528     NOP
3194  F4D9     NOP
3198  F52C     NOP
319A  F4DA     NOP
319C  C4DE     MOVFF POSTINC2, TBLPTR
319E  F4F6     NOP
31A0  C4DD     MOVFF POSTDEC2, TBLPTRH
31A2  F4F7     NOP
31A4  0E00     MOVLW 0x0
31A6  6EF8     MOVWF 0xFF8, ACCESS
31A8  0008     TBLRD*
31AA  50F5     MOVF 0xFF5, W, ACCESS
31AC  6E07     MOVWF 0x7, ACCESS
31AE  6A08     CLRF 0x8, ACCESS
31B0  ECBC     CALL 0x5978, 0
31B2  F02C     NOP
31B4  5007     MOVF 0x7, W, ACCESS
31B6  0105     MOVLB 0x5
31B8  6FA6     MOVWF 0xA6, BANKED
758:                   if (ct[0]) {
31BA  51A6     MOVF 0xA6, W, BANKED
31BC  B4D8     BTFSC 0xFD8, 2, ACCESS
31BE  EFE3     GOTO 0x31C6
31C0  F018     NOP
31C2  EFE5     GOTO 0x31CA
31C4  F018     NOP
31C6  EF2F     GOTO 0x325E
31C8  F019     NOP
759:                       ct[1] = tolower((int)(*fmt)[1]);
31CC  F528     NOP
31CE  F4D9     NOP
31D2  F52C     NOP
31D4  F4DA     NOP
31D8  F378     NOP
31DA  F54E     NOP
31DE  F374     NOP
31E0  F54F     NOP
31E2  0E01     MOVLW 0x1
31E4  264E     ADDWF 0x4E, F, ACCESS
31E6  0E00     MOVLW 0x0
31E8  224F     ADDWFC 0x4F, F, ACCESS
31EC  F538     NOP
31EE  F4F6     NOP
31F2  F53C     NOP
31F4  F4F7     NOP
31F6  0E00     MOVLW 0x0
31F8  6EF8     MOVWF 0xFF8, ACCESS
31FA  0008     TBLRD*
31FC  50F5     MOVF 0xFF5, W, ACCESS
31FE  6E07     MOVWF 0x7, ACCESS
3200  6A08     CLRF 0x8, ACCESS
3202  ECBC     CALL 0x5978, 0
3204  F02C     NOP
3206  5007     MOVF 0x7, W, ACCESS
3208  0105     MOVLB 0x5
320A  6FA7     MOVWF 0xA7, BANKED
760:                       if (ct[1]) {
320C  51A7     MOVF 0xA7, W, BANKED
320E  B4D8     BTFSC 0xFD8, 2, ACCESS
3210  EF0C     GOTO 0x3218
3212  F019     NOP
3214  EF0E     GOTO 0x321C
3216  F019     NOP
3218  EF2F     GOTO 0x325E
321A  F019     NOP
761:                           ct[2] = tolower((int)(*fmt)[2]);
321E  F528     NOP
3220  F4D9     NOP
3224  F52C     NOP
3226  F4DA     NOP
322A  F378     NOP
322C  F54E     NOP
3230  F374     NOP
3232  F54F     NOP
3234  0E02     MOVLW 0x2
3236  264E     ADDWF 0x4E, F, ACCESS
3238  0E00     MOVLW 0x0
323A  224F     ADDWFC 0x4F, F, ACCESS
323E  F538     NOP
3240  F4F6     NOP
3244  F53C     NOP
3246  F4F7     NOP
3248  0E00     MOVLW 0x0
324A  6EF8     MOVWF 0xFF8, ACCESS
324C  0008     TBLRD*
324E  50F5     MOVF 0xFF5, W, ACCESS
3250  6E07     MOVWF 0x7, ACCESS
3252  6A08     CLRF 0x8, ACCESS
3254  ECBC     CALL 0x5978, 0
3256  F02C     NOP
3258  5007     MOVF 0x7, W, ACCESS
325A  0105     MOVLB 0x5
325C  6FA8     MOVWF 0xA8, BANKED
762:                       }
763:                   }
764:           #endif
765:           
766:           #ifdef _VFPF_A
767:                   /* 'a' style (hex) floating point */
768:                   if (ct[0] == 'a') {
769:           
770:                       c = (*fmt)[0];
771:                       ++*fmt;
772:                       f = (long double)va_arg(ap, double);
773:                                   
774:                       return atoa(fp, f, c);
775:                   }
776:                   if (!strncmp(ct, "la", CSTRLEN("la"))) {
777:           
778:                       c = (*fmt)[1];
779:                       if (isupper((int)(*fmt)[0])) {
780:                           f = va_arg(ap, long double);
781:                       } else {
782:                           f = (long double)va_arg(ap, double);
783:                       }
784:                       *fmt += CSTRLEN("la");
785:                                   
786:                       return atoa(fp, f, c);
787:                   }
788:           #endif
789:           
790:           #ifdef _VFPF_C
791:                   /* Character */
792:                   if (*fmt[0] == 'c') {
793:                       ++*fmt;
794:                       c = (unsigned char)va_arg(ap, int);
795:                       return ctoa(fp, c);
796:                   }
797:           #endif
798:           
799:           #ifdef _VFPF_D
800:           #ifdef _VFPF_HH
801:                   /* Character decimal integer */
802:                   if (!strncmp(*fmt, "hhd", CSTRLEN("hhd")) || \
803:                       !strncmp(*fmt, "hhi", CSTRLEN("hhi"))) {
804:           
805:                       *fmt += CSTRLEN("hhd");
806:                       ll = (long long)(signed char)va_arg(ap, int);
807:                                   
808:                       return dtoa(fp, ll);
809:                   }
810:           #endif
811:           
812:           #ifdef _VFPF_H
813:                   /* Short decimal integer */
814:                   if (!strncmp(*fmt, "hd", CSTRLEN("hd")) || \
815:                       !strncmp(*fmt, "hi", CSTRLEN("hi"))) {
816:           
817:                       *fmt += CSTRLEN("hd");
818:                       ll = (long long)(short)va_arg(ap, int);
819:                                   
820:                       return dtoa(fp, ll);
821:                   }
822:           #endif
823:           
824:                   /* Decimal integer */
825:                   if ((*fmt[0] == 'd') || (*fmt[0] == 'i')) {
3260  F528     NOP
3262  F4D9     NOP
3266  F52C     NOP
3268  F4DA     NOP
326A  C4DE     MOVFF POSTINC2, TBLPTR
326C  F4F6     NOP
326E  C4DD     MOVFF POSTDEC2, TBLPTRH
3270  F4F7     NOP
3272  0E00     MOVLW 0x0
3274  6EF8     MOVWF 0xFF8, ACCESS
3276  0008     TBLRD*
3278  50F5     MOVF 0xFF5, W, ACCESS
327A  0A64     XORLW 0x64
327C  B4D8     BTFSC 0xFD8, 2, ACCESS
327E  EF43     GOTO 0x3286
3280  F019     NOP
3282  EF45     GOTO 0x328A
3284  F019     NOP
3286  EF5B     GOTO 0x32B6
3288  F019     NOP
328C  F528     NOP
328E  F4D9     NOP
3292  F52C     NOP
3294  F4DA     NOP
3296  C4DE     MOVFF POSTINC2, TBLPTR
3298  F4F6     NOP
329A  C4DD     MOVFF POSTDEC2, TBLPTRH
329C  F4F7     NOP
329E  0E00     MOVLW 0x0
32A0  6EF8     MOVWF 0xFF8, ACCESS
32A2  0008     TBLRD*
32A4  50F5     MOVF 0xFF5, W, ACCESS
32A6  0A69     XORLW 0x69
32A8  A4D8     BTFSS 0xFD8, 2, ACCESS
32AA  EF59     GOTO 0x32B2
32AC  F019     NOP
32AE  EF5B     GOTO 0x32B6
32B0  F019     NOP
32B2  EFA5     GOTO 0x334A
32B4  F019     NOP
826:           
827:                       ++*fmt;
32B8  F528     NOP
32BA  F4D9     NOP
32BE  F52C     NOP
32C0  F4DA     NOP
32C2  2ADE     INCF 0xFDE, F, ACCESS
32C4  0E00     MOVLW 0x0
32C6  22DD     ADDWFC 0xFDD, F, ACCESS
828:                       ll = (long long)va_arg(ap, int);
32CA  F530     NOP
32CC  F4D9     NOP
32D0  F534     NOP
32D2  F4DA     NOP
32D6  F37C     NOP
32D8  F54E     NOP
32DA  0E02     MOVLW 0x2
32DC  26DE     ADDWF 0xFDE, F, ACCESS
32E0  F37C     NOP
32E2  F54F     NOP
32E4  0E00     MOVLW 0x0
32E6  22DD     ADDWFC 0xFDD, F, ACCESS
32EA  F538     NOP
32EC  F4D9     NOP
32F0  F53C     NOP
32F2  F4DA     NOP
32F6  F378     NOP
32F8  F598     NOP
32FC  F374     NOP
32FE  F599     NOP
3300  0E00     MOVLW 0x0
3302  BF99     BTFSC SPI2CLK, 7, BANKED
3304  0EFF     MOVLW 0xFF
3306  6F9A     MOVWF 0x9A, BANKED
3308  6F9B     MOVWF 0x9B, BANKED
330A  6F9C     MOVWF 0x9C, BANKED
330C  6F9D     MOVWF 0x9D, BANKED
330E  6F9E     MOVWF 0x9E, BANKED
3310  6F9F     MOVWF 0x9F, BANKED
829:                                   
830:                       return dtoa(fp, ll);
3312  C548     MOVFF fp, fp
3314  F51E     NOP
3316  C549     MOVFF 0x549, sign
3318  F51F     NOP
331A  C598     MOVFF ll, new_exp
331C  F520     NOP
331E  C599     MOVFF 0x599, bexp
3320  F521     NOP
3322  C59A     MOVFF 0x59A, grs
3324  F522     NOP
3326  C59B     MOVFF 0x59B, 0x523
3328  F523     NOP
332A  C59C     MOVFF 0x59C, 0x524
332C  F524     NOP
332E  C59D     MOVFF 0x59D, 0x525
3330  F525     NOP
3332  C59E     MOVFF 0x59E, bexp
3334  F526     NOP
3336  C59F     MOVFF 0x59F, aexp
3338  F527     NOP
333A  EC44     CALL 0x4688, 0
333C  F023     NOP
333E  C51E     MOVFF fp, fp
3340  F548     NOP
3342  C51F     MOVFF sign, 0x549
3344  F549     NOP
3346  EF28     GOTO 0x3650
3348  F01B     NOP
831:                   }
832:           
833:           #ifdef _VFPF_L
834:                   /* Long decimal integer */
835:                   if (!strncmp(*fmt, "ld", CSTRLEN("ld")) || \
836:                       !strncmp(*fmt, "li", CSTRLEN("li"))) {
837:           
838:                       *fmt += CSTRLEN("ld");
839:                       ll = (long long)va_arg(ap, long);
840:                                   
841:                       return dtoa(fp, ll);
842:                   }
843:           #endif
844:           
845:           #ifdef _VFPF_LL
846:                   /* Long long decimal integer */
847:                   if (!strncmp(*fmt, "lld", CSTRLEN("lld")) || \
848:                       !strncmp(*fmt, "lli", CSTRLEN("lli"))) {
849:           
850:                       *fmt += CSTRLEN("lld");
851:                       ll = va_arg(ap, long long);
852:                                   
853:                       return dtoa(fp, ll);
854:                   }
855:           #endif
856:           
857:           #ifdef _VFPF_J
858:                   /* intmax_t decimal integer */
859:                   if (!strncmp(*fmt, "jd", CSTRLEN("jd")) || \
860:                       !strncmp(*fmt, "ji", CSTRLEN("ji"))) {
861:           
862:                       *fmt += CSTRLEN("jd");
863:                       ll = (long long)va_arg(ap, intmax_t);
864:                                   
865:                       return dtoa(fp, ll);
866:                   }
867:           #endif
868:           
869:           #ifdef _VFPF_T
870:                   /* ptrdiff_t decimal integer */
871:                   if (!strncmp(*fmt, "td", CSTRLEN("td")) || \
872:                       !strncmp(*fmt, "ti", CSTRLEN("ti"))) {
873:           
874:                       *fmt += CSTRLEN("td");
875:                       ll = (long long)va_arg(ap, ptrdiff_t);
876:                                   
877:                       return dtoa(fp, ll);
878:                   }
879:           #endif
880:           
881:           #ifdef _VFPF_Z
882:                   /* size_t decimal integer */
883:                   if (!strncmp(*fmt, "zd", CSTRLEN("zd")) || \
884:                       !strncmp(*fmt, "zi", CSTRLEN("zi"))) {
885:           
886:                       *fmt += CSTRLEN("zd");
887:                       ll = (long long)va_arg(ap, size_t);
888:                                   
889:                       return dtoa(fp, ll);
890:                   }
891:           #endif
892:           #endif
893:           
894:           #ifdef _VFPF_E
895:                   /* 'e' style floating point */
896:                   if (ct[0] == 'e') {
897:           
898:                       c = (*fmt)[0];
899:                       ++*fmt;
900:                       f = (long double)va_arg(ap, double);
901:                                   
902:                       return efgtoa(fp, f, c);
903:                   }
904:                   if (!strncmp(ct, "le", CSTRLEN("le"))) {
905:           
906:                       c = (*fmt)[1];
907:                       if (isupper((int)(*fmt)[0])) {
908:                           f = va_arg(ap, long double);
909:                       } else {
910:                           f = (long double)va_arg(ap, double);
911:                       }
912:                       *fmt += CSTRLEN("lf");
913:                                   
914:                       return efgtoa(fp, f, c);
915:                   }
916:           #endif
917:           
918:           #ifdef _VFPF_F
919:                   /* 'f' style floating point */
920:                   if (ct[0] == 'f') {
334A  0E66     MOVLW 0x66
334C  19A6     XORWF 0xA6, W, BANKED
334E  A4D8     BTFSS 0xFD8, 2, ACCESS
3350  EFAC     GOTO 0x3358
3352  F019     NOP
3354  EFAE     GOTO 0x335C
3356  F019     NOP
3358  EFFF     GOTO 0x33FE
335A  F019     NOP
921:           
922:                       c = (*fmt)[0];
335E  F528     NOP
3360  F4D9     NOP
3364  F52C     NOP
3366  F4DA     NOP
3368  C4DE     MOVFF POSTINC2, TBLPTR
336A  F4F6     NOP
336C  C4DD     MOVFF POSTDEC2, TBLPTRH
336E  F4F7     NOP
3370  0E00     MOVLW 0x0
3372  6EF8     MOVWF 0xFF8, ACCESS
3374  0008     TBLRD*
3378  F3D4     NOP
337A  F5A9     NOP
923:                       ++*fmt;
337E  F528     NOP
3380  F4D9     NOP
3384  F52C     NOP
3386  F4DA     NOP
3388  2ADE     INCF 0xFDE, F, ACCESS
338A  0E00     MOVLW 0x0
338C  22DD     ADDWFC 0xFDD, F, ACCESS
924:                       f = (long double)va_arg(ap, double);
3390  F530     NOP
3392  F4D9     NOP
3396  F534     NOP
3398  F4DA     NOP
339C  F37C     NOP
339E  F54E     NOP
33A0  0E04     MOVLW 0x4
33A2  26DE     ADDWF 0xFDE, F, ACCESS
33A6  F37C     NOP
33A8  F54F     NOP
33AA  0E00     MOVLW 0x0
33AC  22DD     ADDWFC 0xFDD, F, ACCESS
33B0  F538     NOP
33B2  F4D9     NOP
33B6  F53C     NOP
33B8  F4DA     NOP
33BC  F378     NOP
33BE  F5A2     NOP
33C2  F378     NOP
33C4  F5A3     NOP
33C8  F378     NOP
33CA  F5A4     NOP
33CE  F378     NOP
33D0  F5A5     NOP
925:                                   
926:                       return efgtoa(fp, f, c);
33D2  C548     MOVFF fp, fp
33D4  F53C     NOP
33D6  C549     MOVFF 0x549, 0x53D
33D8  F53D     NOP
33DA  C5A2     MOVFF f, f
33DC  F53E     NOP
33DE  C5A3     MOVFF 0x5A3, 0x53F
33E0  F53F     NOP
33E2  C5A4     MOVFF 0x5A4, i
33E4  F540     NOP
33E6  C5A5     MOVFF 0x5A5, 0x541
33E8  F541     NOP
33EA  C5A9     MOVFF c, c
33EC  F542     NOP
33EE  EC9D     CALL 0x253A, 0
33F0  F012     NOP
33F2  C53C     MOVFF fp, fp
33F4  F548     NOP
33F6  C53D     MOVFF 0x53D, 0x549
33F8  F549     NOP
33FA  EF28     GOTO 0x3650
33FC  F01B     NOP
927:                   }
928:                   if (!strncmp(ct, "lf", CSTRLEN("lf"))) {
33FE  0EA6     MOVLW 0xA6
3400  6E01     MOVWF 0x1, ACCESS
3402  0E05     MOVLW 0x5
3404  6E02     MOVWF 0x2, ACCESS
3406  0E36     MOVLW 0x36
3408  6E03     MOVWF 0x3, ACCESS
340A  0E25     MOVLW 0x25
340C  6E04     MOVWF 0x4, ACCESS
340E  0E00     MOVLW 0x0
3410  6E06     MOVWF 0x6, ACCESS
3412  0E02     MOVLW 0x2
3414  6E05     MOVWF 0x5, ACCESS
3416  EC94     CALL 0x5328, 0
3418  F029     NOP
341A  5001     MOVF 0x1, W, ACCESS
341C  1002     IORWF 0x2, W, ACCESS
341E  A4D8     BTFSS 0xFD8, 2, ACCESS
3420  EF14     GOTO 0x3428
3422  F01A     NOP
3424  EF16     GOTO 0x342C
3426  F01A     NOP
3428  EFC9     GOTO 0x3592
342A  F01A     NOP
929:           
930:                       c = (*fmt)[1];
342E  F528     NOP
3430  F4D9     NOP
3434  F52C     NOP
3436  F4DA     NOP
343A  F378     NOP
343C  F54E     NOP
3440  F374     NOP
3442  F54F     NOP
3444  0E01     MOVLW 0x1
3446  264E     ADDWF 0x4E, F, ACCESS
3448  0E00     MOVLW 0x0
344A  224F     ADDWFC 0x4F, F, ACCESS
344E  F538     NOP
3450  F4F6     NOP
3454  F53C     NOP
3456  F4F7     NOP
3458  0E00     MOVLW 0x0
345A  6EF8     MOVWF 0xFF8, ACCESS
345C  0008     TBLRD*
3460  F3D4     NOP
3462  F5A9     NOP
931:                       if (isupper((int)(*fmt)[0])) {
3464  0EBF     MOVLW 0xBF
3466  6E4E     MOVWF 0x4E, ACCESS
3468  0EFF     MOVLW 0xFF
346A  6E4F     MOVWF 0x4F, ACCESS
346E  F528     NOP
3470  F4D9     NOP
3474  F52C     NOP
3476  F4DA     NOP
3478  C4DE     MOVFF POSTINC2, TBLPTR
347A  F4F6     NOP
347C  C4DD     MOVFF POSTDEC2, TBLPTRH
347E  F4F7     NOP
3480  0E00     MOVLW 0x0
3482  6EF8     MOVWF 0xFF8, ACCESS
3484  0008     TBLRD*
3486  50F5     MOVF 0xFF5, W, ACCESS
3488  6E50     MOVWF 0x50, ACCESS
348A  6A51     CLRF 0x51, ACCESS
348C  504E     MOVF 0x4E, W, ACCESS
348E  2650     ADDWF 0x50, F, ACCESS
3490  504F     MOVF 0x4F, W, ACCESS
3492  2251     ADDWFC 0x51, F, ACCESS
3494  5051     MOVF 0x51, W, ACCESS
3496  E10A     BNZ 0x34AC
3498  0E1A     MOVLW 0x1A
349A  5C50     SUBWF 0x50, W, ACCESS
349C  A0D8     BTFSS 0xFD8, 0, ACCESS
349E  EF53     GOTO 0x34A6
34A0  F01A     NOP
34A2  EF56     GOTO 0x34AC
34A4  F01A     NOP
34A6  0E01     MOVLW 0x1
34A8  EF57     GOTO 0x34AE
34AA  F01A     NOP
34AC  0E00     MOVLW 0x0
34AE  0105     MOVLB 0x5
34B0  6FA0     MOVWF 0xA0, BANKED
34B2  6BA1     CLRF 0xA1, BANKED
34B4  51A0     MOVF 0xA0, W, BANKED
34B6  11A1     IORWF 0xA1, W, BANKED
34B8  B4D8     BTFSC 0xFD8, 2, ACCESS
34BA  EF61     GOTO 0x34C2
34BC  F01A     NOP
34BE  EF63     GOTO 0x34C6
34C0  F01A     NOP
34C2  EF87     GOTO 0x350E
34C4  F01A     NOP
932:                           f = va_arg(ap, long double);
34C8  F530     NOP
34CA  F4D9     NOP
34CE  F534     NOP
34D0  F4DA     NOP
34D4  F37C     NOP
34D6  F54E     NOP
34D8  0E04     MOVLW 0x4
34DA  26DE     ADDWF 0xFDE, F, ACCESS
34DE  F37C     NOP
34E0  F54F     NOP
34E2  0E00     MOVLW 0x0
34E4  22DD     ADDWFC 0xFDD, F, ACCESS
34E8  F538     NOP
34EA  F4D9     NOP
34EE  F53C     NOP
34F0  F4DA     NOP
34F4  F378     NOP
34F6  F5A2     NOP
34FA  F378     NOP
34FC  F5A3     NOP
3500  F378     NOP
3502  F5A4     NOP
3506  F378     NOP
3508  F5A5     NOP
933:                       } else {
350A  EFA9     GOTO 0x3552
350C  F01A     NOP
934:                           f = (long double)va_arg(ap, double);
3510  F530     NOP
3512  F4D9     NOP
3516  F534     NOP
3518  F4DA     NOP
351C  F37C     NOP
351E  F54E     NOP
3520  0E04     MOVLW 0x4
3522  26DE     ADDWF 0xFDE, F, ACCESS
3526  F37C     NOP
3528  F54F     NOP
352A  0E00     MOVLW 0x0
352C  22DD     ADDWFC 0xFDD, F, ACCESS
3530  F538     NOP
3532  F4D9     NOP
3536  F53C     NOP
3538  F4DA     NOP
353C  F378     NOP
353E  F5A2     NOP
3542  F378     NOP
3544  F5A3     NOP
3548  F378     NOP
354A  F5A4     NOP
354E  F378     NOP
3550  F5A5     NOP
935:                       }
3552  0E02     MOVLW 0x2
3556  F528     NOP
3558  F4D9     NOP
355C  F52C     NOP
355E  F4DA     NOP
3560  26DE     ADDWF 0xFDE, F, ACCESS
3562  0E00     MOVLW 0x0
3564  22DD     ADDWFC 0xFDD, F, ACCESS
936:                       *fmt += CSTRLEN("lf");
937:                                   
938:                       return efgtoa(fp, f, c);
3566  C548     MOVFF fp, fp
3568  F53C     NOP
356A  C549     MOVFF 0x549, 0x53D
356C  F53D     NOP
356E  C5A2     MOVFF f, f
3570  F53E     NOP
3572  C5A3     MOVFF 0x5A3, 0x53F
3574  F53F     NOP
3576  C5A4     MOVFF 0x5A4, i
3578  F540     NOP
357A  C5A5     MOVFF 0x5A5, 0x541
357C  F541     NOP
357E  C5A9     MOVFF c, c
3580  F542     NOP
3582  EC9D     CALL 0x253A, 0
3584  F012     NOP
3586  C53C     MOVFF fp, fp
3588  F548     NOP
358A  C53D     MOVFF 0x53D, 0x549
358C  F549     NOP
358E  EF28     GOTO 0x3650
3590  F01B     NOP
939:                   }
940:           #endif
941:           
942:           #ifdef _VFPF_G
943:                   /* 'g' style floating point */
944:                   if (ct[0] == 'g') {
945:           
946:                       c = (*fmt)[0];
947:                       ++*fmt;
948:                       f = (long double)va_arg(ap, double);
949:                                   
950:                       return efgtoa(fp, f, c);
951:                   }
952:                   if (!strncmp(ct, "lg", CSTRLEN("lg"))) {
953:           
954:                       c = (*fmt)[1];
955:                       if (isupper((int)(*fmt)[0])) {
956:                           f = va_arg(ap, long double);
957:                       } else {
958:                           f = (long double)va_arg(ap, double);
959:                       }
960:                       *fmt += CSTRLEN("lg");
961:                                   
962:                       return efgtoa(fp, f, c);
963:                   }
964:           #endif
965:           
966:           #ifdef _VFPF_O
967:           #ifdef _VFPF_HH
968:                   /* Character octal integer */
969:                   if (!strncmp(*fmt, "hho", CSTRLEN("hho"))) {
970:           
971:                       *fmt += CSTRLEN("hho");
972:                       llu = (unsigned long long)(unsigned char)va_arg(ap, int);
973:                                   
974:                       return otoa(fp, llu);
975:                   }
976:           #endif
977:           
978:           #ifdef _VFPF_H
979:                   /* Short octal integer */
980:                   if (!strncmp(*fmt, "ho", CSTRLEN("ho"))) {
981:           
982:                       *fmt += CSTRLEN("ho");
983:                       llu = (unsigned long long)(unsigned short)va_arg(ap, int);
984:                                   
985:                       return otoa(fp, llu);
986:                   }
987:           #endif
988:           
989:                   /* Octal integer */
990:                   if (*fmt[0] == 'o') {
991:           
992:                       ++*fmt;
993:                       llu = (unsigned long long)va_arg(ap, unsigned int);
994:                                   
995:                       return otoa(fp, llu);
996:                   }
997:           
998:           #ifdef _VFPF_L
999:                   /* Long octal integer */
1000:                  if (!strncmp(*fmt, "lo", CSTRLEN("lo"))) {
1001:          
1002:                      *fmt += CSTRLEN("lo");
1003:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1004:                                  
1005:                      return otoa(fp, llu);
1006:                  }
1007:          #endif
1008:          
1009:          #ifdef _VFPF_LL
1010:                  /* Long long octal integer */
1011:                  if (!strncmp(*fmt, "llo", CSTRLEN("llo"))) {
1012:          
1013:                      *fmt += CSTRLEN("llo");
1014:                      llu = va_arg(ap, unsigned long long);
1015:                                  
1016:                      return otoa(fp, llu);
1017:                  }
1018:          #endif
1019:          
1020:          #ifdef _VFPF_J
1021:                  /* uintmax_t octal integer */
1022:                  if (!strncmp(*fmt, "jo", CSTRLEN("jo"))) {
1023:          
1024:                      *fmt += CSTRLEN("jo");
1025:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1026:                                  
1027:                      return otoa(fp, llu);
1028:                  }
1029:          #endif
1030:          
1031:          #ifdef _VFPF_T
1032:                  /* ptrdiff_t octal integer */
1033:                  if (!strncmp(*fmt, "to", CSTRLEN("to"))) {
1034:          
1035:                      *fmt += CSTRLEN("to");
1036:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1037:                                  
1038:                      return otoa(fp, llu);
1039:                  }
1040:          #endif
1041:          
1042:          #ifdef _VFPF_Z
1043:                  /* size_t octal integer */
1044:                  if (!strncmp(*fmt, "zo", CSTRLEN("zo"))) {
1045:          
1046:                      *fmt += CSTRLEN("zo");
1047:                      llu = (unsigned long long)va_arg(ap, size_t);
1048:                                  
1049:                      return otoa(fp, llu);
1050:                  }
1051:          #endif
1052:          #endif
1053:          
1054:                  /* Character count */
1055:          #ifdef _VFPF_N
1056:          
1057:          #ifdef _VFPF_HH
1058:                  if (!strncmp(*fmt, "hhn", CSTRLEN("hhn"))) {
1059:          
1060:                      *fmt += CSTRLEN("hhn");
1061:                      vp = (void *)va_arg(ap, char *);
1062:                      *(char *)vp = (char)nout;
1063:                      return 0;
1064:                  }
1065:          #endif
1066:          
1067:          #ifdef _VFPF_H
1068:                  if (!strncmp(*fmt, "hn", CSTRLEN("hn"))) {
1069:          
1070:                      *fmt += CSTRLEN("hn");
1071:                      vp = (void *)va_arg(ap, short *);
1072:                      *(short *)vp = (short)nout;
1073:                      return 0;
1074:                  }
1075:          #endif
1076:          
1077:                  if (*fmt[0] == 'n') {
1078:                      ++*fmt;
1079:                      vp = (void *)va_arg(ap, int *);
1080:                      *(int *)vp = nout;
1081:                      return 0;
1082:                  }
1083:          
1084:          #ifdef _VFPF_L
1085:                  if (!strncmp(*fmt, "ln", CSTRLEN("ln"))) {
1086:          
1087:                      *fmt += CSTRLEN("ln");
1088:                      vp = (void *)va_arg(ap, long *);
1089:                      *(long *)vp = (long)nout;
1090:                      return 0;
1091:                  }
1092:          #endif
1093:          
1094:          #ifdef _VFPF_LL
1095:                  if (!strncmp(*fmt, "lln", CSTRLEN("lln"))) {
1096:          
1097:                      *fmt += CSTRLEN("lln");
1098:                      vp = (void *)va_arg(ap, long long *);
1099:                      *(long long *)vp = (long long)nout;
1100:                      return 0;
1101:                  }
1102:          #endif
1103:          
1104:          #ifdef _VFPF_J
1105:                  if (!strncmp(*fmt, "jn", CSTRLEN("jn"))) {
1106:          
1107:                      *fmt += CSTRLEN("jn");
1108:                      vp = (void *)va_arg(ap, uintmax_t *);
1109:                      *(uintmax_t *)vp = (uintmax_t)nout;
1110:                      return 0;
1111:                  }
1112:          #endif
1113:          
1114:          #ifdef _VFPF_T
1115:                  if (!strncmp(*fmt, "tn", CSTRLEN("tn"))) {
1116:          
1117:                      *fmt += CSTRLEN("tn");
1118:                      vp = (void *)va_arg(ap, ptrdiff_t *);
1119:                      *(ptrdiff_t *)vp = (ptrdiff_t)nout;
1120:                      return 0;
1121:                  }
1122:          #endif
1123:          
1124:          #ifdef _VFPF_Z
1125:                  if (!strncmp(*fmt, "zn", CSTRLEN("zn"))) {
1126:          
1127:                      *fmt += CSTRLEN("zn");
1128:                      vp = (void *)va_arg(ap, size_t *);
1129:                      *(size_t *)vp = (size_t)nout;
1130:                      return 0;
1131:                  }
1132:          #endif
1133:          
1134:          #endif
1135:          
1136:          #ifdef _VFPF_P
1137:                  /* Pointer */
1138:                  if (*fmt[0] == 'p') {
1139:          
1140:                      ++*fmt;
1141:                      llu = (unsigned long long)(size_t)va_arg(ap, void *);
1142:                                  
1143:                      return xtoa(fp, llu, 'x');
1144:                  }
1145:          #endif
1146:          
1147:          #ifdef _VFPF_S
1148:                  /* String */
1149:                  if (*fmt[0] == 's') {
1150:          
1151:                      ++*fmt;
1152:                      cp = va_arg(ap, char *);
1153:          
1154:                      return stoa(fp, cp);
1155:                  }
1156:          #endif
1157:          
1158:          #ifdef _VFPF_U
1159:          #ifdef _VFPF_HH
1160:                  /* Unsigned character decimal integer */
1161:                  if (!strncmp(*fmt, "hhu", CSTRLEN("hhu"))) {
1162:          
1163:                      *fmt += CSTRLEN("hhu");
1164:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1165:                                  
1166:                      return utoa(fp, llu);
1167:                  }
1168:          #endif
1169:          
1170:          #ifdef _VFPF_H
1171:                  /* Unsigned short decimal integer */
1172:                  if (!strncmp(*fmt, "hu", CSTRLEN("hu"))) {
1173:          
1174:                      *fmt += CSTRLEN("hu");
1175:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1176:                                  
1177:                      return utoa(fp, llu);
1178:                  }
1179:          #endif
1180:          
1181:                  /* Unsigned decimal integer */
1182:                  if (*fmt[0] == 'u') {
1183:          
1184:                      ++*fmt;
1185:                      llu = (unsigned long long)va_arg(ap, unsigned int);
1186:                                  
1187:                      return utoa(fp, llu);
1188:                  }
1189:          
1190:          #ifdef _VFPF_L
1191:                  /* Unsigned long decimal integer */
1192:                  if (!strncmp(*fmt, "lu", CSTRLEN("lu"))) {
1193:          
1194:                      *fmt += CSTRLEN("lu");
1195:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1196:                                  
1197:                      return utoa(fp, llu);
1198:                  }
1199:          #endif
1200:          
1201:          #ifdef _VFPF_LL
1202:                  /* Unsigned long long decimal integer */
1203:                  if (!strncmp(*fmt, "llu", CSTRLEN("llu"))) {
1204:          
1205:                      *fmt += CSTRLEN("llu");
1206:                      llu = va_arg(ap, unsigned long long);
1207:                                  
1208:                      return utoa(fp, llu);
1209:                  }
1210:          #endif
1211:          
1212:          #ifdef _VFPF_J
1213:                  /* uintmax_t decimal integer */
1214:                  if (!strncmp(*fmt, "ju", CSTRLEN("ju"))) {
1215:          
1216:                      *fmt += CSTRLEN("ju");
1217:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1218:                                  
1219:                      return utoa(fp, llu);
1220:                  }
1221:          #endif
1222:          
1223:          #ifdef _VFPF_T
1224:                  /* ptrdiff_t decimal integer */
1225:                  if (!strncmp(*fmt, "tu", CSTRLEN("tu"))) {
1226:          
1227:                      *fmt += CSTRLEN("tu");
1228:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1229:                                  
1230:                      return utoa(fp, llu);
1231:                  }
1232:          #endif
1233:          
1234:          #ifdef _VFPF_Z
1235:                  /* size_t decimal integer */
1236:                  if (!strncmp(*fmt, "zu", CSTRLEN("zu"))) {
1237:          
1238:                      *fmt += CSTRLEN("zu");
1239:                      llu = (unsigned long long)va_arg(ap, size_t);
1240:                                  
1241:                      return utoa(fp, llu);
1242:                  }
1243:          #endif
1244:          #endif
1245:          
1246:          #ifdef _VFPF_X
1247:          #ifdef _VFPF_HH
1248:                  /* Character hexadecimal integer */
1249:                  if (!strncmp(*fmt, "hhx", CSTRLEN("hhx")) || \
1250:                      !strncmp(*fmt, "hhX", CSTRLEN("hhX"))) {
1251:          
1252:                      c = (*fmt)[2];
1253:                      *fmt += CSTRLEN("hhx");
1254:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1255:                                  
1256:                      return xtoa(fp, llu, c);
1257:                  }
1258:          #endif
1259:          
1260:          #ifdef _VFPF_H
1261:                  /* Short hexadecimal integer */
1262:                  if (!strncmp(*fmt, "hx", CSTRLEN("hx")) || \
1263:                      !strncmp(*fmt, "hX", CSTRLEN("hX"))) {
1264:          
1265:                      c = (*fmt)[1];
1266:                      *fmt += CSTRLEN("hx");
1267:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1268:                                  
1269:                      return xtoa(fp, llu, c);
1270:                  }
1271:          #endif
1272:          
1273:                  /* Hexadecimal integer */
1274:                  if ((*fmt[0] == 'x') || (*fmt[0] == 'X')) {
1275:          
1276:                      c = (*fmt)[0];
1277:                      ++*fmt;
1278:                      llu = (unsigned long long)va_arg(ap, unsigned int);
1279:                                  
1280:                      return xtoa(fp, llu, c);
1281:                  }
1282:          
1283:          #ifdef _VFPF_L
1284:                  /* Long hexadecimal integer */
1285:                  if (!strncmp(*fmt, "lx", CSTRLEN("lx")) || \
1286:                      !strncmp(*fmt, "lX", CSTRLEN("lX"))) {
1287:          
1288:                      c = (*fmt)[1];
1289:                      *fmt += CSTRLEN("lx");
1290:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1291:                                  
1292:                      return xtoa(fp, llu, c);
1293:                  }
1294:          #endif
1295:          
1296:          #ifdef _VFPF_LL
1297:                  /* Long long hexadecimal integer */
1298:                  if (!strncmp(*fmt, "llx", CSTRLEN("llx")) || \
1299:                      !strncmp(*fmt, "llX", CSTRLEN("llX"))) {
1300:          
1301:                      c = (*fmt)[2];
1302:                      *fmt += CSTRLEN("llx");
1303:                      llu = va_arg(ap, unsigned long long);
1304:                                  
1305:                      return xtoa(fp, llu, c);
1306:                  }
1307:          #endif
1308:          
1309:          #ifdef _VFPF_J
1310:                  /* uintmax_t hexadecimal integer */
1311:                  if (!strncmp(*fmt, "jx", CSTRLEN("jx")) || \
1312:                      !strncmp(*fmt, "jX", CSTRLEN("jX"))) {
1313:          
1314:                      c = (*fmt)[1];
1315:                      *fmt += CSTRLEN("jx");
1316:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1317:                                  
1318:                      return xtoa(fp, llu, c);
1319:                  }
1320:          #endif
1321:          
1322:          #ifdef _VFPF_T
1323:                  /* ptrdiff_t hexadecimal integer */
1324:                  if (!strncmp(*fmt, "tx", CSTRLEN("tx")) || \
1325:                      !strncmp(*fmt, "tX", CSTRLEN("tX"))) {
1326:          
1327:                      c = (*fmt)[1];
1328:                      *fmt += CSTRLEN("tx");
1329:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1330:                                  
1331:                      return xtoa(fp, llu, c);
1332:                  }
1333:          #endif
1334:          
1335:          #ifdef _VFPF_Z
1336:                  /* size_t hexadecimal integer */
1337:                  if (!strncmp(*fmt, "zx", CSTRLEN("zx")) || \
1338:                      !strncmp(*fmt, "zX", CSTRLEN("zX"))) {
1339:          
1340:                      c = (*fmt)[1];
1341:                      *fmt += CSTRLEN("zx");
1342:                      llu = (unsigned long long)va_arg(ap, size_t);
1343:                                  
1344:                      return xtoa(fp, llu, c);
1345:                  }
1346:          #endif
1347:          #endif
1348:          
1349:                  /* 'Escaped' '%' character */
1350:                  if ((*fmt)[0] == '%') {
3594  F528     NOP
3596  F4D9     NOP
359A  F52C     NOP
359C  F4DA     NOP
359E  C4DE     MOVFF POSTINC2, TBLPTR
35A0  F4F6     NOP
35A2  C4DD     MOVFF POSTDEC2, TBLPTRH
35A4  F4F7     NOP
35A6  0E00     MOVLW 0x0
35A8  6EF8     MOVWF 0xFF8, ACCESS
35AA  0008     TBLRD*
35AC  50F5     MOVF 0xFF5, W, ACCESS
35AE  0A25     XORLW 0x25
35B0  A4D8     BTFSS 0xFD8, 2, ACCESS
35B2  EFDD     GOTO 0x35BA
35B4  F01A     NOP
35B6  EFDF     GOTO 0x35BE
35B8  F01A     NOP
35BA  EFF8     GOTO 0x35F0
35BC  F01A     NOP
1351:                      ++*fmt;
35C0  F528     NOP
35C2  F4D9     NOP
35C6  F52C     NOP
35C8  F4DA     NOP
35CA  2ADE     INCF 0xFDE, F, ACCESS
35CC  0E00     MOVLW 0x0
35CE  22DD     ADDWFC 0xFDD, F, ACCESS
1352:                      fputc((int)'%', fp);
35D0  0E00     MOVLW 0x0
35D2  6E04     MOVWF 0x4, ACCESS
35D4  0E25     MOVLW 0x25
35D6  6E03     MOVWF 0x3, ACCESS
35D8  C548     MOVFF fp, n
35DA  F505     NOP
35DC  C549     MOVFF 0x549, sign
35DE  F506     NOP
35E0  EC83     CALL 0x5706, 0
35E2  F02B     NOP
1353:                      return 1;
35E4  0E00     MOVLW 0x0
35E6  6E49     MOVWF BORCON, ACCESS
35E8  0E01     MOVLW 0x1
35EA  6E48     MOVWF VREGCON, ACCESS
35EC  EF28     GOTO 0x3650
35EE  F01B     NOP
1354:                  }
1355:          
1356:                  /* Unrecognized conversion */
1357:                  ++*fmt;
35F2  F528     NOP
35F4  F4D9     NOP
35F8  F52C     NOP
35FA  F4DA     NOP
35FC  2ADE     INCF 0xFDE, F, ACCESS
35FE  0E00     MOVLW 0x0
3600  22DD     ADDWFC 0xFDD, F, ACCESS
1358:                  return 0;
3602  0E00     MOVLW 0x0
3604  6E49     MOVWF BORCON, ACCESS
3606  0E00     MOVLW 0x0
3608  6E48     MOVWF VREGCON, ACCESS
360A  EF28     GOTO 0x3650
360C  F01B     NOP
1359:              }
1360:          
1361:              /* No conversion, just intervening text */
1362:              fputc((int)(*fmt)[0], fp);
3610  F528     NOP
3612  F4D9     NOP
3616  F52C     NOP
3618  F4DA     NOP
361A  C4DE     MOVFF POSTINC2, TBLPTR
361C  F4F6     NOP
361E  C4DD     MOVFF POSTDEC2, TBLPTRH
3620  F4F7     NOP
3622  0E00     MOVLW 0x0
3624  6EF8     MOVWF 0xFF8, ACCESS
3626  0008     TBLRD*
3628  50F5     MOVF 0xFF5, W, ACCESS
362A  6E03     MOVWF 0x3, ACCESS
362C  6A04     CLRF 0x4, ACCESS
362E  C548     MOVFF fp, n
3630  F505     NOP
3632  C549     MOVFF 0x549, sign
3634  F506     NOP
3636  EC83     CALL 0x5706, 0
3638  F02B     NOP
1363:              ++*fmt;
363C  F528     NOP
363E  F4D9     NOP
3642  F52C     NOP
3644  F4DA     NOP
3646  2ADE     INCF 0xFDE, F, ACCESS
3648  0E00     MOVLW 0x0
364A  22DD     ADDWFC 0xFDD, F, ACCESS
364C  EFF2     GOTO 0x35E4
364E  F01A     NOP
1364:              return 1;
1365:          }
3650  0012     RETURN 0
1366:          #endif
1367:          
1368:          int vfprintf(FILE *fp, const char *fmt, va_list ap)
58A8  C554     MOVFF fmt, cfmt
58AA  F558     NOP
58AC  C555     MOVFF 0x555, 0x559
58AE  F559     NOP
1369:          {
1370:          #ifdef _VFPF_CONVERT
1371:              char *cfmt;
1372:          
1373:              cfmt = (char *)fmt;
1374:              nout = 0;
58B0  0E00     MOVLW 0x0
58B2  0105     MOVLB 0x5
58B4  6FDA     MOVWF CLCnSEL2, BANKED
58B6  0E00     MOVLW 0x0
58B8  6FD9     MOVWF CLCnSEL1, BANKED
1375:              while (*cfmt) {
58BA  EF72     GOTO 0x58E4
58BC  F02C     NOP
58E6  F560     NOP
58E8  F4F6     NOP
58EC  F564     NOP
58EE  F4F7     NOP
58F0  0E00     MOVLW 0x0
58F2  6EF8     MOVWF 0xFF8, ACCESS
58F4  0008     TBLRD*
58F6  50F5     MOVF 0xFF5, W, ACCESS
58F8  0900     IORLW 0x0
58FA  A4D8     BTFSS 0xFD8, 2, ACCESS
58FC  EF82     GOTO 0x5904
58FE  F02C     NOP
5900  EF84     GOTO 0x5908
5902  F02C     NOP
5904  EF5F     GOTO 0x58BE
5906  F02C     NOP
1376:                  nout += vfpfcnvrt(fp, &cfmt, ap);
58BE  C552     MOVFF fp, fp
58C0  F548     NOP
58C2  C553     MOVFF 0x553, 0x549
58C4  F549     NOP
58C6  0E58     MOVLW 0x58
58C8  6E4A     MOVWF HLVDCON0, ACCESS
58CA  0E05     MOVLW 0x5
58CC  6E4B     MOVWF HLVDCON1, ACCESS
58CE  C556     MOVFF ap, ap
58D0  F54C     NOP
58D2  C557     MOVFF 0x557, 0x54D
58D4  F54D     NOP
58D6  EC9E     CALL 0x313C, 0
58D8  F018     NOP
58DA  5048     MOVF VREGCON, W, ACCESS
58DC  0105     MOVLB 0x5
58DE  27D9     ADDWF CLCnSEL1, F, BANKED
58E0  5049     MOVF BORCON, W, ACCESS
58E2  23DA     ADDWFC CLCnSEL2, F, BANKED
1377:              }
1378:              return nout;
5908  C5D9     MOVFF nout, fp
590A  F552     NOP
590C  C5DA     MOVFF 0x5DA, 0x553
590E  F553     NOP
1379:          #else
1380:              return fputs(fmt, fp);
1381:          #endif
1382:          }
5910  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.20/pic/sources/c99/common/awmod.c  -------------------------------
1:             // integer signed unsigned modulus
2:             
3:             signed int
4:             #ifdef __PICC__
5:             __awmod(signed int divisor, signed int dividend)
6:             #else
7:             __awmod(signed int dividend, signed int divisor)
55AC  0E00     MOVLW 0x0
55AE  6E06     MOVWF 0x6, ACCESS
8:             #endif
9:             {
10:            	unsigned char	counter, sign;
11:            
12:            	sign = 0;
13:            	if(dividend < 0) {
55B0  BE02     BTFSC 0x2, 7, ACCESS
55B2  EFDF     GOTO 0x55BE
55B4  F02A     NOP
55B6  EFDD     GOTO 0x55BA
55B8  F02A     NOP
55BA  EFE5     GOTO 0x55CA
55BC  F02A     NOP
14:            		dividend = -dividend;
55BE  6C01     NEGF 0x1, ACCESS
55C0  1E02     COMF 0x2, F, ACCESS
55C2  B0D8     BTFSC 0xFD8, 0, ACCESS
55C4  2A02     INCF 0x2, F, ACCESS
15:            		sign = 1;
55C6  0E01     MOVLW 0x1
55C8  6E06     MOVWF 0x6, ACCESS
16:            	}
17:            	if(divisor < 0)
55CA  BE04     BTFSC 0x4, 7, ACCESS
55CC  EFEC     GOTO 0x55D8
55CE  F02A     NOP
55D0  EFEA     GOTO 0x55D4
55D2  F02A     NOP
55D4  EFF0     GOTO 0x55E0
55D6  F02A     NOP
18:            		divisor = -divisor;
55D8  6C03     NEGF 0x3, ACCESS
55DA  1E04     COMF 0x4, F, ACCESS
55DC  B0D8     BTFSC 0xFD8, 0, ACCESS
55DE  2A04     INCF 0x4, F, ACCESS
19:            	if(divisor != 0) {
55E0  5003     MOVF 0x3, W, ACCESS
55E2  1004     IORWF 0x4, W, ACCESS
55E4  B4D8     BTFSC 0xFD8, 2, ACCESS
55E6  EFF7     GOTO 0x55EE
55E8  F02A     NOP
55EA  EFF9     GOTO 0x55F2
55EC  F02A     NOP
55EE  EF1D     GOTO 0x563A
55F0  F02B     NOP
20:            		counter = 1;
55F2  0E01     MOVLW 0x1
55F4  6E05     MOVWF 0x5, ACCESS
21:            		while(((unsigned int)divisor & 0x8000U) == 0) {
55F6  EF01     GOTO 0x5602
55F8  F02B     NOP
5602  AE04     BTFSS 0x4, 7, ACCESS
5604  EF06     GOTO 0x560C
5606  F02B     NOP
5608  EF08     GOTO 0x5610
560A  F02B     NOP
560C  EFFD     GOTO 0x55FA
560E  F02A     NOP
22:            			divisor <<= 1;
55FA  90D8     BCF 0xFD8, 0, ACCESS
55FC  3603     RLCF 0x3, F, ACCESS
55FE  3604     RLCF 0x4, F, ACCESS
23:            			counter++;
5600  2A05     INCF 0x5, F, ACCESS
24:            		}
25:            		do {
26:            			if((unsigned int)divisor <= (unsigned int)dividend)
5610  5003     MOVF 0x3, W, ACCESS
5612  5C01     SUBWF 0x1, W, ACCESS
5614  5004     MOVF 0x4, W, ACCESS
5616  5802     SUBWFB 0x2, W, ACCESS
5618  A0D8     BTFSS 0xFD8, 0, ACCESS
561A  EF11     GOTO 0x5622
561C  F02B     NOP
561E  EF13     GOTO 0x5626
5620  F02B     NOP
5622  EF17     GOTO 0x562E
5624  F02B     NOP
27:            				dividend -= divisor;
5626  5003     MOVF 0x3, W, ACCESS
5628  5E01     SUBWF 0x1, F, ACCESS
562A  5004     MOVF 0x4, W, ACCESS
562C  5A02     SUBWFB 0x2, F, ACCESS
28:            			*(unsigned int *)&divisor >>= 1;
562E  90D8     BCF 0xFD8, 0, ACCESS
5630  3204     RRCF 0x4, F, ACCESS
5632  3203     RRCF 0x3, F, ACCESS
29:            		} while(--counter != 0);
5634  2E05     DECFSZ 0x5, F, ACCESS
5636  EF08     GOTO 0x5610
5638  F02B     NOP
30:            	}
31:            	if(sign)
563A  5006     MOVF 0x6, W, ACCESS
563C  B4D8     BTFSC 0xFD8, 2, ACCESS
563E  EF23     GOTO 0x5646
5640  F02B     NOP
5642  EF25     GOTO 0x564A
5644  F02B     NOP
5646  EF29     GOTO 0x5652
5648  F02B     NOP
32:            		dividend = -dividend;
564A  6C01     NEGF 0x1, ACCESS
564C  1E02     COMF 0x2, F, ACCESS
564E  B0D8     BTFSC 0xFD8, 0, ACCESS
5650  2A02     INCF 0x2, F, ACCESS
33:            	return dividend;
5652  C501     MOVFF __pcstackCOMRAM, __pcstackCOMRAM
5654  F501     NOP
5656  C502     MOVFF txData, txData
5658  F502     NOP
34:            }
565A  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.20/pic/sources/c99/common/awdiv.c  -------------------------------
1:             // integer signed division
2:             
3:             signed int
4:             #ifdef __PICC__
5:             __awdiv(signed int divisor, signed int dividend)
6:             #else
7:             __awdiv(signed int dividend, signed int divisor)
54E8  0E00     MOVLW 0x0
54EA  6E0C     MOVWF 0xC, ACCESS
8:             #endif
9:             {
10:            	signed int	quotient;
11:            	unsigned char	counter, sign;
12:            
13:            	sign = 0;
14:            	if(divisor < 0) {
54EC  BE0A     BTFSC 0xA, 7, ACCESS
54EE  EF7D     GOTO 0x54FA
54F0  F02A     NOP
54F2  EF7B     GOTO 0x54F6
54F4  F02A     NOP
54F6  EF83     GOTO 0x5506
54F8  F02A     NOP
15:            		divisor = -divisor;
54FA  6C09     NEGF 0x9, ACCESS
54FC  1E0A     COMF 0xA, F, ACCESS
54FE  B0D8     BTFSC 0xFD8, 0, ACCESS
5500  2A0A     INCF 0xA, F, ACCESS
16:            		sign = 1;
5502  0E01     MOVLW 0x1
5504  6E0C     MOVWF 0xC, ACCESS
17:            	}
18:            	if(dividend < 0) {
5506  BE08     BTFSC 0x8, 7, ACCESS
5508  EF8A     GOTO 0x5514
550A  F02A     NOP
550C  EF88     GOTO 0x5510
550E  F02A     NOP
5510  EF90     GOTO 0x5520
5512  F02A     NOP
19:            		dividend = -dividend;
5514  6C07     NEGF 0x7, ACCESS
5516  1E08     COMF 0x8, F, ACCESS
5518  B0D8     BTFSC 0xFD8, 0, ACCESS
551A  2A08     INCF 0x8, F, ACCESS
20:            		sign ^= 1;
551C  0E01     MOVLW 0x1
551E  1A0C     XORWF 0xC, F, ACCESS
21:            	}
22:            	quotient = 0;
5520  0E00     MOVLW 0x0
5522  6E0E     MOVWF 0xE, ACCESS
5524  0E00     MOVLW 0x0
5526  6E0D     MOVWF 0xD, ACCESS
23:            	if(divisor != 0) {
5528  5009     MOVF 0x9, W, ACCESS
552A  100A     IORWF 0xA, W, ACCESS
552C  B4D8     BTFSC 0xFD8, 2, ACCESS
552E  EF9B     GOTO 0x5536
5530  F02A     NOP
5532  EF9D     GOTO 0x553A
5534  F02A     NOP
5536  EFC5     GOTO 0x558A
5538  F02A     NOP
24:            		counter = 1;
553A  0E01     MOVLW 0x1
553C  6E0B     MOVWF 0xB, ACCESS
25:            		while((divisor & 0x8000U) == 0) {
553E  EFA5     GOTO 0x554A
5540  F02A     NOP
554A  AE0A     BTFSS 0xA, 7, ACCESS
554C  EFAA     GOTO 0x5554
554E  F02A     NOP
5550  EFAC     GOTO 0x5558
5552  F02A     NOP
5554  EFA1     GOTO 0x5542
5556  F02A     NOP
26:            			divisor <<= 1;
5542  90D8     BCF 0xFD8, 0, ACCESS
5544  3609     RLCF 0x9, F, ACCESS
5546  360A     RLCF 0xA, F, ACCESS
27:            			counter++;
5548  2A0B     INCF 0xB, F, ACCESS
28:            		}
29:            		do {
30:            			quotient <<= 1;
5558  90D8     BCF 0xFD8, 0, ACCESS
555A  360D     RLCF 0xD, F, ACCESS
555C  360E     RLCF 0xE, F, ACCESS
31:            			if((unsigned int)divisor <= (unsigned int)dividend) {
555E  5009     MOVF 0x9, W, ACCESS
5560  5C07     SUBWF 0x7, W, ACCESS
5562  500A     MOVF 0xA, W, ACCESS
5564  5808     SUBWFB 0x8, W, ACCESS
5566  A0D8     BTFSS 0xFD8, 0, ACCESS
5568  EFB8     GOTO 0x5570
556A  F02A     NOP
556C  EFBA     GOTO 0x5574
556E  F02A     NOP
5570  EFBF     GOTO 0x557E
5572  F02A     NOP
32:            				dividend -= divisor;
5574  5009     MOVF 0x9, W, ACCESS
5576  5E07     SUBWF 0x7, F, ACCESS
5578  500A     MOVF 0xA, W, ACCESS
557A  5A08     SUBWFB 0x8, F, ACCESS
33:            				quotient |= 1;
557C  800D     BSF 0xD, 0, ACCESS
34:            			}
35:            			*(unsigned int *)&divisor >>= 1;
557E  90D8     BCF 0xFD8, 0, ACCESS
5580  320A     RRCF 0xA, F, ACCESS
5582  3209     RRCF 0x9, F, ACCESS
36:            		} while(--counter != 0);
5584  2E0B     DECFSZ 0xB, F, ACCESS
5586  EFAC     GOTO 0x5558
5588  F02A     NOP
37:            	}
38:            	if(sign)
558A  500C     MOVF 0xC, W, ACCESS
558C  B4D8     BTFSC 0xFD8, 2, ACCESS
558E  EFCB     GOTO 0x5596
5590  F02A     NOP
5592  EFCD     GOTO 0x559A
5594  F02A     NOP
5596  EFD1     GOTO 0x55A2
5598  F02A     NOP
39:            		quotient = -quotient;
559A  6C0D     NEGF 0xD, ACCESS
559C  1E0E     COMF 0xE, F, ACCESS
559E  B0D8     BTFSC 0xFD8, 0, ACCESS
55A0  2A0E     INCF 0xE, F, ACCESS
40:            	return quotient;
55A2  C50D     MOVFF signs, s
55A4  F507     NOP
55A6  C50E     MOVFF fp, l
55A8  F508     NOP
41:            }
55AA  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.20/pic/sources/c99/common/aomod.c  -------------------------------
1:             // long long signed unsigned modulus
2:             
3:             #pragma warning disable 1516
4:             
5:             signed long long int
6:             #ifdef __PICC__
7:             __aomod(signed long long int divisor, signed long long int dividend)
8:             #else
9:             __aomod(signed long long int dividend, signed long long int divisor)
4EBC  0E00     MOVLW 0x0
4EBE  6E12     MOVWF 0x12, ACCESS
10:            #endif
11:            {
12:            	unsigned char	counter, sign;
13:            
14:            	sign = 0;
15:            	if(dividend < 0) {
4EC0  BE08     BTFSC 0x8, 7, ACCESS
4EC2  EF67     GOTO 0x4ECE
4EC4  F027     NOP
4EC6  EF65     GOTO 0x4ECA
4EC8  F027     NOP
4ECA  EF79     GOTO 0x4EF2
4ECC  F027     NOP
16:            		dividend = -dividend;
4ECE  1E08     COMF 0x8, F, ACCESS
4ED0  1E07     COMF 0x7, F, ACCESS
4ED2  1E06     COMF 0x6, F, ACCESS
4ED4  1E05     COMF 0x5, F, ACCESS
4ED6  1E04     COMF 0x4, F, ACCESS
4ED8  1E03     COMF 0x3, F, ACCESS
4EDA  1E02     COMF 0x2, F, ACCESS
4EDC  6C01     NEGF 0x1, ACCESS
4EDE  0E00     MOVLW 0x0
4EE0  2202     ADDWFC 0x2, F, ACCESS
4EE2  2203     ADDWFC 0x3, F, ACCESS
4EE4  2204     ADDWFC 0x4, F, ACCESS
4EE6  2205     ADDWFC 0x5, F, ACCESS
4EE8  2206     ADDWFC 0x6, F, ACCESS
4EEA  2207     ADDWFC 0x7, F, ACCESS
4EEC  2208     ADDWFC 0x8, F, ACCESS
17:            		sign = 1;
4EEE  0E01     MOVLW 0x1
4EF0  6E12     MOVWF 0x12, ACCESS
18:            	}
19:            	if(divisor < 0)
4EF2  BE10     BTFSC 0x10, 7, ACCESS
4EF4  EF80     GOTO 0x4F00
4EF6  F027     NOP
4EF8  EF7E     GOTO 0x4EFC
4EFA  F027     NOP
4EFC  EF90     GOTO 0x4F20
4EFE  F027     NOP
20:            		divisor = -divisor;
4F00  1E10     COMF 0x10, F, ACCESS
4F02  1E0F     COMF 0xF, F, ACCESS
4F04  1E0E     COMF 0xE, F, ACCESS
4F06  1E0D     COMF 0xD, F, ACCESS
4F08  1E0C     COMF 0xC, F, ACCESS
4F0A  1E0B     COMF 0xB, F, ACCESS
4F0C  1E0A     COMF 0xA, F, ACCESS
4F0E  6C09     NEGF 0x9, ACCESS
4F10  0E00     MOVLW 0x0
4F12  220A     ADDWFC 0xA, F, ACCESS
4F14  220B     ADDWFC 0xB, F, ACCESS
4F16  220C     ADDWFC 0xC, F, ACCESS
4F18  220D     ADDWFC 0xD, F, ACCESS
4F1A  220E     ADDWFC 0xE, F, ACCESS
4F1C  220F     ADDWFC 0xF, F, ACCESS
4F1E  2210     ADDWFC 0x10, F, ACCESS
21:            	if(divisor != 0) {
4F20  5009     MOVF 0x9, W, ACCESS
4F22  100A     IORWF 0xA, W, ACCESS
4F24  100B     IORWF 0xB, W, ACCESS
4F26  100C     IORWF 0xC, W, ACCESS
4F28  100D     IORWF 0xD, W, ACCESS
4F2A  100E     IORWF 0xE, W, ACCESS
4F2C  100F     IORWF 0xF, W, ACCESS
4F2E  1010     IORWF 0x10, W, ACCESS
4F30  B4D8     BTFSC 0xFD8, 2, ACCESS
4F32  EF9D     GOTO 0x4F3A
4F34  F027     NOP
4F36  EF9F     GOTO 0x4F3E
4F38  F027     NOP
4F3A  EFE7     GOTO 0x4FCE
4F3C  F027     NOP
22:            		counter = 1;
4F3E  0E01     MOVLW 0x1
4F40  6E11     MOVWF 0x11, ACCESS
23:            		while((divisor & 0x8000000000000000ULL) == 0) {
4F42  EFAD     GOTO 0x4F5A
4F44  F027     NOP
4F5A  AE10     BTFSS 0x10, 7, ACCESS
4F5C  EFB2     GOTO 0x4F64
4F5E  F027     NOP
4F60  EFB4     GOTO 0x4F68
4F62  F027     NOP
4F64  EFA3     GOTO 0x4F46
4F66  F027     NOP
24:            			divisor <<= 1;
4F46  90D8     BCF 0xFD8, 0, ACCESS
4F48  3609     RLCF 0x9, F, ACCESS
4F4A  360A     RLCF 0xA, F, ACCESS
4F4C  360B     RLCF 0xB, F, ACCESS
4F4E  360C     RLCF 0xC, F, ACCESS
4F50  360D     RLCF 0xD, F, ACCESS
4F52  360E     RLCF 0xE, F, ACCESS
4F54  360F     RLCF 0xF, F, ACCESS
4F56  3610     RLCF 0x10, F, ACCESS
25:            			counter++;
4F58  2A11     INCF 0x11, F, ACCESS
26:            		}
27:            		do {
28:            			if((unsigned long long)divisor <= (unsigned long long)dividend)
4F68  5009     MOVF 0x9, W, ACCESS
4F6A  5C01     SUBWF 0x1, W, ACCESS
4F6C  500A     MOVF 0xA, W, ACCESS
4F6E  5802     SUBWFB 0x2, W, ACCESS
4F70  500B     MOVF 0xB, W, ACCESS
4F72  5803     SUBWFB 0x3, W, ACCESS
4F74  500C     MOVF 0xC, W, ACCESS
4F76  5804     SUBWFB 0x4, W, ACCESS
4F78  500D     MOVF 0xD, W, ACCESS
4F7A  5805     SUBWFB 0x5, W, ACCESS
4F7C  500E     MOVF 0xE, W, ACCESS
4F7E  5806     SUBWFB 0x6, W, ACCESS
4F80  500F     MOVF 0xF, W, ACCESS
4F82  5807     SUBWFB 0x7, W, ACCESS
4F84  5010     MOVF 0x10, W, ACCESS
4F86  5808     SUBWFB 0x8, W, ACCESS
4F88  A0D8     BTFSS 0xFD8, 0, ACCESS
4F8A  EFC9     GOTO 0x4F92
4F8C  F027     NOP
4F8E  EFCB     GOTO 0x4F96
4F90  F027     NOP
4F92  EFDB     GOTO 0x4FB6
4F94  F027     NOP
29:            				dividend -= divisor;
4F96  5009     MOVF 0x9, W, ACCESS
4F98  5E01     SUBWF 0x1, F, ACCESS
4F9A  500A     MOVF 0xA, W, ACCESS
4F9C  5A02     SUBWFB 0x2, F, ACCESS
4F9E  500B     MOVF 0xB, W, ACCESS
4FA0  5A03     SUBWFB 0x3, F, ACCESS
4FA2  500C     MOVF 0xC, W, ACCESS
4FA4  5A04     SUBWFB 0x4, F, ACCESS
4FA6  500D     MOVF 0xD, W, ACCESS
4FA8  5A05     SUBWFB 0x5, F, ACCESS
4FAA  500E     MOVF 0xE, W, ACCESS
4FAC  5A06     SUBWFB 0x6, F, ACCESS
4FAE  500F     MOVF 0xF, W, ACCESS
4FB0  5A07     SUBWFB 0x7, F, ACCESS
4FB2  5010     MOVF 0x10, W, ACCESS
4FB4  5A08     SUBWFB 0x8, F, ACCESS
30:            			*(unsigned long long int *)&divisor >>= 1;
4FB6  90D8     BCF 0xFD8, 0, ACCESS
4FB8  3210     RRCF 0x10, F, ACCESS
4FBA  320F     RRCF 0xF, F, ACCESS
4FBC  320E     RRCF 0xE, F, ACCESS
4FBE  320D     RRCF 0xD, F, ACCESS
4FC0  320C     RRCF 0xC, F, ACCESS
4FC2  320B     RRCF 0xB, F, ACCESS
4FC4  320A     RRCF 0xA, F, ACCESS
4FC6  3209     RRCF 0x9, F, ACCESS
31:            		} while(--counter != 0);
4FC8  2E11     DECFSZ 0x11, F, ACCESS
4FCA  EFB4     GOTO 0x4F68
4FCC  F027     NOP
32:            	}
33:            	if(sign)
4FCE  5012     MOVF 0x12, W, ACCESS
4FD0  B4D8     BTFSC 0xFD8, 2, ACCESS
4FD2  EFED     GOTO 0x4FDA
4FD4  F027     NOP
4FD6  EFEF     GOTO 0x4FDE
4FD8  F027     NOP
4FDA  EFFF     GOTO 0x4FFE
4FDC  F027     NOP
34:            		dividend = -dividend;
4FDE  1E08     COMF 0x8, F, ACCESS
4FE0  1E07     COMF 0x7, F, ACCESS
4FE2  1E06     COMF 0x6, F, ACCESS
4FE4  1E05     COMF 0x5, F, ACCESS
4FE6  1E04     COMF 0x4, F, ACCESS
4FE8  1E03     COMF 0x3, F, ACCESS
4FEA  1E02     COMF 0x2, F, ACCESS
4FEC  6C01     NEGF 0x1, ACCESS
4FEE  0E00     MOVLW 0x0
4FF0  2202     ADDWFC 0x2, F, ACCESS
4FF2  2203     ADDWFC 0x3, F, ACCESS
4FF4  2204     ADDWFC 0x4, F, ACCESS
4FF6  2205     ADDWFC 0x5, F, ACCESS
4FF8  2206     ADDWFC 0x6, F, ACCESS
4FFA  2207     ADDWFC 0x7, F, ACCESS
4FFC  2208     ADDWFC 0x8, F, ACCESS
35:            	return dividend;
4FFE  C501     MOVFF __pcstackCOMRAM, __pcstackCOMRAM
5000  F501     NOP
5002  C502     MOVFF txData, txData
5004  F502     NOP
5006  C503     MOVFF _r, _r
5008  F503     NOP
500A  C504     MOVFF 0x504, 0x504
500C  F504     NOP
500E  C505     MOVFF n, n
5010  F505     NOP
5012  C506     MOVFF sign, sign
5014  F506     NOP
5016  C507     MOVFF s, s
5018  F507     NOP
501A  C508     MOVFF l, l
501C  F508     NOP
36:            }
501E  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.20/pic/sources/c99/common/aodiv.c  -------------------------------
1:             // long long signed unsigned division
2:             
3:             #pragma warning disable 1516
4:             
5:             signed long long int
6:             #ifdef __PICC__
7:             __aodiv(signed long long int divisor, signed long long int dividend)
8:             #else
9:             __aodiv(signed long long int dividend, signed long long int divisor)
4D34  0E00     MOVLW 0x0
4D36  6E12     MOVWF 0x12, ACCESS
10:            #endif
11:            {
12:            	signed long long int	quotient;
13:            	unsigned char	counter, sign;
14:            
15:            	sign = 0;
16:            	if(divisor < 0) {
4D38  BE10     BTFSC 0x10, 7, ACCESS
4D3A  EFA3     GOTO 0x4D46
4D3C  F026     NOP
4D3E  EFA1     GOTO 0x4D42
4D40  F026     NOP
4D42  EFB5     GOTO 0x4D6A
4D44  F026     NOP
17:            		divisor = -divisor;
4D46  1E10     COMF 0x10, F, ACCESS
4D48  1E0F     COMF 0xF, F, ACCESS
4D4A  1E0E     COMF 0xE, F, ACCESS
4D4C  1E0D     COMF 0xD, F, ACCESS
4D4E  1E0C     COMF 0xC, F, ACCESS
4D50  1E0B     COMF 0xB, F, ACCESS
4D52  1E0A     COMF 0xA, F, ACCESS
4D54  6C09     NEGF 0x9, ACCESS
4D56  0E00     MOVLW 0x0
4D58  220A     ADDWFC 0xA, F, ACCESS
4D5A  220B     ADDWFC 0xB, F, ACCESS
4D5C  220C     ADDWFC 0xC, F, ACCESS
4D5E  220D     ADDWFC 0xD, F, ACCESS
4D60  220E     ADDWFC 0xE, F, ACCESS
4D62  220F     ADDWFC 0xF, F, ACCESS
4D64  2210     ADDWFC 0x10, F, ACCESS
18:            		sign = 1;
4D66  0E01     MOVLW 0x1
4D68  6E12     MOVWF 0x12, ACCESS
19:            	}
20:            	if(dividend < 0) {
4D6A  BE08     BTFSC 0x8, 7, ACCESS
4D6C  EFBC     GOTO 0x4D78
4D6E  F026     NOP
4D70  EFBA     GOTO 0x4D74
4D72  F026     NOP
4D74  EFCE     GOTO 0x4D9C
4D76  F026     NOP
21:            		dividend = -dividend;
4D78  1E08     COMF 0x8, F, ACCESS
4D7A  1E07     COMF 0x7, F, ACCESS
4D7C  1E06     COMF 0x6, F, ACCESS
4D7E  1E05     COMF 0x5, F, ACCESS
4D80  1E04     COMF 0x4, F, ACCESS
4D82  1E03     COMF 0x3, F, ACCESS
4D84  1E02     COMF 0x2, F, ACCESS
4D86  6C01     NEGF 0x1, ACCESS
4D88  0E00     MOVLW 0x0
4D8A  2202     ADDWFC 0x2, F, ACCESS
4D8C  2203     ADDWFC 0x3, F, ACCESS
4D8E  2204     ADDWFC 0x4, F, ACCESS
4D90  2205     ADDWFC 0x5, F, ACCESS
4D92  2206     ADDWFC 0x6, F, ACCESS
4D94  2207     ADDWFC 0x7, F, ACCESS
4D96  2208     ADDWFC 0x8, F, ACCESS
22:            		sign ^= 1;
4D98  0E01     MOVLW 0x1
4D9A  1A12     XORWF 0x12, F, ACCESS
23:            	}
24:            	quotient = 0;
4D9C  EE21     LFSR 2, 0x513
4D9E  F113     NOP
4DA0  0E07     MOVLW 0x7
4DA2  6ADE     CLRF 0xFDE, ACCESS
4DA4  06E8     DECF 0xFE8, F, ACCESS
4DA6  E2FD     BC 0x4DA2
25:            	if(divisor != 0) {
4DA8  5009     MOVF 0x9, W, ACCESS
4DAA  100A     IORWF 0xA, W, ACCESS
4DAC  100B     IORWF 0xB, W, ACCESS
4DAE  100C     IORWF 0xC, W, ACCESS
4DB0  100D     IORWF 0xD, W, ACCESS
4DB2  100E     IORWF 0xE, W, ACCESS
4DB4  100F     IORWF 0xF, W, ACCESS
4DB6  1010     IORWF 0x10, W, ACCESS
4DB8  B4D8     BTFSC 0xFD8, 2, ACCESS
4DBA  EFE1     GOTO 0x4DC2
4DBC  F026     NOP
4DBE  EFE3     GOTO 0x4DC6
4DC0  F026     NOP
4DC2  EF35     GOTO 0x4E6A
4DC4  F027     NOP
26:            		counter = 1;
4DC6  0E01     MOVLW 0x1
4DC8  6E11     MOVWF 0x11, ACCESS
27:            		while((divisor & 0x8000000000000000ULL) == 0) {
4DCA  EFF1     GOTO 0x4DE2
4DCC  F026     NOP
4DE2  AE10     BTFSS 0x10, 7, ACCESS
4DE4  EFF6     GOTO 0x4DEC
4DE6  F026     NOP
4DE8  EFF8     GOTO 0x4DF0
4DEA  F026     NOP
4DEC  EFE7     GOTO 0x4DCE
4DEE  F026     NOP
28:            			divisor <<= 1;
4DCE  90D8     BCF 0xFD8, 0, ACCESS
4DD0  3609     RLCF 0x9, F, ACCESS
4DD2  360A     RLCF 0xA, F, ACCESS
4DD4  360B     RLCF 0xB, F, ACCESS
4DD6  360C     RLCF 0xC, F, ACCESS
4DD8  360D     RLCF 0xD, F, ACCESS
4DDA  360E     RLCF 0xE, F, ACCESS
4DDC  360F     RLCF 0xF, F, ACCESS
4DDE  3610     RLCF 0x10, F, ACCESS
29:            			counter++;
4DE0  2A11     INCF 0x11, F, ACCESS
30:            		}
31:            		do {
32:            			quotient <<= 1;
4DF0  90D8     BCF 0xFD8, 0, ACCESS
4DF2  3613     RLCF 0x13, F, ACCESS
4DF4  3614     RLCF 0x14, F, ACCESS
4DF6  3615     RLCF 0x15, F, ACCESS
4DF8  3616     RLCF 0x16, F, ACCESS
4DFA  3617     RLCF 0x17, F, ACCESS
4DFC  3618     RLCF 0x18, F, ACCESS
4DFE  3619     RLCF 0x19, F, ACCESS
4E00  361A     RLCF 0x1A, F, ACCESS
33:            			if((unsigned long long)divisor <= (unsigned long long)dividend) {
4E02  5009     MOVF 0x9, W, ACCESS
4E04  5C01     SUBWF 0x1, W, ACCESS
4E06  500A     MOVF 0xA, W, ACCESS
4E08  5802     SUBWFB 0x2, W, ACCESS
4E0A  500B     MOVF 0xB, W, ACCESS
4E0C  5803     SUBWFB 0x3, W, ACCESS
4E0E  500C     MOVF 0xC, W, ACCESS
4E10  5804     SUBWFB 0x4, W, ACCESS
4E12  500D     MOVF 0xD, W, ACCESS
4E14  5805     SUBWFB 0x5, W, ACCESS
4E16  500E     MOVF 0xE, W, ACCESS
4E18  5806     SUBWFB 0x6, W, ACCESS
4E1A  500F     MOVF 0xF, W, ACCESS
4E1C  5807     SUBWFB 0x7, W, ACCESS
4E1E  5010     MOVF 0x10, W, ACCESS
4E20  5808     SUBWFB 0x8, W, ACCESS
4E22  A0D8     BTFSS 0xFD8, 0, ACCESS
4E24  EF16     GOTO 0x4E2C
4E26  F027     NOP
4E28  EF18     GOTO 0x4E30
4E2A  F027     NOP
4E2C  EF29     GOTO 0x4E52
4E2E  F027     NOP
34:            				dividend -= divisor;
4E30  5009     MOVF 0x9, W, ACCESS
4E32  5E01     SUBWF 0x1, F, ACCESS
4E34  500A     MOVF 0xA, W, ACCESS
4E36  5A02     SUBWFB 0x2, F, ACCESS
4E38  500B     MOVF 0xB, W, ACCESS
4E3A  5A03     SUBWFB 0x3, F, ACCESS
4E3C  500C     MOVF 0xC, W, ACCESS
4E3E  5A04     SUBWFB 0x4, F, ACCESS
4E40  500D     MOVF 0xD, W, ACCESS
4E42  5A05     SUBWFB 0x5, F, ACCESS
4E44  500E     MOVF 0xE, W, ACCESS
4E46  5A06     SUBWFB 0x6, F, ACCESS
4E48  500F     MOVF 0xF, W, ACCESS
4E4A  5A07     SUBWFB 0x7, F, ACCESS
4E4C  5010     MOVF 0x10, W, ACCESS
4E4E  5A08     SUBWFB 0x8, F, ACCESS
35:            				quotient |= 1;
4E50  8013     BSF 0x13, 0, ACCESS
36:            			}
37:            			*(unsigned long long int *)&divisor >>= 1;
4E52  90D8     BCF 0xFD8, 0, ACCESS
4E54  3210     RRCF 0x10, F, ACCESS
4E56  320F     RRCF 0xF, F, ACCESS
4E58  320E     RRCF 0xE, F, ACCESS
4E5A  320D     RRCF 0xD, F, ACCESS
4E5C  320C     RRCF 0xC, F, ACCESS
4E5E  320B     RRCF 0xB, F, ACCESS
4E60  320A     RRCF 0xA, F, ACCESS
4E62  3209     RRCF 0x9, F, ACCESS
38:            		} while(--counter != 0);
4E64  2E11     DECFSZ 0x11, F, ACCESS
4E66  EFF8     GOTO 0x4DF0
4E68  F026     NOP
39:            	}
40:            	if(sign)
4E6A  5012     MOVF 0x12, W, ACCESS
4E6C  B4D8     BTFSC 0xFD8, 2, ACCESS
4E6E  EF3B     GOTO 0x4E76
4E70  F027     NOP
4E72  EF3D     GOTO 0x4E7A
4E74  F027     NOP
4E76  EF4D     GOTO 0x4E9A
4E78  F027     NOP
41:            		quotient = -quotient;
4E7A  1E1A     COMF 0x1A, F, ACCESS
4E7C  1E19     COMF 0x19, F, ACCESS
4E7E  1E18     COMF 0x18, F, ACCESS
4E80  1E17     COMF 0x17, F, ACCESS
4E82  1E16     COMF 0x16, F, ACCESS
4E84  1E15     COMF 0x15, F, ACCESS
4E86  1E14     COMF 0x14, F, ACCESS
4E88  6C13     NEGF 0x13, ACCESS
4E8A  0E00     MOVLW 0x0
4E8C  2214     ADDWFC 0x14, F, ACCESS
4E8E  2215     ADDWFC 0x15, F, ACCESS
4E90  2216     ADDWFC 0x16, F, ACCESS
4E92  2217     ADDWFC 0x17, F, ACCESS
4E94  2218     ADDWFC 0x18, F, ACCESS
4E96  2219     ADDWFC 0x19, F, ACCESS
4E98  221A     ADDWFC 0x1A, F, ACCESS
42:            	return quotient;
4E9A  C513     MOVFF quotient, __pcstackCOMRAM
4E9C  F501     NOP
4E9E  C514     MOVFF 0x514, txData
4EA0  F502     NOP
4EA2  C515     MOVFF buf, _r
4EA4  F503     NOP
4EA6  C516     MOVFF 0x516, 0x504
4EA8  F504     NOP
4EAA  C517     MOVFF p, n
4EAC  F505     NOP
4EAE  C518     MOVFF 0x518, sign
4EB0  F506     NOP
4EB2  C519     MOVFF 0x519, s
4EB4  F507     NOP
4EB6  C51A     MOVFF i, l
4EB8  F508     NOP
43:            }
4EBA  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.20/pic/sources/c99/common/abs.c  ---------------------------------
1:             int abs(int a)
5AFE  BE14     BTFSC 0x14, 7, ACCESS
5B00  EF8C     GOTO 0x5B18
5B02  F02D     NOP
5B04  5014     MOVF 0x14, W, ACCESS
5B06  E106     BNZ 0x5B14
5B08  0413     DECF 0x13, W, ACCESS
5B0A  B0D8     BTFSC 0xFD8, 0, ACCESS
5B0C  EF8A     GOTO 0x5B14
5B0E  F02D     NOP
5B10  EF8C     GOTO 0x5B18
5B12  F02D     NOP
5B14  EF9A     GOTO 0x5B34
5B16  F02D     NOP
5B18  C513     MOVFF quotient, buf
5B1A  F515     NOP
5B1C  C514     MOVFF 0x514, 0x516
5B1E  F516     NOP
5B20  1E15     COMF 0x15, F, ACCESS
5B22  1E16     COMF 0x16, F, ACCESS
5B24  4A15     INFSNZ 0x15, F, ACCESS
5B26  2A16     INCF 0x16, F, ACCESS
5B28  C515     MOVFF buf, quotient
5B2A  F513     NOP
5B2C  C516     MOVFF 0x516, 0x514
5B2E  F514     NOP
5B30  EF9E     GOTO 0x5B3C
5B32  F02D     NOP
5B34  C513     MOVFF quotient, quotient
5B36  F513     NOP
5B38  C514     MOVFF 0x514, 0x514
5B3A  F514     NOP
2:             {
3:             	return a>0 ? a : -a;
4:             }
5B3C  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.20/pic/sources/c99/common/__fpclassifyf.c  -----------------------
1:             #include <math.h>
2:             #include <stdint.h>
3:             
4:             int __fpclassifyf(float x)
522A  C5D5     MOVFF F463, arg
522C  F50B     NOP
522E  C5D6     MOVFF 0x5D6, s
5230  F50C     NOP
5232  C5D7     MOVFF 0x5D7, signs
5234  F50D     NOP
5236  C5D8     MOVFF 0x5D8, fp
5238  F50E     NOP
523A  C501     MOVFF __pcstackCOMRAM, arg
523C  F50B     NOP
523E  C502     MOVFF txData, s
5240  F50C     NOP
5242  C503     MOVFF _r, signs
5244  F50D     NOP
5246  C504     MOVFF 0x504, fp
5248  F50E     NOP
5:             {
6:             	union {float f; uint32_t i;} u = {x};
7:             	int e = u.i>>23 & 0xff;
524A  C50B     MOVFF arg, n
524C  F505     NOP
524E  C50C     MOVFF s, sign
5250  F506     NOP
5252  C50D     MOVFF signs, s
5254  F507     NOP
5256  C50E     MOVFF fp, l
5258  F508     NOP
525A  0E18     MOVLW 0x18
525C  EF35     GOTO 0x526A
525E  F029     NOP
5260  90D8     BCF 0xFD8, 0, ACCESS
5262  3208     RRCF 0x8, F, ACCESS
5264  3207     RRCF 0x7, F, ACCESS
5266  3206     RRCF 0x6, F, ACCESS
5268  3205     RRCF 0x5, F, ACCESS
526A  2EE8     DECFSZ 0xFE8, F, ACCESS
526C  EF30     GOTO 0x5260
526E  F029     NOP
5270  5005     MOVF 0x5, W, ACCESS
5272  6E09     MOVWF 0x9, ACCESS
5274  6A0A     CLRF 0xA, ACCESS
8:             	if (!e) return u.i<<1 ? FP_SUBNORMAL : FP_ZERO;
5276  5009     MOVF 0x9, W, ACCESS
5278  100A     IORWF 0xA, W, ACCESS
527A  A4D8     BTFSS 0xFD8, 2, ACCESS
527C  EF42     GOTO 0x5284
527E  F029     NOP
5280  EF44     GOTO 0x5288
5282  F029     NOP
5284  EF64     GOTO 0x52C8
5286  F029     NOP
5288  90D8     BCF 0xFD8, 0, ACCESS
528A  340B     RLCF 0xB, W, ACCESS
528C  6E05     MOVWF 0x5, ACCESS
528E  340C     RLCF 0xC, W, ACCESS
5290  6E06     MOVWF 0x6, ACCESS
5292  340D     RLCF 0xD, W, ACCESS
5294  6E07     MOVWF 0x7, ACCESS
5296  340E     RLCF 0xE, W, ACCESS
5298  6E08     MOVWF 0x8, ACCESS
529A  5005     MOVF 0x5, W, ACCESS
529C  1006     IORWF 0x6, W, ACCESS
529E  1007     IORWF 0x7, W, ACCESS
52A0  1008     IORWF 0x8, W, ACCESS
52A2  A4D8     BTFSS 0xFD8, 2, ACCESS
52A4  EF56     GOTO 0x52AC
52A6  F029     NOP
52A8  EF58     GOTO 0x52B0
52AA  F029     NOP
52AC  EF5E     GOTO 0x52BC
52AE  F029     NOP
52B0  0E00     MOVLW 0x0
52B2  6E02     MOVWF 0x2, ACCESS
52B4  0E02     MOVLW 0x2
52B6  6E01     MOVWF 0x1, ACCESS
52B8  EF93     GOTO 0x5326
52BA  F029     NOP
52BC  0E00     MOVLW 0x0
52BE  6E02     MOVWF 0x2, ACCESS
52C0  0E03     MOVLW 0x3
52C2  6E01     MOVWF 0x1, ACCESS
52C4  EF93     GOTO 0x5326
52C6  F029     NOP
9:             	if (e==0xff) return u.i<<9 ? FP_NAN : FP_INFINITE;
52C8  2809     INCF 0x9, W, ACCESS
52CA  100A     IORWF 0xA, W, ACCESS
52CC  A4D8     BTFSS 0xFD8, 2, ACCESS
52CE  EF6B     GOTO 0x52D6
52D0  F029     NOP
52D2  EF6D     GOTO 0x52DA
52D4  F029     NOP
52D6  EF8F     GOTO 0x531E
52D8  F029     NOP
52DA  C50B     MOVFF arg, n
52DC  F505     NOP
52DE  C50C     MOVFF s, sign
52E0  F506     NOP
52E2  C50D     MOVFF signs, s
52E4  F507     NOP
52E6  C50E     MOVFF fp, l
52E8  F508     NOP
52EA  0E09     MOVLW 0x9
52EC  90D8     BCF 0xFD8, 0, ACCESS
52EE  3605     RLCF 0x5, F, ACCESS
52F0  3606     RLCF 0x6, F, ACCESS
52F2  3607     RLCF 0x7, F, ACCESS
52F4  3608     RLCF 0x8, F, ACCESS
52F6  2EE8     DECFSZ 0xFE8, F, ACCESS
52F8  EF76     GOTO 0x52EC
52FA  F029     NOP
52FC  5005     MOVF 0x5, W, ACCESS
52FE  1006     IORWF 0x6, W, ACCESS
5300  1007     IORWF 0x7, W, ACCESS
5302  1008     IORWF 0x8, W, ACCESS
5304  B4D8     BTFSC 0xFD8, 2, ACCESS
5306  EF87     GOTO 0x530E
5308  F029     NOP
530A  EF8A     GOTO 0x5314
530C  F029     NOP
530E  0E01     MOVLW 0x1
5310  EF8B     GOTO 0x5316
5312  F029     NOP
5314  0E00     MOVLW 0x0
5316  6E01     MOVWF 0x1, ACCESS
5318  6A02     CLRF 0x2, ACCESS
531A  EF93     GOTO 0x5326
531C  F029     NOP
10:            	return FP_NORMAL;
531E  0E00     MOVLW 0x0
5320  6E02     MOVWF 0x2, ACCESS
5322  0E04     MOVLW 0x4
5324  6E01     MOVWF 0x1, ACCESS
11:            }
5326  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.20/pic/sources/c99/common/Umul16.c  ------------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned int
15:            __wmul(unsigned int multiplier, unsigned int multiplicand)
5C1C  5001     MOVF 0x1, W, ACCESS
5C1E  0203     MULWF 0x3, ACCESS
5C22  F3CC     NOP
5C24  F505     NOP
5C28  F3D0     NOP
5C2A  F506     NOP
16:            {
17:                    unsigned int product;
18:            
19:            #if _Has_hardware_multiply || _Has_large_call_stack
20:            
21:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:            
24:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:            /*
26:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                   a  b
28:            *      c  d
29:            -----------
30:                 |   bd
31:                 |ad  0
32:                 |bc  0
33:            +  ac| 0  0 (we ignore this intermediate product
34:                         because it does not affect the low 16 bits of the result)
35:            ===========
36:             */
37:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
38:                    product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
5C2C  5001     MOVF 0x1, W, ACCESS
5C2E  0204     MULWF 0x4, ACCESS
5C30  50F3     MOVF 0xFF3, W, ACCESS
5C32  2606     ADDWF 0x6, F, ACCESS
39:                    product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
5C34  5002     MOVF 0x2, W, ACCESS
5C36  0203     MULWF 0x3, ACCESS
5C38  50F3     MOVF 0xFF3, W, ACCESS
5C3A  2606     ADDWF 0x6, F, ACCESS
40:            
41:            #else
42:            
43:            	product = 0;
44:            	do {
45:            		if(multiplier & 1)
46:            			product += multiplicand;
47:            		multiplicand <<= 1;
48:            		multiplier >>= 1;
49:            	} while(multiplier != 0);
50:            
51:            #endif
52:                    return product;
5C3C  C505     MOVFF n, __pcstackCOMRAM
5C3E  F501     NOP
5C40  C506     MOVFF sign, txData
5C42  F502     NOP
53:            }
5C44  0012     RETURN 0
